

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="JunBin">
  <meta name="keywords" content="">
  
    <meta name="description" content="简单易用的 C++11 新特性 重构代码时提炼几点有用的 C++11 新特性，能够帮助大家写出更加优雅的 C++ 代码。 强制类型转换     描述     const_cast -   static_cast 隐式转换   dynamic_cast 安全的下行转换   reinterpret_cast 不安全、无条件的编译期转换    右值语义  如何移动一头大象？在第二个冰箱中启动量子复制系">
<meta property="og:type" content="article">
<meta property="og:title" content="Useful And Easy New Features Of Cpp11">
<meta property="og:url" content="https://clcanny.github.io/2019/07/16/computer-science/programming-language/c++/useful-and-easy-new-features-of-cpp11/index.html">
<meta property="og:site_name" content="On The Road">
<meta property="og:description" content="简单易用的 C++11 新特性 重构代码时提炼几点有用的 C++11 新特性，能够帮助大家写出更加优雅的 C++ 代码。 强制类型转换     描述     const_cast -   static_cast 隐式转换   dynamic_cast 安全的下行转换   reinterpret_cast 不安全、无条件的编译期转换    右值语义  如何移动一头大象？在第二个冰箱中启动量子复制系">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-and-easy-new-features-of-Cpp11/polymorphic-of-prvalue-reference.jpg">
<meta property="og:image" content="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-and-easy-new-features-of-Cpp11/prvalue-left-operand.png">
<meta property="article:published_time" content="2019-07-16T14:14:15.000Z">
<meta property="article:modified_time" content="2024-10-30T15:47:28.515Z">
<meta property="article:author" content="JunBin">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-and-easy-new-features-of-Cpp11/polymorphic-of-prvalue-reference.jpg">
  
  
  
  <title>Useful And Easy New Features Of Cpp11 - On The Road</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"clcanny.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0-rc1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Useful And Easy New Features Of Cpp11"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2019-07-16 22:14" pubdate>
          2019年7月16日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          142 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Useful And Easy New Features Of Cpp11</h1>
            
            
              <div class="markdown-body">
                
                <span id="more"></span>
<h1 id="简单易用的-c11-新特性">简单易用的 C++11 新特性</h1>
<p>重构代码时提炼几点有用的 C++11 新特性，能够帮助大家写出更加优雅的 C++ 代码。</p>
<h2 id="强制类型转换">强制类型转换</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">const_cast</td>
<td style="text-align: center;">-</td>
</tr>
<tr class="even">
<td style="text-align: center;">static_cast</td>
<td style="text-align: center;">隐式转换</td>
</tr>
<tr class="odd">
<td style="text-align: center;">dynamic_cast</td>
<td style="text-align: center;">安全的下行转换</td>
</tr>
<tr class="even">
<td style="text-align: center;">reinterpret_cast</td>
<td style="text-align: center;">不安全、无条件的编译期转换</td>
</tr>
</tbody>
</table>
<h2 id="右值语义">右值语义</h2>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/22111546/answer/30801982">如何移动一头大象？</a>在第二个冰箱中启动量子复制系统，克隆一只完全相同的大象，然后启动高能激光将第一个冰箱内的大象气化消失。</p>
</blockquote>
<h3 id="value-categories">Value categories</h3>
<blockquote>
<p>Each C++ expression is characterized by two independent properties: a <em>type</em> and a <em>value category</em>.</p>
</blockquote>
<p>参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">Stroustrup 叙述 C++11 值类型取名历程</a>，整理出判断值类型的表：</p>
<ul>
<li>Has identity
<ul>
<li>It's possible to determine whether the expression refers to the same entity as another expression, such as by comparing addressses of the objects or the functions they identity (obtained directly or indirectly).</li>
</ul></li>
<li>Can be moved from
<ul>
<li>Move constructor, move assignments operator, or another function overload that implements move semantics can bind to the expression.</li>
<li>The resource will not be used in another place or be discarded by explicitly.</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">has identity</th>
<th style="text-align: center;">hasn't identity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">can be moved from</td>
<td style="text-align: center;">xvalue</td>
<td style="text-align: center;">prvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">can't be moved from</td>
<td style="text-align: center;">lvalue</td>
<td style="text-align: center;">-</td>
</tr>
</tbody>
</table>
<p>glvaue (generalized lvalue) = xvalue + lvalue</p>
<p>rvalue = xvalue + prvalue</p>
<p>根据 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">cppreference</a> 的描述，整理出值类型的属性：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">lvalue</th>
<th style="text-align: center;">xvalue</th>
<th style="text-align: center;">prvalue</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">取地址</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="even">
<td style="text-align: center;">出现在 built-in assignment 的左侧</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="odd">
<td style="text-align: center;">polymorphic 静态类型与实际类型不一致</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="even">
<td style="text-align: center;">initialize a lvalue reference</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">N</td>
</tr>
<tr class="odd">
<td style="text-align: center;">initialize an rvalue reference</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="even">
<td style="text-align: center;">initialize a const lvalue reference</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
</tr>
<tr class="odd">
<td style="text-align: center;">绑定引用会延长生命周期</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">N</td>
<td style="text-align: center;">Y</td>
</tr>
</tbody>
</table>
<h4 id="compiler-is-a-liar">Compiler is a liar</h4>
<h5 id="prvalue-不支持多态">prvalue 不支持多态？</h5>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/15482508/what-is-an-example-of-a-difference-in-allowed-usage-or-behavior-between-an-xvalu">SO</a> 对 <strong>prvalue 不支持多态</strong> 有一个看似合理的解释：</p>
<blockquote>
<p>Correspondingly, because a prvalue's static type is guaranteed to be its dynamic type, extending its lifetime is meaningful and can be done by the compiler. On the other hand, for the xvalue, the object is at some unknown, arbitrary location, so the compiler couldn't easily extend its lifetime, especially given that the type could be polymorphic.</p>
</blockquote>
<p>延长 prvalue 需要确保编译器看到的类型（静态类型）是对象的真实类型（动态类型），否则编译器不知道该如何回收栈空间</p>
<figure>
<img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-and-easy-new-features-of-Cpp11/polymorphic-of-prvalue-reference.jpg" srcset="/img/loading.gif" lazyload alt="" /><figcaption>polymorphic-of-prvalue-reference</figcaption>
</figure>
<p>prvalue reference 延长 prvalue 生命周期在 clang7 的实现方式：</p>
<ol type="1">
<li>临时变量转正：栈顶指针在函数调用后移动到返回值之上（更低的地址）</li>
<li>使用多态指针指向转正后的临时变量</li>
</ol>
<p>至少在 clang 7 的实现方式下，prvalue 是可以使用多态的</p>
<p>严格意义上说，编译器应该在编译期拒绝 polymorphic prvalue reference ，以符合标准</p>
<p>标准没有规定引用必须实现成指针，因而上图斜上方的实现方法在 prvalue 的场景下也是可行的，但这种实现方法就必须拒绝 polymorphic prvalue reference ，否则运行期会出现非预期的行为</p>
<h5 id="rvalue-不能出现在赋值表达式的左侧">rvalue 不能出现在赋值表达式的左侧？</h5>
<p>xvalue 是具名变量，出现在赋值表达式左侧是可以理解的，那么 prvalue 呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang version 8.0.1-svn363027-1~exp1~20190611210016.75 (branches/release_80)<br>Target: x86_64-pc-linux-gnu<br>Thread model: posix<br>InstalledDir: /usr/bin<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// clang++-8 -std=c++11 -emit-llvm -S prvalue.cpp</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<br><span class="hljs-function">Test <span class="hljs-title">Make</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Test</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Make</span>() = <span class="hljs-built_in">Test</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ll">define dso_local i32 @main() #2 &#123;<br>  %1 = alloca %struct.Test, align 8<br>  %2 = alloca %struct.Test, align 8<br>  %3 = bitcast %struct.Test* %1 to i8*<br>  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 8, i1 false)<br>  call void @_ZN4TestC2Ev(%struct.Test* %1) #3<br>  call void @_Z4Makev(%struct.Test* sret %2)<br>  %4 = call %struct.Test* @_ZN4TestaSEOS_(%struct.Test* %2, %struct.Test* %1) #3<br>  ret i32 0<br>&#125;<br></code></pre></td></tr></table></figure>
<p>笔者稍稍修改 <code>main</code> 函数，去除掉对理解没有帮助的修饰符 <code>dereferenceable</code></p>
<figure>
<img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-and-easy-new-features-of-Cpp11/prvalue-left-operand.png" srcset="/img/loading.gif" lazyload alt="" /><figcaption>prvalue-left-operand</figcaption>
</figure>
<p>Clang8 并没有立即消除本应该失去生命周期的变量，因而 prvalue 可以被赋值</p>
<p>再看以下一段更加直观的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include &lt;iostream&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Test</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function">Test <span class="hljs-title">Make</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Test</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Make</span>() = <span class="hljs-built_in">Test</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">operator=<br>~Test()<br>~Test()<br></code></pre></td></tr></table></figure>
<p>在为 prvalue 赋值的场景下，Clang 8 延长了临时变量的生命周期至函数结束</p>
<p>但对于基础类型（如 <code>int</code> ），其右值仍然不可出现在辅助表达式左侧（这是编译器的一个谎言）</p>
<p>如果自行实现一个严格控制变量声明周期的编译器，<code>prvalue</code> 则不能出现在赋值表达式左侧</p>
<h4 id="some-specific-rules">Some specific rules</h4>
<h5 id="rvalue-reference-is-a-lvalue">rvalue reference is a lvalue</h5>
<blockquote>
<p>Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories.</p>
</blockquote>
<p>划重点：non-reference type, value category</p>
<p>不妨定义一个二元组 [non reference type, value category] 来描述表达式分类，取名为 full type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t1;<br>    Test&amp;&amp; r = std::<span class="hljs-built_in">move</span>(t1);<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(r)</span></span>; <span class="hljs-comment">// copy constructor</span><br><br>    <span class="hljs-function">Test <span class="hljs-title">t3</span><span class="hljs-params">(std::move(t1))</span></span>; <span class="hljs-comment">// move constructor</span><br>    <span class="hljs-function">Test <span class="hljs-title">t4</span><span class="hljs-params">(std::move(r))</span></span>; <span class="hljs-comment">// move constructor</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码来自 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues/9552880#9552880">SO</a> ：如何解释 <code>Test t2(r)</code> 调用拷贝构造函数而不是移动构造函数？一种合理的解释如下：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">type</th>
<th style="text-align: center;">value category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">std::move(t1)</td>
<td style="text-align: center;">Test</td>
<td style="text-align: center;">rvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">r</td>
<td style="text-align: center;">rvalue reference of Test</td>
<td style="text-align: center;">lvalue</td>
</tr>
</tbody>
</table>
<p>full type 必须是 non reference type ，rvalue reference of Test 不满足定义，不妨直接删掉 reference 部分</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">type</th>
<th style="text-align: center;">value category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">std::move(t1)</td>
<td style="text-align: center;">Test</td>
<td style="text-align: center;">rvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">r</td>
<td style="text-align: center;"><del>rvalue reference of</del> Test</td>
<td style="text-align: center;">rvalue</td>
</tr>
</tbody>
</table>
<p>所以编译器选择拷贝构造函数而不是移动构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t1;<br>    Test&amp;&amp; r1 = std::<span class="hljs-built_in">move</span>(t1);<br>    Test&amp;&amp; r2 = std::<span class="hljs-built_in">move</span>(r1);<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(r2)</span></span>; <span class="hljs-comment">// copy constructor</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>类似地，编译器在决策 <code>t2(r2)</code> 调用哪一个构造函数的时候，也有一个类似的过程：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">type</th>
<th style="text-align: center;">value category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">std::move(t1)</td>
<td style="text-align: center;">Test</td>
<td style="text-align: center;">rvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">r1</td>
<td style="text-align: center;"><del>rvalue reference of</del> Test</td>
<td style="text-align: center;">lvalue</td>
</tr>
<tr class="odd">
<td style="text-align: center;">std::move(r1)</td>
<td style="text-align: center;">Test</td>
<td style="text-align: center;">rvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">r2</td>
<td style="text-align: center;"><del>rvalue reference of</del> Test</td>
<td style="text-align: center;">rvalue</td>
</tr>
</tbody>
</table>
<h6 id="why-rvalue-reference-cant-be-a-rvalue">Why rvalue reference can't be a rvalue?</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UpperCaseInPlace</span><span class="hljs-params">(string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">transform</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), str.<span class="hljs-built_in">begin</span>(), ::toupper);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;call lvalue version&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">upperCaseStr</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-built_in">UpperCaseInPlace</span>(upperCaseStr);<br>    <span class="hljs-keyword">return</span> upperCaseStr == str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(string&amp;&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;call rvalue version&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">upperCaseStr</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-built_in">UpperCaseInPlace</span>(upperCaseStr);<br>    <span class="hljs-keyword">return</span> upperCaseStr == str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;a long string&quot;</span>;<br>    <span class="hljs-built_in">compare</span>(str);<br>    <span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;a long string&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上代码能够取得较优的性能：对于为右值的 string ，省去一次拷贝构造（省去一次 memcpy ）</p>
<p>聚焦于 compare 函数的 rvalue 版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(string&amp;&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;call rvalue version&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">upperCaseStr</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-built_in">UpperCaseInPlace</span>(upperCaseStr);<br>    <span class="hljs-keyword">return</span> upperCaseStr == str;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>假设推翻 C++11 的设计，右值引用也是右值，compare 函数的 rvalue 版本实现起来比较困难：期望通过拷贝一个右值引用得到一个全新的字符串 <code>upperCaseStr</code></p>
<p>所以 C++11 现在的设计：<strong>右值引用不是右值</strong>具备一定的合理性</p>
<h5 id="value-category-of-function-return-value-isnt-value-category-of-function-call">value category of function return value isn't value category of function call</h5>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">value category of function return value</th>
<th style="text-align: center;">value catrgory of function call</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">lvalue reference</td>
<td style="text-align: center;">lvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">rvalue reference to function</td>
<td style="text-align: center;">lvalue</td>
</tr>
<tr class="odd">
<td style="text-align: center;">rvalue reference to object</td>
<td style="text-align: center;">xvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">non-reference</td>
<td style="text-align: center;">rvalue</td>
</tr>
</tbody>
</table>
<h4 id="why-we-need-xvalue">Why we need xvalue ?</h4>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues/9552880#9552880">SO</a> 的回答认为 xvalue 和 prvalue 的最大差别是 xvalue 可以出现在赋值表达式左侧而 prvalue 不可以，然而笔者认为这个说法是错的：</p>
<ol type="1">
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category">cppreference</a> 明确提到：An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators. xvalue 和 prvalue 按照标准都不允许出现在赋值表达式的左侧</li>
<li>在 <strong>Compiler is a liar</strong> 一节讨论过 Clang 对非基础类型的 rvalue 出现在赋值表达式左侧的处理方式，非基础类型的 xvalue 和 prvalue 都可以出现在赋值表达式的左侧</li>
</ol>
<p>需要 xvalue 的原因是它既有名字又可以移动，既不是 lvalue 又不是 prvalue</p>
<h4 id="xvalue-如何产生">xvalue 如何产生？</h4>
<ol type="1">
<li>a function call whose return type is rvalue reference to object, such as <code>std::move(x)</code></li>
<li><code>a[n]</code>, the built-in <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_subscript_operator">subscript</a> expression, where one operand is an array rvalue</li>
<li><code>a.m</code>, the <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators">member of object</a> expression, where <code>a</code> is an rvalue and <code>m</code> is a non-static data member of non-reference type</li>
</ol>
<table>

<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">has identity</th>
<th style="text-align: center;">can be move from</th>
<th style="text-align: center;">value category</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;">看上去 function call 没有 identity <br>但函数返回的引用一般来自函数实参或全局变量<br>Y</td>
<td style="text-align: center;">Y<br>返回右值引用的目的是使得调用者获得右值</td>
<td style="text-align: center;">xvalue</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">n 是 identity<br>Y</td>
<td style="text-align: center;">Y<br>为什么可移动？</td>
<td style="text-align: center;">xvalue</td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: center;">m 是 identity<br>Y</td>
<td style="text-align: center;">Y<br>为什么可移动？</td>
<td style="text-align: center;">xvalue</td>
</tr>
</tbody>
</table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Super</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sub</span> : <span class="hljs-keyword">public</span> Super &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123; Sub sub; &#125;;<br><br><span class="hljs-comment">// cannot take the address of an rvalue of type &#x27;Sub&#x27;</span><br><span class="hljs-comment">// &amp;((Sub[2])&#123;Sub(), Sub()&#125;[0]);</span><br>Super&amp;&amp; a = ((Sub[<span class="hljs-number">1</span>])&#123;<span class="hljs-built_in">Sub</span>()&#125;)[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// cannot take the address of an rvalue of type &#x27;int&#x27;</span><br><span class="hljs-comment">// &amp;(Sub().a);</span><br>Super&amp;&amp; b = <span class="hljs-built_in">Test</span>().sub;<br><br>Sub c;<br><span class="hljs-comment">// cannot take the address of an rvalue of type &#x27;Sub&#x27;</span><br><span class="hljs-comment">// &amp;std::move(c);</span><br>Super&amp;&amp; rC = std::<span class="hljs-built_in">move</span>(c);<br></code></pre></td></tr></table></figure>
<p>为什么 <code>a[n]</code> 和 <code>a.m</code> 可移动？</p>
<blockquote>
<p>女朋友常说：”你是我的，所以你的钱也是我的“</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Money</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123; Money m &#125;;<br>Person you;<br>Person ry&amp;&amp; = std::<span class="hljs-built_in">move</span>(you);<br>Person yourGirlFriend;<br><span class="hljs-comment">// you.money 是一个 xvalue</span><br>youGirlFried.money = you.money;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Person <span class="hljs-title">getGoodMan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Person; &#125;<br>Person girlFriend;<br>grilFriend.money = getGoodMan.money<br></code></pre></td></tr></table></figure>
<blockquote>
<p>”你的钱，我要了“</p>
</blockquote>
<h3 id="copy-constructor-move-constructor">copy constructor &amp; move constructor</h3>
<p>左值匹配拷贝构造函数，右值匹配移动构造函数</p>
<p>识别左值右值的时候注意两条规则：</p>
<ol type="1">
<li>rvalue reference 会被当做 lvalue 处理</li>
<li>函数调用的值类型不等于函数返回值的值类型</li>
</ol>
<h3 id="perfect-forward">perfect forward</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Test&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(t)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Test&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(move(t))</span></span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(forward&lt;T&gt;(t))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t;<br>    <span class="hljs-built_in">f</span>(t);<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">move</span>(t));<br>    <span class="hljs-built_in">g</span>(t);<br>    <span class="hljs-built_in">g</span>(<span class="hljs-built_in">move</span>(t));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;iostream&gt;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;utility&gt;</span><br>using namespace std;<br><br>struct Test<br>&#123;<br>    Test() = default;<br>    Test(Test&amp; other) &#123;<br>        cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl;<br>    &#125;<br>    Test(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; &quot;move constructor&quot; &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>void f(Test&amp; t)<br>&#123;<br>    Test t2(t);<br>&#125;<br><br>void f(Test&amp;&amp; t)<br>&#123;<br>    Test t2(move(t));<br>&#125;<br><br>template &lt;typename T&gt;<br>void g(T&amp;&amp; t)<br>&#123;<br>    Test t2(forward&lt;T&gt;(t));<br>&#125;<br><br>int main()<br>&#123;<br>    Test t;<br>    f(t);<br>    f(move(t));<br>    g(t);<br>    g(move(t));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">copy constructor<br>move constructor<br>copy constructor<br>move constructor<br></code></pre></td></tr></table></figure>
<p>函数 <code>g</code> 调用的 <code>forward</code> 函数即是完美转发，完美转发保证将左值引用当做左值处理，将右值引用当做右值处理</p>
<p>函数 g 的参数类型是 <code>T&amp;&amp;</code> ，笔者认为 <code>&amp;&amp;</code> 在这里并不代表右值，而是代表 universal reference</p>
<p><code>T&amp;&amp;</code> 不是右值，是 universal reference （这是 C++11 的另外一个大坑）</p>
<h3 id="右值语义如何影响代码">右值语义如何影响代码</h3>
<p>在不考虑 copy elision 的情况下（编译时添加 <code>-fno-elide-constructors</code> 选项），右值语义可以大大减小返回复杂类型的成本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;* output)</span></span>;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; x = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数 <code>f</code> 和 函数 <code>g</code> 的性能差距即使在不考虑 copy elision 的情况下，也是非常小的，而函数 <code>g</code> 的含义却比函数 <code>f</code> 的含义要清晰</p>
<p>顺带提一句：调用"返回值不是引用类型的函数"的表达式的值类型是右值，代码不必写成 <code>std::move(x)</code> 的形式</p>
<p>两个返回值的函数可以写成如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// clang++-8 -std=c++11 -fno-elide-constructors test.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vec</span><br>&#123;<br>    <span class="hljs-built_in">Vec</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Vec</span>(Vec&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Vec</span>(Vec&amp;&amp; other) = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span><br>&#123;<br>    <span class="hljs-built_in">Pair</span>(T&amp;&amp; t, U&amp;&amp; u) : <span class="hljs-built_in">first</span>(forward&lt;T&gt;(t)), <span class="hljs-built_in">second</span>(forward&lt;U&gt;(u)) &#123;&#125;<br>    <span class="hljs-built_in">Pair</span>(Pair&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Pair</span>(Pair&amp;&amp; other) : <span class="hljs-built_in">first</span>(<span class="hljs-built_in">move</span>(other.first)), <span class="hljs-built_in">second</span>(<span class="hljs-built_in">move</span>(other.second)) &#123;&#125;<br><br>    T first;<br>    U second;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(Vec* v)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function">Pair&lt;<span class="hljs-type">bool</span>, Vec&gt; <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Vec v;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Pair</span>&lt;<span class="hljs-type">bool</span>, Vec&gt;(<span class="hljs-literal">true</span>, <span class="hljs-built_in">move</span>(v));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Pair&lt;<span class="hljs-type">bool</span>, Vec&gt; <span class="hljs-title">result</span><span class="hljs-params">(g())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>相较于函数 <code>f</code> ，函数 <code>g</code> 最多多调用两次移动构造函数</p>
<h2 id="copy-elision">copy elision</h2>
<p>Named Return Value Optimization = NRVO</p>
<p>Return Value Optimization = RVO</p>
<p>在 C++11 ，标准只是允许 <code>copy elision</code> 而不是强制 <code>copy elision</code> ，不过 <code>copy elision</code> 在主流编译器已经得到实现</p>
<h3 id="触发-nrvo-的条件">触发 NRVO 的条件</h3>
<p>返回相同的具名变量</p>
<h3 id="guaranteed-copy-elision">Guaranteed copy elision</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">gcc</th>
<th style="text-align: center;">clang</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">support version</td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://www.gnu.org/software/gcc/projects/cxx-status.html">7</a></td>
<td style="text-align: center;"><a target="_blank" rel="noopener" href="https://clang.llvm.org/cxx_status.html">4</a></td>
</tr>
</tbody>
</table>
<p>guaranteed copy elision 由 <a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">Wording for guaranteed copy elision through simplified value categories</a> 提出，在 C++17 可以使用</p>
<p>不过在 Guaranteed copy elision 下，临时变量和 prvalue (?) 的语义发生了变化</p>
<h2 id="emplace">emplace</h2>
<h3 id="简单介绍">简单介绍</h3>
<blockquote>
<p>Inserts a new element into the container constructed in-place with the given <code>args</code> if there is no element with the key in the container. The constructor of the new element (i.e. <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/utility/pair">std::pair</a>&lt;const Key, T&gt;) is called with exactly the same arguments as supplied to <code>emplace</code>, forwarded via <a target="_blank" rel="noopener" href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a>&lt;Args&gt;(args)…. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</p>
</blockquote>
<p>引用自 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/container/map/emplace">cppreference</a> 的这段话可以归纳为三点：</p>
<ol type="1">
<li>原地构造</li>
<li>完美转发</li>
<li>即使元素存在也可能引发一次不必要的构造</li>
</ol>
<p>考虑下面一个禁止任何拷贝的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;&#125;;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>在 c++11 之前如何为 <code>map&lt;int, Test&gt; m</code> 插入元素呢？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// error: use of deleted function Test::Test(const Test&amp;)</span><br><span class="hljs-comment">// template argument deduction/substitution failed</span><br>m.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)));<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// error: use of deleted function ‘Test&amp; Test::operator=(Test&amp;&amp;)</span><br><span class="hljs-comment">// error: no matching function for call to Test::Test()</span><br>m[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
<p>笔者没有想到不 workaround 的办法：为 Test 类增加默认构造函数，放开移动拷贝构造函数的限制等</p>
<p>在 emplace 之后，你可以这么做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">emplace</span>(<br>  std::piecewise_construct,<br>  std::forward_as_tuple(<span class="hljs-number">1</span>), <span class="hljs-comment">// 构造 key 用到的参数</span><br>  std::forward_as_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 构造 value 用到的参数</span><br></code></pre></td></tr></table></figure>
<h3 id="其它形式的-emplace">其它形式的 emplace</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string, string&gt; m;<br><span class="hljs-comment">// uses pair&#x27;s move constructor</span><br>m.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;a&quot;</span>), <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;a&quot;</span>)));<br><span class="hljs-comment">// uses pair&#x27;s converting move constructor</span><br>m.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>));<br><span class="hljs-comment">// uses pair&#x27;s template constructor</span><br>m.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>如果 key 和 value 都是单参数构造函数且具备隐式转换，emplace 用起来最方便</p>
<h3 id="实际用途">实际用途</h3>
<p>在 C++11 之前，为避免多次构造，往容器里塞元素要这么写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Element&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Element</span>()); <span class="hljs-comment">// 提供一个非常轻量的无参数构造函数</span><br>Element&amp; e = v.<span class="hljs-built_in">back</span>();<br>e.field = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 其它赋值操作</span><br></code></pre></td></tr></table></figure>
<p>这段代码是不优雅的：提供专门为容器准备的无参数构造函数</p>
<p>利用 emplace 之后：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Element&gt; v;<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<p>代码变得更直观，且性能没有下降，甚至还减少一次对无参数构造函数的调用</p>
<h3 id="emplace-是如何工作的">emplace 是如何工作的？</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Tp</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Allocator</span>&gt;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... _Args&gt;<br><span class="hljs-type">void</span> vector&lt;_Tp, _Allocator&gt;::<span class="hljs-built_in">emplace_back</span>(_Args&amp;&amp;... __args)<br>&#123;<br>  <span class="hljs-comment">// omit the relation between capacity and size</span><br>  __RAII_IncreaseAnnotator __annotator(*<span class="hljs-keyword">this</span>);<br>  __alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;__alloc(),<br>                            _VSTD::__to_raw_pointer(<span class="hljs-keyword">this</span>-&gt;__end_),<br>                            _VSTD::forward&lt;_Args&gt;(__args)...);<br>  __annotator.__done();<br>&#125;<br><br><span class="hljs-keyword">using</span> __alloc_traits = allocator_traits&lt;_Allocator&gt;;<br></code></pre></td></tr></table></figure>
<p>根据 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory/allocator/construct">cppreference</a> 的描述，<code>std::allocator&lt;T&gt;::construct</code> 的作用是</p>
<blockquote>
<p>Constructs an object of type <code>T</code> in allocated uninitialized storage pointed to by <code>p</code>, using placement-new</p>
</blockquote>
<p>Calls <code>::new((void *)p) U([std::forward]&lt;Args&gt;(args)…)</code></p>
<p>一般而言，分配内存与构建对象是绑定的，而 placement new 只负责在已分配的内存上构建对象</p>
<p>利用 placement new 和完美转发，emplace 的实现顺理成章：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniVec</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> mElement[<span class="hljs-built_in">sizeof</span>(E)];<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">new</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(mElement)) <span class="hljs-built_in">E</span>(forward&lt;Args&gt;(args)...);<br>    &#125;<br><br>    <span class="hljs-function">E* <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;E*&gt;(mElement);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>UniVec</code> 是一个最多只能存放一个元素的 Vector ，<code>emplace_back</code> 的实现是使用完美转发的参数调用 <code>placement new</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        : <span class="hljs-built_in">mA</span>(a)<br>        , <span class="hljs-built_in">mB</span>(b)<br>    &#123;&#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">int</span> mA;<br>    <span class="hljs-type">int</span> mB;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UniVec&lt;Test&gt; v;<br>    v.<span class="hljs-built_in">emplace_back</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">begin</span>()-&gt;mA &lt;&lt; endl;<br>    cout &lt;&lt; v.<span class="hljs-built_in">begin</span>()-&gt;mB &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以上程序能正常编译运行，说明 emplace_back 确实如预期运行</p>
<h2 id="可打断的线程">可打断的线程</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onSignalTerm</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>&#123;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">signal</span>(SIGTERM, onSignalTerm);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() -&gt; <span class="hljs-type">void</span> &#123; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125; &#125;)</span></span>;<br>    <span class="hljs-type">pthread_t</span> tid = t.<span class="hljs-built_in">native_handle</span>();<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">pthread_kill</span>(tid, SIGTERM);<br>    t.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;join succeed&quot;</span> &lt;&lt;  std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>利用信号的能力，写一个超时则强制结束的线程池是可能的：杀掉一个线程再创建一个线程放进去</p>
<p>但要根据线程耗的 cpu 时间、当前的调用栈以及调用栈参数等详细信息来决定是否强制杀掉一个线程仍是非常有难度的，检测底层信息不是件容易的事情</p>
<h2 id="编译期反射-static_assert-concept">编译期反射 + static_assert = concept</h2>
<p>concept <span class="math inline">\(\approx\)</span> 接口</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Engine&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EngineWrapper</span><br>&#123;<br>    <span class="hljs-keyword">using</span> R = <span class="hljs-keyword">typename</span> concepts::Get_Caller_MethodRT0&lt;Engine&gt;::type;<br><br>    <span class="hljs-built_in">static_assert</span>(<br>        concepts::<span class="hljs-built_in">IsStandardRandom</span>&lt;Engine&gt;() ||<br>        concepts::<span class="hljs-built_in">IsMonkeyRandom</span>&lt;Engine&gt;(),<br>        <span class="hljs-string">&quot;Engine should be a standard random or monkey random&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="匹配任何调用的函数">匹配任何调用的函数</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>以任意个数、任意类型（参数类型不需要一致）的参数调用 <code>func</code> 都是没问题的</p>
<h3 id="对模板参数的限制">对模板参数的限制</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Ps&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Has_Max_Method</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">Test</span><span class="hljs-params">(U* u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">((*u).Max(std::declval&lt;Ps&gt;()...))</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarkType</span> &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> MarkType <span class="hljs-title">Test</span><span class="hljs-params">(...)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = std::is_same&lt;<br>        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">Test</span>(std::<span class="hljs-built_in">declval</span>&lt;T*&gt;())), R&gt;::value;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>以上代码可以检查一个类型是否具备某个函数，举例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>&#123;<br>    <span class="hljs-built_in">static_assert</span>(Has_Max_Method&lt;E, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::value, <span class="hljs-string">&quot;E must have Max method&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><code>Container</code> 要求其元素类型 <code>E</code> 具备函数签名为 <code>int Max(int, int)</code> 的成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;<span class="hljs-type">int</span>&gt; a;<br>    Container&lt;Test&gt; b;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译器报错：<code>static_assert failed due to requirement 'Has_Max_Method&lt;int, int, int, int&gt;::value' "E must have Max method"</code></p>
<h3 id="两种报错形式">两种报错形式</h3>
<p>假设我们不使用 <code>static_assert</code> 限制模板参数需要具备的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">E</span>().<span class="hljs-built_in">Max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">Max</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译器报错：<code>in instantiation of member function 'Container&lt;int&gt;::Max' requested here</code></p>
<blockquote>
<p>想想看 vector 是怎么虐待你的吧！</p>
<p>我们需要一个看得懂模板报错的 C++ 工程师！</p>
</blockquote>
<p>但一旦使用 <code>static_assert</code> ，体验会非常接近支持 interface 的语言</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>&#123;<br>    <span class="hljs-built_in">static_assert</span>(Has_Max_Method&lt;E, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::value, <span class="hljs-string">&quot;E must have Max method&quot;</span>);<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">E</span>().<span class="hljs-built_in">Max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">Max</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译器的完整报错如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">test.cpp:22:5: error: static_assert failed due to requirement &#x27;Has_Max_Method&lt;int, int, int, int&gt;::value&#x27; &quot;E must have Max method&quot;<br>    static_assert(Has_Max_Method&lt;E, int, int, int&gt;::value, &quot;E must have Max method&quot;);<br>    ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>test.cpp:41:20: note: in instantiation of template class &#x27;Container&lt;int&gt;&#x27; requested here<br>    Container&lt;int&gt; a;<br>                   ^<br>1 error generated.<br></code></pre></td></tr></table></figure>
<p>编译器在 <code>static_assert</code> 失败之后，并没有继续尝试实例化 <code>static_assert</code> 之后的成员函数；同时报错信息也可以自行定制；模板报错变得简短而准确。</p>
<h3 id="编译器反射如何影响代码">编译器反射如何影响代码？</h3>
<p>abstract class vs template ：</p>
<ol type="1">
<li>不需要付出性能损耗的代价（模板成员函数默认会 inline ？）</li>
<li>注入更加方便，不需要类似 <code>SetDependency</code> 的函数提供注入手段。</li>
</ol>
<p>在将 <code>Has_Max_Method</code> 类似的类用宏抽象后，编译期反射用起来的体验如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">GET_RT_MACRO_SIMPLE</span>(PublicMethod, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">static_assert</span>(std::is_same&lt;Get_PublicMethod_MethodRT0&lt;Test&gt;::type, <span class="hljs-type">bool</span>&gt;::value, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>这不妨成为 <code>abstract class</code> 的一种替代选项。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Computer-Science/" class="category-chain-item">Computer Science</a>
  
  
    <span>></span>
    
  <a href="/categories/Computer-Science/Programming-Language/" class="category-chain-item">Programming Language</a>
  
  
    <span>></span>
    
  <a href="/categories/Computer-Science/Programming-Language/C/" class="category-chain-item">C++</a>
  
  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Useful And Easy New Features Of Cpp11</div>
      <div>https://clcanny.github.io/2019/07/16/computer-science/programming-language/c++/useful-and-easy-new-features-of-cpp11/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>JunBin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2019年7月16日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/02/16/computer-science/programming-language/c++/string-literal-in-cpp11/" title="String Literal In Cpp11">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">String Literal In Cpp11</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
