<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Understanding Workloads to Schedule KVCache - A Methodological Approach</title>
    <link href="/2025/07/31/computer-science/big-data/dfs/understanding-workloads-to-schedule-kvcache-a-methodological-approach/"/>
    <url>/2025/07/31/computer-science/big-data/dfs/understanding-workloads-to-schedule-kvcache-a-methodological-approach/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>KVCache has become a cornerstone optimization in large language model serving, enabling systems to reuse intermediate key-value computations across requests. However, the effectiveness of KVCache fundamentally depends on scheduling decisions that are inherently workload-dependent. The paper <a href="https://arxiv.org/pdf/2506.02634">KVCache Cache in the Wild: Characterizing and Optimizing KVCache Cache at a Large Cloud Provider</a> not just a solution, but more importantly, a systematic methodology for understanding workloads that can inform scheduling design.</p><p>The core insight is deceptively simple: optimal scheduling policies cannot be designed in a vacuum. They must emerge from a deep understanding of how real workloads behave and, crucially, why they behave that way.</p><h2 id="part-1-the-kvcache-scheduling-challenge">Part 1: The KVCache Scheduling Challenge</h2><p>KVCache scheduling involves two fundamental aspects:</p><p><strong>Lifecycle management</strong> encompasses the entire data flow of KVCache blocks from creation to deletion. This includes deciding whether to cache newly computed blocks, managing their movement across storage tiers (HBM, CPU memory, SSD), and determining when to evict them. Each storage tier offers different capacity-throughput tradeoffs, and optimal scheduling must also estimate the required size for each layer to avoid waste while ensuring performance.</p><p><strong>Aggressive optimizations</strong> like prefetching attempt to proactively move blocks from lower tiers back to HBM before they're needed. These strategies leverage temporal and spatial locality patterns but must balance potential performance gains against bandwidth waste and system complexity.</p><p>The challenge is that these decisions depend entirely on workload characteristics - what works for API-driven workloads may fail catastrophically for interactive chat sessions.</p><h2 id="part-2-workload-analysis-methodology">Part 2: Workload Analysis Methodology</h2><h3 id="data-collection-philosophy">Data Collection Philosophy</h3><p>The methodology begins with an iterative refinement process. Initial data collection reveals unexpected patterns, which prompt collection of additional contextual information. This feedback loop prevents both over-collection and blind spots. Each iteration sharpens the understanding of what data truly matters for scheduling decisions.</p><h3 id="pattern-modeling-approach">Pattern Modeling Approach</h3><p>The first step in understanding workloads is attempting to model their behavior with simple mathematical formulations. The authors initially tried to fit overall access patterns with exponential distributions for reuse probability over time.</p><p>This simplicity is methodological discipline. Complex models might fit observed data more precisely, but they risk overfitting to specific traces. Simple models that fit reasonably well likely capture fundamental behaviors that generalize across deployments.</p><p>When simple models failed to adequately capture behavior across all requests, this signaled the need for categorization. Poor model fit isn't failure - it's information indicating that the workload contains distinct sub-populations with different behaviors.</p><h3 id="workload-categorization-strategy">Workload Categorization Strategy</h3><p>Upon discovering that unified models couldn't capture workload behavior, the authors split requests into categories: single-turn versus multi-turn, API calls versus chat interactions, and different application types. Each split was motivated by model fit improvement.</p><p>But the crucial step was validating these categories by identifying root causes. They discovered API requests exhibited high reuse because developers typically hardcode identical system prompts. File-understanding requests showed longer reuse times because users need time to process document summaries. These aren't just patterns - they're behavioral explanations that validate the categorization.</p><p>This creates a powerful refinement cycle:</p><ol type="1"><li>Attempt simple model fitting on aggregate data.</li><li>Identify subsets where models fail.</li><li>Split into categories that improve model fit.</li><li>Validate categories by finding behavioral reasons.</li></ol><p>The end result: multiple simple models, each capturing a behaviorally-distinct workload component.</p><h3 id="from-models-to-system-design">From Models to System Design</h3><p>With validated models for each workload category, system design becomes principled rather than heuristic. The exponential decay in reuse probability directly informs eviction priorities - blocks from categories with faster decay should be evicted first when capacity is constrained.</p><p>The models also enable capacity planning. By understanding the lifespan distribution of each category and their relative frequencies, the system can estimate required cache sizes for each storage tier. For instance, discovering that API workloads have short but intense reuse patterns suggests keeping a smaller but faster cache is optimal.</p><h2 id="reference">Reference</h2><ul><li><a href="https://arxiv.org/pdf/2506.02634">KVCache Cache in the Wild: Characterizing and Optimizing KVCache Cache at a Large Cloud Provider</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>DFS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FalconFS: Trading Rename Performance for Single-Hop Operations at Scale</title>
    <link href="/2025/07/30/computer-science/big-data/dfs/falconfs-trading-rename-performance-for-single-hop-operations-at-scale/"/>
    <url>/2025/07/30/computer-science/big-data/dfs/falconfs-trading-rename-performance-for-single-hop-operations-at-scale/</url>
    
    <content type="html"><![CDATA[<h2 id="the-challenge-metadata-at-ai-scale">The Challenge: Metadata at AI Scale</h2><p>Production AI workloads now span 100+ billion small files accessed in random patterns during training. This unprecedented scale exposes a fundamental limitation in distributed filesystem design: current DFS architectures cannot simultaneously achieve metadata locality and scalability - directory partitioning bottlenecks on hot paths while hash partitioning scatters related metadata across all servers. Traditional systems are trapped: they promise to make every operation fast, including rarely-used ones like rename. However, AI workloads exhibit a striking characteristic: rename operations, while critical for general computing, virtually never occur during model training. This insight opens a new design space: what if we explicitly sacrifice rename performance to achieve both scalability AND locality for all other operations? <a href="https://arxiv.org/pdf/2507.10367">FalconFS</a> explores this tradeoff by optimizing aggressively for reads and creates while accepting poor rename performance.</p><h2 id="how-falconfs-achieves-one-hop-operations-at-scale">How FalconFS Achieves One-Hop Operations at Scale</h2><h3 id="the-architecture">The Architecture</h3><p>FalconFS consists of three core components: MNodes for managing metadata, file stores for handling data blocks, and clients for coordinating operations.</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/falconfs-trading-slow-directory-operations-for-one-hop-everything-else/figure-5-architecture-of-falconfs.png" alt="" /><figcaption>Figure 5: Architecture of FalconFS</figcaption></figure><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/falconfs-trading-slow-directory-operations-for-one-hop-everything-else/table-1-scheme-of-falconfs-s-metadata.png" alt="" /><figcaption>Table 1: Scheme of FalconFS's metadata</figcaption></figure><h3 id="the-core-innovation-name-based-routing">The Core Innovation: Name-Based Routing</h3><p>Traditional distributed filesystems route requests based on full paths. For example, accessing <code>/data/models/checkpoint.pt</code> might involve:</p><ol type="1"><li>Contacting Server-1, which owns <code>/data</code>.</li><li>Then Server-3, which owns <code>/data/models</code>.</li><li>Finally, Server-7, which owns the file itself.</li></ol><p>In contrast, FalconFS eliminates path-based routing entirely. It routes requests solely based on the filename. For instance, <code>hash("checkpoint.pt") -&gt; Server-7</code>. Whether the file is at <code>/data/checkpoint.pt</code> or <code>/backups/old/v2/checkpoint.pt</code>, it always lives on Server-7. One hash, one hop, and the file is found.</p><h3 id="making-path-resolution-work">Making Path Resolution Work</h3><p>But wait - how does Server-7 verify the client has permission to access <code>/data/models/checkpoint.pt</code> if it doesn't know about those directories?</p><p>FalconFS solves this with lazy directory replication. Each metadata server (MNode) maintains a cache of directory entries (dentries) it needs. Initial request: <code>/data/models/checkpoint.pt</code>:</p><ol type="1"><li>Client hashes <code>checkpoint.pt</code> and routes to MNode-7.</li><li>MNode-7 checks its cache for <code>/data/models/</code> permissions.</li><li>Cache miss. MNode-7 fetches directory info from owners.</li><li>MNode-7 caches this for future requests.</li><li>Subsequent operations complete entirely on MNode-7.</li></ol><p>After warmup, each MNode has a complete view of the directory paths leading to its files. No cross-server communication needed.</p><h3 id="boosting-readcreate-performance-and-scalability">Boosting Read/Create Performance and Scalability</h3><ul><li>Performance: As previously mentioned, after cache warmup, each MNode maintains complete path information for files it serves. Any read or create operation completes in a single network hop directly to the owner MNode.</li><li>Scalability: The filename-based partitioning ensures that as long as filenames are reasonably distributed (which is typical in AI datasets with millions of unique files), requests naturally load-balance across MNodes. Adding more MNodes directly increases the system's capacity to handle concurrent requests, providing near-linear scalability for read operations.</li></ul><h3 id="maintaining-correctness-guarantees">Maintaining Correctness Guarantees</h3><p>While optimizing for performance and scalability, FalconFS maintains full correctness guarantees: linearizability, serializability, and atomicity. This is crucial - optimizations without correctness have no value.</p><h4 id="serializability-through-two-phase-locking">Serializability Through Two-Phase Locking</h4><p>FalconFS ensures serializability using hierarchical two-phase locking:</p><ul><li><strong>MNode-level explicit locks</strong>: Traditional in-memory locks (e.g., <code>std::shared_lock</code>) that protect local operations within each MNode.</li><li><strong>Coordinator-level implicit locks</strong>: An MSI-style (Modified, Shared, Invalid) coherence protocol (similar to a memory coherence protocol) that maintains consistency across MNodes without explicit lock requests.<ul><li><strong>Shared</strong>: Normal state where dentries are replicated across MNodes for reading.</li><li><strong>Modified</strong>: Exclusive state for the owner MNode to modify a dentry. When needed, the owner revokes all S states from other MNodes and transitions to M state.</li><li><strong>Invalid</strong>: State of non-owner MNodes after the owner acquires M state for modification.</li></ul></li></ul><p>For an operation on <code>/data/models/checkpoint.pt</code>:</p><ul><li>First, MNode-7 acquires local locks on <code>/</code>,<code>/data</code>,<code>/data/models</code>, and<code>/data/models/checkpoint.pt</code> (root to leaf order).</li><li>Then, MNode-7 verifies all cached dentries remain in valid states (S or M) and blocks any incoming invalidation requests until operation completes. This is equivalent to acquiring coordinator-level locks - but done implicitly through the coherence protocol. No explicit coordinator interaction occurs, preserving the one-hop architecture.</li><li>Finally, all locks are released in reverse order once the operation completes.</li></ul><p>This strict ordering prevents deadlocks while ensuring serializable execution.</p><h4 id="linearizability-through-clear-linearization-points">Linearizability Through Clear Linearization Points</h4><p>Linearizability is guaranteed because:</p><ul><li>The linearization point for each request is clearly defined as the moment it acquires its final lock.</li><li>This lock acquisition always occurs within the request's real-time bounds - after the client initiates the operation and before any response is returned.</li><li>The 2PL protocol enforces a consistent ordering of conflicting operations. Once a request acquires its locks, no conflicting request can proceed until those locks are released. This ensures a globally consistent total order that respects the partial orderings of conflicting requests.</li></ul><h4 id="atomicity">Atomicity</h4><p>FalconFS handles atomicity based on operation scope:</p><ul><li>Single-MNode operations (file creation, writes): The owning MNode ensures atomicity through local transactions. No coordination overhead required.</li><li>Multi-MNode operations (rename): The coordinator uses two-phase commit to ensure atomicity across servers.</li></ul><p>This selective approach maintains strong consistency while minimizing coordination - most operations require no distributed transactions.</p><h2 id="comparison-with-similar-approaches">Comparison with Similar Approaches</h2><p>FalconFS isn't alone in trading rename performance for better performance and scalability of other operations - LocoFS shares this key insight that making renames expensive unlocks both horizontal scalability and single-hop performance for common operations, though implements it differently.</p><ul><li>Directory ownership: LocoFS centralizes all directories on one server; FalconFS distributes them across all servers.</li><li>Cache coherence: LocoFS uses time-based leases; FalconFS uses MSI-style state transitions.</li></ul><h2 id="reference">Reference</h2><ul><li><a href="https://arxiv.org/pdf/2507.10367">FalconFS: Distributed File System for Large-Scale Deep Learning Pipeline</a></li><li><a href="https://storage.cs.tsinghua.edu.cn/papers/sc17-locofs.pdf/">LocoFS: A Loosely-Coupled Metadata Service for Distributed File Systems</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>DFS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MVOCC vs. SVOCC: A Comprehensive Guide to Optimistic Concurrency Control</title>
    <link href="/2024/10/26/computer-science/serializability/mvocc-vs-svocc-a-comprehensive-guide-to-optimistic-concurrency-control/"/>
    <url>/2024/10/26/computer-science/serializability/mvocc-vs-svocc-a-comprehensive-guide-to-optimistic-concurrency-control/</url>
    
    <content type="html"><![CDATA[<p>This blog begins by introducing key theorems related to serializability. These theorems are then used to explain the three conditions applied in single-version OCC, which form the foundation for implementing the validation phase. Finally, we explore multi-version OCC and discuss its advantages over the single-version approach.</p><h2 id="basics-of-optimistic-concurrency-control">Basics of Optimistic Concurrency Control</h2><p><a href="http://wwwlgis.informatik.uni-kl.de/cms/fileadmin/publications/1984/Hae84.InformationSystems.pdf">OBSERVATIONS ON OPTIMISTIC CONCURRENCY CONTROL SCHEMES</a> describes OCC as follows:</p><blockquote><p>When transactions are accessing a database concurrently, a concurrency control (CC) scheme has to prevent conflicts among them such that their serializability can be guaranteed.</p><p>Conventional CC schemes use two-phase locking protocols acquiring dynamically locks for the objects.</p><p>Optimistic CC schemes are designed to get rid of the locking overhead. The burden of CC is deferred unitl EOT when some checking for potential conflicts has to take place. If a conceivable conflict is detected, a "pessimistic" view has to be taken: this conceivable conflict is resolved by aborting the transaction. Hence, theses schemes rely on transaction backout as a control mechanism.</p></blockquote><h3 id="serialization-graphs-and-conflict-serializability">Serialization Graphs and Conflict-Serializability</h3><p><a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</a> provides a generalized theory about OCC. Since the original paper spans 198 pages, this section summarizes critical aspects related to serializability (with some simplifications for clarity):</p><ul><li>A history <span class="math inline">\(H\)</span> represents a set of transactions, described as a partial order of events <span class="math inline">\(E\)</span> that reflect the operations (such as reads, writes, commits, and aborts) of the transactions.</li><li>The direct serialization graph <span class="math inline">\(\operatorname{DSG}(H)\)</span> of a given history <span class="math inline">\(H\)</span> is a graph constructed as follows:<ul><li>Each node in <span class="math inline">\(\operatorname{DSG}(H)\)</span> corresponds to a committed transaction in <span class="math inline">\(H\)</span>.</li><li>Directed edges correspond to different types of direct conflicts.<ul><li>Directly item-read-depends: <span class="math inline">\(T_j\)</span> directly item-read-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs some object version <span class="math inline">\(x_i\)</span> and <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(x_i\)</span>.</li><li>Directly item-anti-depends: <span class="math inline">\(T_j\)</span> directly item-anti-depends on transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> reads some object version <span class="math inline">\(x_k\)</span> and <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x\)</span>'s next version (after <span class="math inline">\(x_k\)</span>).</li><li>Directly item-write-depends: <span class="math inline">\(T_j\)</span> directly item-write-depends on transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs a version <span class="math inline">\(x_i\)</span> and <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x\)</span>'s next version (after <span class="math inline">\(x_i\)</span>).</li></ul></li></ul></li><li>The graph <span class="math inline">\(\operatorname{DSG}(H)\)</span> is acyclic, and aborted reads (where a transaction reads a version written by an aborted transaction) and intermediate reads (where a transaction reads a version that is not the final version written by a committed transaction) are proscribed for a history <span class="math inline">\(H\)</span> iff <span class="math inline">\(H\)</span> is conflict-serializable.</li></ul><p>The above description of serialization graphs and conflict-serializability is a simplified and informal explanation. It omits several key aspects for the sake of clarity, such as the inclusion of the version order as part of the history and the need to account for predicate-based dependencies arising from scanning operations. Additionally, the proof that the acyclicity of the direct serialization graph (<span class="math inline">\(\operatorname{DSG}(H)\)</span>) implies conflict-serializability is not provided here. The following references provide the necessary foundational details and formal arguments to address the aspects omitted in the simplified description above:</p><ul><li><a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</a></li><li>The Wormhole Theorem, as described in section 7.5.8.1 of <a href="https://www.oreilly.com/library/view/transaction-processing/9780080519555/">"Transaction Processing: Concepts and Techniques" by J. N. Gray and A. Reuter (Morgan Kaufmann Publishers Inc., 1993)</a></li><li>The Serializability Theorem, as described in Section 2.3 of <a href="https://courses.cs.washington.edu/courses/csep552/18wi/papers/CSE550BHG-Ch7.pdf">"Concurrency Control and Recovery in Database Systems" by Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman</a></li></ul><h3 id="cycle-prevention-with-timestamps">Cycle Prevention with Timestamps</h3><p>Since the acyclicity of the direct serialization graph (<span class="math inline">\(\operatorname{DSG}(H)\)</span>) implies conflict-serializability, OCC only needs to detect cycles and abort transactions that could introduce cycles. However, detecting cycles using traditional graph algorithms can be computationally expensive, as it requires each machine to have a complete view of the graph.</p><p>To overcome this, we can leverage logical clocks (timestamps) to enforce a one-directional dependency graph, which guarantees acyclicity. The idea is simple: assign each transaction a logical timestamp, and enforce a rule where a transaction can only depend on another transaction with a <strong>smaller</strong> timestamp. This ensures that all dependencies flow in one direction, thereby preventing cycles.</p><h4 id="backward-and-forward-validation">Backward and Forward Validation</h4><p><a href="http://wwwlgis.informatik.uni-kl.de/cms/fileadmin/publications/1984/Hae84.InformationSystems.pdf">OBSERVATIONS ON OPTIMISTIC CONCURRENCY CONTROL SCHEMES</a> proposes two methods for detecting wrong-direction dependencies:</p><blockquote><p>Backward oriented optimistic CC (BOCC) checks during the validation phase of <span class="math inline">\(T_j\)</span> whether its read set <span class="math inline">\(\operatorname{RS}(T_j)\)</span> intersects with any of the write sets <span class="math inline">\(\operatorname{WS}(T_i)\)</span> of all concurrently executed transactions <span class="math inline">\(T_i\)</span> having finished their read phases before <span class="math inline">\(T_j\)</span>. Since "blind" modifications are not very likely, each transaction has to be validated in practice.</p><p>Let <span class="math inline">\(T_{start}\)</span> be the highest transaction number assigned to some transaction when <span class="math inline">\(T_j\)</span> starts, and <span class="math inline">\(T_{finish}\)</span> the highest transaction number when <span class="math inline">\(T_j\)</span> enters its validation phase. Then, essentially the following procedure in <span class="math inline">\(T_j\)</span>'s validation phase will decide <span class="math inline">\(T_j\)</span>'s destiny.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">VALID := TRUE;<br>FOR T(i) := T(start+1) TO T(finish) DO<br>  IF RS(T(j)) \intersect WS(T(i)) != \emptyset THEN<br>    VALID := FALSE;<br>IF VALID THEN COMMIT<br>         ELSE ABORT;<br></code></pre></td></tr></table></figure><p>Forward oriented optimistic CC (FOCC) checks during the validation phase of <span class="math inline">\(T_j\)</span> whether its write set <span class="math inline">\(\operatorname{WS}(T_j)\)</span> intersects with any of the read sets <span class="math inline">\(\operatorname{RS}(T_i)\)</span> of all transactions <span class="math inline">\(T_i\)</span> having not yet finished their read phases.</p><p>Let the active transactions have the numbers <span class="math inline">\(T_{act1}\)</span> until <span class="math inline">\(T_{actn}\)</span>. Then, <span class="math inline">\(T_j\)</span> is validated as follows:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">VALID := TRUE;<br>FOR T(i) := T(act1) TO T(actn) DO<br>  IF WS(T(j)) \intersect RS(T(i)) != \emptyset THEN<br>    VALID := FALSE;<br>IF VALID THEN COMMIT<br>         ELSE ABORT;<br></code></pre></td></tr></table></figure></blockquote><p>It is important to note that the paper assumes blind writes are not possible, meaning the write set of a transaction is a superset of its read set. As a result, if transaction <span class="math inline">\(T_j\)</span> item-write-depends on transaction <span class="math inline">\(T_i\)</span>, then <span class="math inline">\(T_j\)</span> also item-anti-depends on <span class="math inline">\(T_i\)</span>. Consequently, there is no need to explicitly test for wrong-direction item-write-dependencies during backward validation.</p><p>Both backward-oriented and forward-oriented optimistic CC (also known as backward validation and forward validation) can detect and prevent wrong-direction dependencies. While the formal proof is omitted here, the intuition is as follows, assuming Jack and Tom want to enter two lines:</p><ul><li>Backward validation is like Jack entering a line where no one ahead of him promises not to harm him if he enters. Jack himself makes no promises to those behind him. The only thing Jack needs to do is check whether anyone ahead could potentially harm him. If so, he leaves (the transaction aborts); otherwise, he stays in line (the transaction commits).</li><li>Forward validation is like Tom entering a line where those ahead have promised not to harm him, and Tom himself promises not to harm anyone behind him. Tom's job is to check if anyone behind him might be affected if he stays. If so, he leaves (the transaction aborts); otherwise, he stays (the transaction commits).</li></ul><p>However, backward validation is more commonly used, so we will focus on it. In backward validation, a transaction is validated by checking it against other concurrent transactions (transactions whose lifetimes overlap) <strong>with smaller timestamps</strong>. The assignment of timestamps and the timing of validation are crucial and must be coordinated to ensure that, once Jack decides to stay in line (i.e., the transaction commits), no one who was not already in the queue (i.e., not assigned a timestamp already) before validation can queue ahead of him afterward (i.e., be assigned a smaller timestamp).</p><h2 id="single-version-optimistic-concurrency-control">Single-Version Optimistic Concurrency Control</h2><p>Single-version OCC is a straightforward approach to implementing optimistic concurrency control. In this context, "single-version" means that, globally, there is at most one version of each object available to all transactions. While a transaction may create local copies of objects in its own workspace during execution, these local versions are private and cannot be accessed by other transactions until the transaction commits.</p><h3 id="phases-of-a-transaction-in-svocc">Phases of a Transaction in SVOCC</h3><p><a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a> introduces a method where a transaction is divided into three phases:</p><blockquote><p>It is required that any transaction consist of two or three phases: a read phase, a validation phase, and a possible write phase (see Figure 1).</p></blockquote><ul><li>During the read phase, the transaction reads the data and locally stores any changes it intends to make. Importantly, no changes are written to the global database during this phase. All modifications are made on local copies of the data.</li><li>If validation is successful, the transaction enters the write phase, wherein the local changes are applied to the global database.</li></ul><h4 id="local-writes-in-active-transactions">Local Writes in Active Transactions</h4><p><a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a> emphasizes that no global modifications occur during the read phase of a transaction:</p><blockquote><p>During the read phase, all writes take place on local copies of the nodes to be modified. Then, if it can be established during the validation phase that the changes the transaction made will not cause a loss of integrity, the local copies are made global in the write phase.</p></blockquote><p>This is the simplest way to avoid aborted reads and intermediate reads.</p><h4 id="the-validation-phase">The Validation Phase</h4><h5 id="choosing-the-timing-for-timestamp-assignment">Choosing the Timing for Timestamp Assignment</h5><p>The following statements are quoted from <a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a>:</p><blockquote><p>In order to verify (1), a permutation <span class="math inline">\(\pi\)</span> must be found. This is handled by explicitly assigning each transaction <span class="math inline">\(T_i\)</span>, a unique integer transaction number <span class="math inline">\(t(i)\)</span> during the course of its execution.</p><p>On first thought, we might assign transaction numbers at the beginning of the read phase; however, this is not optimistic (hence contrary to the philosophy of this paper) for the following reason. Consider the case of two transactions, <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span>, starting at roughly the same time, assigned transaction number <span class="math inline">\(n\)</span> and <span class="math inline">\(n + 1\)</span>, respectively. Even if <span class="math inline">\(T_2\)</span> completes its read phase much earlier than <span class="math inline">\(T_1\)</span>, before being validated <span class="math inline">\(T_2\)</span> must wait for the completion of the read phase of <span class="math inline">\(T_1\)</span>, since the validation of <span class="math inline">\(T_2\)</span> in this case relies on knowledge of the write set of <span class="math inline">\(T_1\)</span> (see Figure 3).</p><p>In an optimistic approach, we would like for transactions to be validated immediately if at all possible (in order to improve response time). For these and similar considerations we assign transaction numbers <strong>at the end of the read phase</strong>.</p></blockquote><p>Although the paper states that "before being validated <span class="math inline">\(T_2\)</span> must wait for the completion of the read phase of <span class="math inline">\(T_1\)</span>," I believe this is a limitation of using backward validation in isolation. Combining backward validation with forward validation can address this issue. However, let's follow the paper in the discussion below.</p><h5 id="three-conditions-for-validation">Three Conditions for Validation</h5><p><a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a> proposes three conditions to validate transactions:</p><blockquote><p>There must exist a serially equivalent schedule in which transaction <span class="math inline">\(T_i\)</span> comes before transaction <span class="math inline">\(T_j\)</span> whenever <span class="math inline">\(t(i)\)</span> &lt; <span class="math inline">\(t(j)\)</span>. This can be guaranteed by the following validation condition: for each transaction <span class="math inline">\(T_j\)</span> with transaction number <span class="math inline">\(t(j)\)</span>, and for all <span class="math inline">\(T_i\)</span> with <span class="math inline">\(t(i) &lt; t(j)\)</span>; <strong>one of</strong> the following three conditions must hold (see Figure 2):</p><ol type="1"><li><span class="math inline">\(T_i\)</span> completes its write phase before <span class="math inline">\(T_j\)</span> starts its read phase.</li><li>The write set of <span class="math inline">\(T_i\)</span> does not intersect the read set of <span class="math inline">\(T_j\)</span>, and <span class="math inline">\(T_i\)</span> completes its write phase before <span class="math inline">\(T_j\)</span> starts its write phase.</li><li>The write set of <span class="math inline">\(T_i\)</span> does not intersect the read set or the write set of <span class="math inline">\(T_j\)</span>, and <span class="math inline">\(T_i\)</span> completes its read phase before <span class="math inline">\(T_j\)</span> completes its read phase.</li></ol></blockquote><p>These three conditions are essential in the backward validation to ensure that no cycles form in the direct serialization graph. The following table shows how the three conditions prevent different types of dependencies with wrong direction:</p><table><thead><tr class="header"><th>Condition</th><th>Is <span class="math inline">\(T_i\)</span> item-read-depends on <span class="math inline">\(T_j\)</span> possible?</th><th>Is <span class="math inline">\(T_i\)</span> item-anti-depends on <span class="math inline">\(T_j\)</span> possible?</th><th>Is <span class="math inline">\(T_i\)</span> item-write-depends on <span class="math inline">\(T_j\)</span> possible?</th></tr></thead><tbody><tr class="odd"><td>(1)</td><td>No: <span class="math inline">\(T_i\)</span> completes before <span class="math inline">\(T_j\)</span> starts, so <span class="math inline">\(T_i\)</span> cannot read any versions written by <span class="math inline">\(T_j\)</span>.</td><td>No: <span class="math inline">\(T_j\)</span> starts after <span class="math inline">\(T_i\)</span> completes, so <span class="math inline">\(T_j\)</span> either reads the version written by <span class="math inline">\(T_i\)</span> or a newer version. It cannot read an older version.</td><td>No: <span class="math inline">\(T_i\)</span> completes its write phase before <span class="math inline">\(T_j\)</span> starts writing, so only <span class="math inline">\(T_j\)</span> can overwrite <span class="math inline">\(T_i\)</span>'s version. The reverse is impossible.</td></tr><tr class="even"><td>(2)</td><td>No: <span class="math inline">\(T_i\)</span> completes its write phase before <span class="math inline">\(T_j\)</span> starts writing, so <span class="math inline">\(T_i\)</span> completes its read phase before <span class="math inline">\(T_j\)</span> starts writing. Therefore, <span class="math inline">\(T_i\)</span> cannot read any version written by <span class="math inline">\(T_j\)</span>.</td><td>No: The write set of <span class="math inline">\(T_i\)</span> does not intersect the read set of <span class="math inline">\(T_j\)</span>, so what <span class="math inline">\(T_j\)</span> reads cannot be overwritten by <span class="math inline">\(T_i\)</span>.</td><td>No: <span class="math inline">\(T_i\)</span> completes its write phase before <span class="math inline">\(T_j\)</span> starts writing, so only <span class="math inline">\(T_j\)</span> can install the next version. The reverse is not possible.</td></tr><tr class="odd"><td>(3)</td><td>No: <span class="math inline">\(T_i\)</span> completes its read phase before <span class="math inline">\(T_j\)</span> completes its read phase, which means <span class="math inline">\(T_i\)</span> also completes its read phase before <span class="math inline">\(T_j\)</span> starts its write phase. Therefore, <span class="math inline">\(T_i\)</span> cannot read what <span class="math inline">\(T_j\)</span> writes.</td><td>No: The read set of <span class="math inline">\(T_j\)</span> does not intersect the write set of <span class="math inline">\(T_i\)</span>, so <span class="math inline">\(T_j\)</span> cannot read any version written by <span class="math inline">\(T_i\)</span>.</td><td>No: The write set of <span class="math inline">\(T_j\)</span> does not intersect the write set of <span class="math inline">\(T_i\)</span>, so neither transaction can overwrite the other's version.</td></tr></tbody></table><p>The above explanation omits some details for the sake of clarity. For example, <a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</a> emphasizes that the version order in a history <span class="math inline">\(H\)</span> can be different from the order of write or commit events in <span class="math inline">\(H\)</span>. However, for simplicity, we assume here that the version order of involved objects corresponds directly to the commit event order. Additionally, we do not cover more advanced topics such as scanning operations and predicate-based dependencies.</p><h5 id="serial-validation">Serial Validation</h5><p>The following code is quoted from <a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a>:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text">tbegin = (<br>  create set := empty;<br>  read set := empty;<br>  write set := empty;<br>  delete set := empty;<br>  start tn := tnc)<br>tend = (<br>  // The part enclosed by &lt; and &gt; represents a critical section,<br>  // which functions similarly to a mutex guard.<br>  &lt;finish tn := tnc;<br>   valid := true;<br>   for t from start tn + 1 to finish tn do<br>     if (write set of transaction with transaction number t intersects read set)<br>       then valid:= false;<br>   if valid<br>     then ((write phase); tnc := tnc + 1; tn := tnc)&gt;;<br>  if valid<br>    then (cleanup)<br>    else (backup)).<br></code></pre></td></tr></table></figure><p>My understanding of the above code can be split into three parts: validating the transaction with transactions whose <code>tn</code> is smaller than or equal to <code>start tn</code>, from <code>start tn + 1</code> to <code>finish tn</code>, and larger than <code>finish tn</code>:</p><ul><li>The write phase and the increment of the <code>tnc</code> are performed as a single atomic action within the same critical section. This ensures that all transactions with a <code>tn</code> less than the current transaction's <code>start tn</code> have already completed their write phase before the current transaction starts its read phase. During the validation phase of the current transaction, these earlier transactions (with a <code>tn</code> less than the current transaction's <code>start tn</code>) can be handled using <strong>Condition (1)</strong>, meaning their read and write sets do not need to be explicitly checked with the current transaction's read and write sets - they naturally pass the validation.</li><li>The write phase and the increment of the <code>tnc</code> are executed as a single atomic action within the same critical section. Since the critical section is executed for multiple transactions one by one, this guarantees that transactions with smaller <code>tn</code> complete their write phase before transactions with larger <code>tn</code> start their write phase. As a result, this satisfies part of <strong>Condition (2)</strong>, allowing us to use <strong>Condition (2)</strong> to validate transactions from <code>start tn + 1</code> to <code>finish tn</code>.</li><li>The validation phase, the increment of the <code>tnc</code>, and the assignment of the incremented <code>tnc</code> to the transaction's <code>tn</code> are performed as a single atomic action within the same critical section. This ensures that after the validation phase of the current transaction, no transaction that hasn't yet been assigned a <code>tn</code> before the current transaction's validation phase will be assigned a smaller <code>tn</code> than the current transaction's <code>tn</code>.<ul><li>Using the analogy used before: After Jack decides to stay in line (i.e., the current transaction passes the validation check and commits), no one who was not already in the queue (i.e., no transaction without a <code>tn</code> before the current transaction's validation phase) can jump ahead of him (i.e., can be assigned a smaller <code>tn</code> than Jack's).</li><li>This is an example of how the assignment of timestamps and the timing of validation are crucial and must be coordinated, as mentioned previously.</li><li>Notice: In backward validation, for transactions with a tn larger than the current transaction's <code>tn</code>, it is their responsibility to validate whether they violate serializability with the current transaction - not the current transaction's responsibility.</li></ul></li></ul><h5 id="parallel-validation">Parallel Validation</h5><p>The following code is quoted from <a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a>:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs text">tend = (<br>  // Critical section A.<br>  &lt;finish tn := tnc;<br>   finish active := (make a copy of active);<br>   active := active \union &#123;id of this transaction&#125;&gt;;<br>  valid := true;<br>  for t from start tn + 1 to finish tn do<br>    if (write set of transaction with transaction number t intersects read set)<br>      then valid := false;<br>  for i \in finish active do<br>    if (write set of transaction Ti intersects read set or write set)<br>      then valid := false;<br>  if valid<br>    then (<br>      (write phase);<br>      // Critical section B.<br>      &lt;tnc := tnc + 1;<br>       tn := tnc;<br>       active := active - &#123;id of this transaction&#125;&gt;;<br>      (cleanup))<br>    else (<br>      // Critical section C.<br>      &lt;active := active - &#123;id of transaction&#125;&gt;;<br>      (backup))).<br></code></pre></td></tr></table></figure><p>My understanding of the above code is as follows:</p><ul><li>The three critical sections, A, B, and C, share the same mutex. At any given time, only one critical section can be executing.</li><li>While validating the current transaction in critical section A, the transactions with <code>tn</code> between <code>start tn + 1</code> and <code>finish tn</code> have already completed their write phases and have been assigned a <code>tn</code> in critical section B (otherwise, these transactions would have a <code>tn</code> larger than <code>finish tn</code>; the critical section A of the current transaction is exclusive with the critical section B of those transactions - they cannot execute concurrently, and one must occur before the other). This ensures that their write phases are completed before the current transaction starts its own write phase, allowing us to apply <strong>Condition (2)</strong> for their validation. This mirrors the behavior of serial validation.</li><li>When the current transaction obtains <code>finish active</code> by copying <code>active</code> in critical section A, it has just completed its read phase and has not yet started its write phase. Meanwhile, all transactions in <code>finish active</code> must have already completed the entire critical section A (otherwise, those transactions would not appear in the <code>finish active</code> set of the current transaction; the critical section A of the current transaction is exclusive with the critical section A of those transactions - they cannot execute concurrently, and one must occur before the other), meaning they completed their read phases before the current transaction completes its read phase or starts its write phase. Therefore, we can apply <strong>Condition (3)</strong> to validate them.<ul><li>Notice: Transactions in the <code>finish active</code> set of the current transaction may enter critical section B either before or after the current transaction, meaning their <code>tn</code> could be smaller or larger than the current transaction's <code>tn</code>. In the case that they are assigned a smaller <code>tn</code>, it is the current transaction's responsibility to check for conflicts with them.</li></ul></li><li>For transactions that haven't been assigned a <code>tn</code> and do not appear in the <code>finish active</code> set of the current transaction, it is their responsibility to check for conflicts with the current transaction. In other words, it is not the current transaction's responsibility to check for conflicts with them.</li></ul><h2 id="multi-version-optimistic-concurrency-control">Multi-Version Optimistic Concurrency Control</h2><h3 id="designing-an-mvocc-protocol-based-on-svocc">Designing an MVOCC Protocol Based on SVOCC</h3><h4 id="basic-storage-format-of-versions">Basic Storage Format of Versions</h4><p>In a MVOCC protocol, multiple versions of the same object must explicitly declare the lifecycle of each version. This is achieved by introducing a <code>Begin</code> field and an <code>End</code> field, which define the lifetime of each version. (Note that the <code>Begin</code> and <code>End</code> fields are distinct from the begin timestamp and end timestamp mentioned below; both the <code>Begin</code> field and the <code>End</code> field in the version record correspond to the end timestamp of a transaction.) Together with the original columns, these fields construct the record format for each version.</p><table><thead><tr class="header"><th style="text-align: center;">Begin</th><th style="text-align: center;">End</th><th style="text-align: center;">Name</th><th style="text-align: center;">Amount</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">15</td><td style="text-align: center;">inf</td><td style="text-align: center;">Jane</td><td style="text-align: center;">150</td></tr><tr class="even"><td style="text-align: center;">10</td><td style="text-align: center;">20</td><td style="text-align: center;">John</td><td style="text-align: center;">100</td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;">Txn75</td><td style="text-align: center;">John</td><td style="text-align: center;">110</td></tr><tr class="even"><td style="text-align: center;">Txn75</td><td style="text-align: center;">inf</td><td style="text-align: center;">John</td><td style="text-align: center;">130</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;">Txn75</td><td style="text-align: center;">Larry</td><td style="text-align: center;">170</td></tr><tr class="even"><td style="text-align: center;">Txn75</td><td style="text-align: center;">inf</td><td style="text-align: center;">Larry</td><td style="text-align: center;">150</td></tr></tbody></table><h4 id="why-two-timestamps-are-needed-in-mvocc">Why Two Timestamps Are Needed in MVOCC</h4><p><a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a> assigns two timestamps to a transaction:</p><ul><li>Begin Timestamp: Acquired at the start of the transaction.</li><li>End Timestamp: Acquired when the transaction is ready to be validated.</li></ul><blockquote><p>Transaction 75 is in the process of transferring $20 from Larry's account to John's account. It has created the new versions for Larry (Larry, 150) and for John (John, 130) and inserted them into the appropriate buckets in the index.</p><p>Note that transaction 75 has stored its transaction ID in the <code>Begin</code> and <code>End</code> fields of the new and old versions, respectively. (One bit in the field indicates the field's current content.)</p><p>Now suppose transaction 75 commits with end timestamp 100. It then returns to the old and new versions and sets the <code>Begin</code> and <code>End</code> fields, respectively, to 100. The final values are shown in red below the old and new versions. The old version (John, 110) now has the valid time 20 to 100 and the new version (John, 130) has a valid time from 100 to infinity.</p></blockquote><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/mvocc-vs-svocc-a-comprehensive-guide-to-optimistic-concurrency-control/figure-1-example-account-table-with-one-hash-index-transaction-75-has-transferred-20-from-larrys-account-to-johns-account-but-has-not-yet-committed.png" alt="" /><figcaption>Figure 1: Example account table with one hash index. Transaction 75 has transferred $20 from Larry's account to John's account but has not yet committed.</figcaption></figure><p>In my view, the end timestamp in <a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a> corresponds to the transaction number in <a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a>. Both papers opt to assign the end timestamp or transaction number at the end of the read phase to allow transactions to be validated immediately, rather than having to wait for transactions with smaller end timestamps or transaction numbers that have not yet completed their read phase.</p><p>Additionally, an MVOCC transaction requires a timestamp during the read phase to identify the correct version of an object. This timestamp is the begin timestamp. This is why <a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a> assigns two timestamps to each transaction.</p><p>However, in my opinion, the requirement that "before being validated <span class="math inline">\(T_2\)</span> must wait for the completion of the read phase of <span class="math inline">\(T_1\)</span>" is a limitation of relying solely on backward validation. I believe that combining backward validation with forward validation could resolve this issue, allowing the end timestamp or transaction number to be assigned at the start of the transaction, thereby eliminating the need for two timestamps in MVOCC. That said, I am still in the process of proving this hypothesis.</p><h4 id="how-active-transactions-write-objects-with-new-versions">How Active Transactions Write Objects with New Versions</h4><p>Due to the presence of <code>Begin</code> and <code>End</code> fields indicating the lifecycle of each version, MVOCC allows global modifications to occur even during the read phase of a transaction, unlike SVOCC. <a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a> provides an example of a bank transfer:</p><blockquote><p>Transaction 75 is in the process of transferring $20 from Larry's account to John's account. It has created the new versions for Larry (Larry, 150) and for John (John, 130) and inserted them into the appropriate buckets in the index.</p><p>Note that transaction 75 has stored its transaction ID in the <code>Begin</code> and <code>End</code> fields of the new and old versions, respectively. (One bit in the field indicates the field's current content.)</p></blockquote><table><thead><tr class="header"><th style="text-align: center;">Begin</th><th style="text-align: center;">End</th><th style="text-align: center;">Name</th><th style="text-align: center;">Amount</th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">15</td><td style="text-align: center;">inf</td><td style="text-align: center;">Jane</td><td style="text-align: center;">150</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">10</td><td style="text-align: center;">20</td><td style="text-align: center;">John</td><td style="text-align: center;">100</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;">Txn75</td><td style="text-align: center;">John</td><td style="text-align: center;">110</td><td style="text-align: center;">Old</td></tr><tr class="even"><td style="text-align: center;">Txn75</td><td style="text-align: center;">inf</td><td style="text-align: center;">John</td><td style="text-align: center;">130</td><td style="text-align: center;">New</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;">Txn75</td><td style="text-align: center;">Larry</td><td style="text-align: center;">170</td><td style="text-align: center;">Old</td></tr><tr class="even"><td style="text-align: center;">Txn75</td><td style="text-align: center;">inf</td><td style="text-align: center;">Larry</td><td style="text-align: center;">150</td><td style="text-align: center;">New</td></tr></tbody></table><p>In the read phase of transaction 75, a new version is created globally. Unlike SVOCC, making global modifications during the read phase of transaction 75 does not result in aborted reads or intermediate reads. This is because the system records the transaction ID, rather than a timestamp, in the <code>End</code> field of the old version and the <code>Begin</code> field of the new version. As a result, other transactions either ignore these in-progress versions or wait for transaction 75 to commit before they proceed with their own commits.</p><p>Moreover, making global modifications offers an advantage: it reduces the transaction abortion rate, as will be demonstrated in a later section.</p><h4 id="how-to-locate-a-specific-version-when-reading-an-object">How to Locate a Specific Version When Reading an Object</h4><p>Essentially, a transaction locates a version by finding one where its begin timestamp falls between the <code>Begin</code> and <code>End</code> fields of that version. Building on this, <a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a> proposes speculative reads and speculative ignores when encountering a version where either the <code>Begin</code> or <code>End</code> field contains a transaction ID instead of a timestamp (indicating that an ongoing transaction is modifying this version). In this case, the system assumes the ongoing transaction will eventually commit and reads the modifications, creating a commit dependency on the ongoing transaction (i.e., the current transaction must wait for the ongoing transaction to commit before it can commit).</p><p>More details can be found in Section 2.5, Version Visibility, of the original paper.</p><h4 id="how-to-validate-and-commit">How to Validate and Commit</h4><p>Essentially, <a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a> employs backward validation but optimizes it for in-memory storage:</p><blockquote><p>We use backward validation but optimize it for in-memory storage. Instead of validating a read set against the write sets of all other transactions, we simply check whether a version that was read is still visible as of the end of the transaction.</p></blockquote><p>This blog is designed to omit the discussion on scanning operations. However, if we were to address it, I believe the method <a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a> uses to detect anomalies in scanning operations is not entirely accurate. The approach of "T walks its ScanSet and repeats each scan looking for versions that came into existence during T's lifetime and are visible as of the end of the transaction" may not be sufficient. I believe that simply checking if the versions seen during scanning still exist at validation is insufficient. It is also necessary to check if any additional versions appear during validation that were not visible during the read phase. The method proposed in <a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</a> might be more appropriate.</p><h3 id="advantage-1-lower-abort-rate-for-read-transactions">Advantage 1: Lower Abort Rate for Read Transactions</h3><p>Consider the following sequence of events:</p><ol type="1"><li><span class="math inline">\(T_5\)</span> writes <span class="math inline">\(v_5\)</span>.</li><li><span class="math inline">\(T_4\)</span> reads <span class="math inline">\(v\)</span>.</li><li><span class="math inline">\(T_6\)</span> reads <span class="math inline">\(v\)</span>.</li><li><span class="math inline">\(T_5\)</span> commits.</li><li><span class="math inline">\(T_4\)</span> validates.</li><li><span class="math inline">\(T_6\)</span> validates.</li></ol><p>In SVOCC, when <span class="math inline">\(T_5\)</span> writes <span class="math inline">\(v_5\)</span>, it can either appear in global modification or local modification:</p><ul><li>If <span class="math inline">\(v_5\)</span> appears in global modification, then <span class="math inline">\(T_4\)</span> reads <span class="math inline">\(v_5\)</span> and must abort.</li><li>If <span class="math inline">\(v_5\)</span> is in local modification, then <span class="math inline">\(T_6\)</span> cannot read <span class="math inline">\(v_5\)</span> and must abort.</li></ul><p>Thus, in SVOCC, whether <span class="math inline">\(v_5\)</span> appears in global or local modification, at least one transaction will abort.</p><p>In contrast, in MVOCC, <span class="math inline">\(v_5\)</span> can appear in global modification, and:</p><ul><li><span class="math inline">\(T_4\)</span> can read an older version, such as <span class="math inline">\(v_4\)</span>, and commit successfully.</li><li><span class="math inline">\(T_6\)</span> can read <span class="math inline">\(v_5\)</span> and commit after <span class="math inline">\(T_5\)</span> commits.</li></ul><p>Therefore, MVOCC results in a lower transaction abort rate compared to SVOCC.</p><h3 id="advantage-2-skipping-the-validation-phase-for-read-transactions">Advantage 2: Skipping the Validation Phase for Read Transactions</h3><p>If a transaction only reads versions whose <code>Begin</code> and <code>End</code> fields are neither inf nor ongoing transaction IDs, and it does not perform any writes, it may be able to commit directly without undergoing a validation phase. For example, consider a transaction with a begin timestamp of 50 that reads the following data:</p><ul><li><code>Begin=10, End=100, Name=John, Amount=100</code></li><li><code>Begin=30, End=100, Name=Larry, Amount=170</code></li></ul><table><thead><tr class="header"><th style="text-align: center;">Begin</th><th style="text-align: center;">End</th><th style="text-align: center;">Name</th><th style="text-align: center;">Amount</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">15</td><td style="text-align: center;">inf</td><td style="text-align: center;">Jane</td><td style="text-align: center;">150</td></tr><tr class="even"><td style="text-align: center;">10</td><td style="text-align: center;">20</td><td style="text-align: center;">John</td><td style="text-align: center;">100</td></tr><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;">100</td><td style="text-align: center;">John</td><td style="text-align: center;">110</td></tr><tr class="even"><td style="text-align: center;">100</td><td style="text-align: center;">inf</td><td style="text-align: center;">John</td><td style="text-align: center;">130</td></tr><tr class="odd"><td style="text-align: center;">30</td><td style="text-align: center;">100</td><td style="text-align: center;">Larry</td><td style="text-align: center;">170</td></tr><tr class="even"><td style="text-align: center;">100</td><td style="text-align: center;">inf</td><td style="text-align: center;">Larry</td><td style="text-align: center;">150</td></tr></tbody></table><h2 id="reference">Reference</h2><ul><li><a href="http://wwwlgis.informatik.uni-kl.de/cms/fileadmin/publications/1984/Hae84.InformationSystems.pdf">OBSERVATIONS ON OPTIMISTIC CONCURRENCY CONTROL SCHEMES</a></li><li><a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</a></li><li><a href="https://www.oreilly.com/library/view/transaction-processing/9780080519555/">Transaction Processing: Concepts and Techniques</a></li><li><a href="https://courses.cs.washington.edu/courses/csep552/18wi/papers/CSE550BHG-Ch7.pdf">Concurrency Control and Recovery in Database Systems</a></li><li><a href="https://www.eecs.harvard.edu/~htk/publication/1981-tods-kung-robinson.pdf">On Optimistic Methods for Concurrency Control</a></li><li><a href="https://vldb.org/pvldb/vol5/p298_per-akelarson_vldb2012.pdf">High-Performance Concurrency Control Mechanisms for Main-Memory Databases</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Serializability</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Design Document: DataNode for Distributed Filesystem</title>
    <link href="/2024/09/22/computer-science/big-data/dfs/design-document-datanode-for-distributed-filesystem/"/>
    <url>/2024/09/22/computer-science/big-data/dfs/design-document-datanode-for-distributed-filesystem/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p><a href="https://hadoop.apache.org/docs/r1.2.1/hdfs_design.html">Hadoop Distributed File System</a>, <a href="https://www.usenix.org/legacy/event/osdi06/tech/full_papers/weil/weil.pdf">Ceph</a>, <a href="https://storage.googleapis.com/gweb-research2023-media/pubtools/4446.pdf">The Google File System</a>, <a href="https://www.usenix.org/system/files/fast21-pan.pdf">Facebook's Tectonic</a>, <a href="https://www.usenix.org/system/files/fast23-li-qiang_more.pdf">Alibaba's Pangu</a> and <a href="https://dl.acm.org/doi/pdf/10.1145/3552326.3587443">Baidu's CFS</a> are all successful distributed file systems (DFS) known for their performance, reliability, and scalability. These systems typically consist of <em>namenodes</em> for metadata management, <em>datanodes</em> for data storage, and <em>client</em> interfaces for user interaction.</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-datanode-for-distributed-filesystem/hdfs-architecture.gif" alt="" /><figcaption>Typical DFS Architecture (quoted from HDFS)</figcaption></figure><p>This document proposes a new datanode architecture to meet evolving demands. Traditional DFS tenants like data warehouses and blob storage are being joined by AI workloads, which introduce new requirements. Additionally, the growing adoption of NVMe in data centers calls for a fresh approach to datanode design.</p><h2 id="terminologies">Terminologies</h2><ul><li>Segment: A segment is a logical unit of storage managed by the NameNode. A file is split into one or more segments, which are then distributed across DataNodes for storage.</li><li>Chunk: The actual data for a segment is stored as chunks on DataNodes. Each segment usually has multiple chunks (commonly three) distributed across different DataNodes to ensure redundancy and reliability. The NameNode keeps track of which DataNodes store the chunks for each segment. When a segment is read or written, the client interacts with one or more chunks on the respective DataNodes.</li><li>Sector: A sector is a small unit within a chunk, and each sector has its own checksum for data integrity.</li><li>Block: Block is a reserved term used for block devices and SPDK.</li></ul><h2 id="design-goals">Design Goals</h2><h3 id="scale-out-architecture">Scale-Out Architecture</h3><ul><li>The DFS Should Be Fully Scale-Out: A truly scalable distributed file system needs its components to scale independently. This includes not only the storage but also the computational responsibilities distributed across the system.</li><li>DataNode Should Take On Certain Calculations: If the NameNode handles all operations, it becomes a bottleneck as the number of DataNodes increases. This would require scaling up the NameNode, making the overall system less scalable.<ul><li>Chunk Allocation as an Example: When a client writes data, the system needs to determine the chunk locations, typically as a list like <code>[(ip=192.168.0.1, disk=nvme0n1, offset=8MiB, len=1MiB), ...]</code>. While the NameNode should calculate the IP and disk information, the offset should be calculated by each DataNode to distribute the load.</li><li>Cache Eviction in Systems Like Alluxio: In caching file systems, DataNodes should handle cache eviction decisions. Offloading such tasks to DataNodes reduces the NameNode's workload and allows for more efficient scaling.</li></ul></li><li>Metadata Locality on DataNodes: When partial calculations are handled by DataNodes, the relevant metadata should also reside on the DataNodes. Keeping this metadata localized prevents unnecessary bandwidth usage between NameNodes and DataNodes and simplifies the programming model.</li><li>Metadata Storage on DataNodes: A system is required to store the metadata locally on the DataNodes. This can be either a custom implementation or an existing solution like a key-value store. I prefer using a mature KV store such as RocksDB for this purpose, given its reliability and performance.</li></ul><p><strong>DataNode should take on certain calculations to ensure a truly scale-out architecture.</strong> As a result, we need a RocksDB-based metadata storage on each DataNode to support these operations.</p><h3 id="write-fast-read-fast">Write Fast, Read Fast</h3><ul><li>The time taken to process a client's write request should be equivalent to <strong>the time of one disk write operation</strong> on the DataNode. If a client's write request results in <strong>two sequential disk writes</strong>, the total time will be longer, which we aim to avoid.<ul><li>HDFS as a Counterexample: In HDFS, when a DataNode writes chunk data as an ext4 file, at least two sequential disk writes are required - one for the ext4 metadata journal and another for the actual data.</li><li>Another Counterexample: In a simple implementation, the DataNode first writes chunk metadata (e.g., to RocksDB) and then performs a separate disk I/O operation for the actual data. This results in two sequential disk writes, which we aim to avoid.</li></ul></li><li>To optimize read performance, each client's read request should result in only one I/O read operation. To achieve this, we must cache chunk metadata (e.g., chunk location) in memory, so that there's no need to retrieve it from disk before serving the read request.</li><li>Bypassing Kernel and CPU Overhead: The design should leverage advanced technologies that bypass kernel and CPU overheads, such as VFIO, SPDK, DMA, RDMA, and GPUDirect. These technologies minimize data copying and reduce latency, allowing for faster and more efficient data writes.</li></ul><p>The goal is to ensure that DataNodes perform the fewest possible disk operations - ideally just one. If two disk operations are necessary, they should be performed in parallel to minimize latency. And each operation should be as fast as possible.</p><h3 id="read-efficiency-a-new-data-layout-for-big-data-and-ai-scenarios">Read Efficiency: A New Data Layout for Big Data and AI Scenarios</h3><ul><li>In Big Data Scenarios:<ul><li>Compute engines often need to read only small portions of large chunks. For example, when reading statistics from a Parquet file, only a subset of the chunk is required, not the entire chunk.</li><li>Instead of using a single checksum for an entire chunk, small units within the chunk should each have their own checksum. For instance, Alibaba's Pangu splits a chunk into multiple sector units, each with its own CRC checksum. This allows the system to read only the necessary sectors and their corresponding checksums, instead of the entire chunk, optimizing performance when serving client read requests.</li></ul></li><li>In AI scenarios, entire chunk are read using DMA/RDMA/GPUDirect, requiring a contiguous data layout for efficient data movement.</li><li>Big Data workloads benefit from interrupted layouts with checksums for small units, while AI workloads prefer contiguous data for efficient sequential access. To effectively serve both scenarios, a new data layout is required:<ul><li>The data is divided into sectors, and each sector has its own CRC for integrity verification. These CRC values are stored alongside the metadata (e.g., in RocksDB), rather than interleaved with the actual data. This ensure that the data remains contiguous on disk.</li><li>To complement the new data layout, we need a new write process that can handle parallel writes for both metadata and data to minimize latency.</li></ul></li></ul><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-datanode-for-distributed-filesystem/self-contained-chunk-layout-in-pangu.png" alt="" /><figcaption>Self-contained Chunk Layout in Pangu</figcaption></figure><h3 id="self-contained-chunk-data-layout-for-recovery">Self-contained Chunk Data Layout for Recovery</h3><p>The goal is to ensure that even if metadata stored in the NameNode (e.g., directory tree) and metadata stored in the DataNode (e.g., chunk locations) are both lost, the system can still recover most of the data. This is crucial for maximizing data recovery in the event of unexpected disasters such as software bugs or operational errors. A self-contained chunk layout allows the system to reconstruct data independently, without relying on external metadata.</p><h2 id="disk-partition">Disk Partition</h2><p>In this section, we discuss how the disk should be partitioned. The disk is divided into two primary sections:</p><ul><li>Metadata Partition: This partition is dedicated to storing metadata. The metadata partition is further subdivided into two distinct parts:<ul><li>DBFS is a simple file system tailored to support RocksDB. It supports basic file operations such as creating append-only files, reading files, and deleting files.</li><li>RocksDB on DBFS: The second subdivision is reserved for RocksDB, which is built on top of DBFS.</li></ul></li><li>Data Partition: This partition holds the actual chunk data.</li></ul><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-datanode-for-distributed-filesystem/disk-partition-layout.excalidraw.svg" alt="" /><figcaption>Disk Partition Layout</figcaption></figure><h3 id="super-meta-edit-log-and-snapshot-format">Super Meta, Edit Log, and Snapshot Format</h3><p>All critical metadata in the system - such as the super meta, edit log, and snapshot - follows the same structured format. This format is designed to be <strong>self-explanatory</strong> and <strong>self-contained</strong>, ensuring that the system can interpret these regions without relying on additional code logic. The format is as follows:</p><ul><li>Each region starts with a magic number - a unique identifier that signals the type of the region (e.g., super meta, edit log, or snapshot).</li><li>After the magic number, a <code>uint32_t</code> specifies the length of the following protobuf message. This ensures that the system knows exactly how many bytes to read for the protobuf.</li><li>The protobuf message itself contains a variety of metadata, including a <strong><code>length</code> field</strong> that describes the total size of the region. This length field is crucial because it makes the region self-explanatory - the system can determine the full length of the region from the protobuf alone, without needing to reference external code or metadata.</li><li>Finally, the region is padded with zero bytes to reach the required alignment.</li></ul><h2 id="chunk-data-layout">Chunk Data Layout</h2><p>In this section, we will examine the current data layouts used by various DFS implementations and then propose a new layout that optimizes for our design goals, particularly the goals of <strong>write fast</strong>, <strong>read fast</strong>, and <strong>read efficiency</strong>. The data layout is at the heart of the entire DataNode architecture and has a profound effect on how we achieve the above design goals.</p><p>This section is divided into two main parts:</p><ul><li>Investigating Current Data Layouts: We will explore the existing data layouts used by popular DFS implementations, highlighting their strengths and weaknesses.</li><li>Proposing a New Data Layout: We will introduce a new layout that addresses the shortcomings of current designs and aligns with our goals. This will be divided into:<ul><li>Layout Specification: A detailed explanation of the new data layout, describing how data and metadata are organized on disk.</li><li>Layout Explanation Through Read/Write Process: A brief walk-through of how the proposed layout optimizes the read and write processes, illustrating why this design is more efficient and scalable.</li></ul></li></ul><h3 id="investigating-current-data-layouts">Investigating Current Data Layouts</h3><p>We will now investigate the data layouts of various distributed file systems and clarify the sources of this information.</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">HDFS</th><th style="text-align: center;">Ceph</th><th style="text-align: center;">GFS</th><th style="text-align: center;">Pangu</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Metadata and Data Layout</td><td style="text-align: center;">Split</td><td style="text-align: center;">Split</td><td style="text-align: center;">Split</td><td style="text-align: center;">Colocate</td></tr><tr class="even"><td style="text-align: center;">Disk Write Operations per Client Write Request</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">Disk Read Operations per Client Read Request</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">Read Efficiency for Small Portions of a Chunk</td><td style="text-align: center;">High</td><td style="text-align: center;">High</td><td style="text-align: center;">High</td><td style="text-align: center;">High</td></tr><tr class="odd"><td style="text-align: center;">Extra <code>memcpy</code> Required for Full Chunk Read</td><td style="text-align: center;">No</td><td style="text-align: center;">No</td><td style="text-align: center;">No</td><td style="text-align: center;">Yes</td></tr></tbody></table><p>The table highlights the tradeoff: if data and metadata are colocated, <strong>an extra <code>memcpy</code> is needed</strong> when reading the entire chunk due to interspersed checksums between data sectors. Conversely, if they are split, a client write request requires <strong>two disk write operations</strong>.</p><p>The following sources were used to gather the information presented in the table above:</p><ul><li><p>Ceph Source: <a href="https://pdl.cmu.edu/PDL-FTP/Storage/ceph-exp-sosp19.pdf">File Systems Unfit as Distributed Storage Backends: Lessons from 10 Years of Ceph Evolution</a></p><ul><li><p>Ceph performs two disk write operations, one for data and one for metadata:</p><blockquote><p>For incoming writes larger than a minimum allocation size (64 KiB for HDDs, 16 KiB for SSDs), the data is written to a newly allocated extent. Once the data is persisted, the corresponding metadata is inserted to RocksDB.</p></blockquote></li><li><p>Ceph also offers other valuable insights:</p><blockquote><p>BlueStore computes a checksum for every write and verifies the checksum on every read.</p><p>While multiple checksum algorithms are supported, crc32c is used by default because it is well-optimized on both x86 and ARM architectures, and it is sufficient for detecting random bit errors.</p><p>With full control of the I/O stack, BlueStore can choose the checksum block size based on the I/O hints. For example, if the hints indicate that writes are from the S3-compatible RGW service, then the objects are read-only and the checksum can be computed over 128 KiB blocks.</p><p>BlueStore achieves its first goal, fast metadata operations, by storing metadata in RocksDB. BlueStore achieves its second goal of no consistency overhead with two changes. First, it writes data directly to raw disk, resulting in one cache flush for data write. Second, it changes RocksDB to reuse WAL files as a circular buffer, resulting in one cache flush for metadata write - a feature that was upstreamed to the mainline RocksDB.</p></blockquote></li></ul></li><li><p>GFS Source: <a href="https://storage.googleapis.com/gweb-research2023-media/pubtools/4446.pdf">The Google File System</a></p><blockquote><p>A chunkis broken up into 64 KB blocks. Each has a corresponding 32 bit checksum. Like other metadata, checksums are kept in memory and stored persistently with logging, separate from user data.</p></blockquote></li><li><p>Pangu Source: <a href="https://www.usenix.org/system/files/fast23-li-qiang_more.pdf">More Than Capacity: Performance-oriented Evolution of Pangu in Alibaba</a></p><blockquote><p>A chunk includes multiple sector units, where each sector unit includes 3 elements: data, padding, and footer. The footer stores chunk metadata, such as chunk ID, chunk length, and the CRC checksum.</p></blockquote></li></ul><h3 id="proposing-a-new-data-layout">Proposing a New Data Layout</h3><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-datanode-for-distributed-filesystem/illustrated-chunk-data-layout-for-chunk-id-8859830.excalidraw.svg" alt="" /><figcaption>Illustrated Chunk Data Layout for Chunk ID 8859830</figcaption></figure><p>The following key design elements are highlighted:</p><ul><li>Splitting Metadata and Data: The chunk metadata (such as checksums and other metadata) and the actual data are stored separately.</li><li>Metadata Copy for Recovery: For recovery purposes, a copy of the metadata is appended at the end of the chunk data.</li><li>Self-Contained Data Format:<ul><li>The data ends with a magic number.</li><li>After the magic number, there's a protobuf length.</li><li>Next comes the protobuf message itself, which contains the serialized metadata or data structure.</li><li>Finally, the data is zero-padded to align with the underlying storage requirements.</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>DFS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Design Document: Enhancing Inode Attributes and Storage Policies in HDFS</title>
    <link href="/2024/08/27/computer-science/big-data/dfs/design-document-enhancing-inode-attributes-and-storage-policies-in-hdfs/"/>
    <url>/2024/08/27/computer-science/big-data/dfs/design-document-enhancing-inode-attributes-and-storage-policies-in-hdfs/</url>
    
    <content type="html"><![CDATA[<h2 id="background-hdfs-solutions-and-implementation-for-archival-storage">Background: HDFS Solutions and Implementation for Archival Storage</h2><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/ArchivalStorage.html">Apache Hadoop 3.3.6 &gt; Archival Storage, SSD &amp; Memory</a> introduces archival storage to decouple storage capacity from compute capacity:</p><blockquote><p>Archival Storage is a solution to decouple growing storage capacity from compute capacity. Nodes with higher density and less expensive storage with low compute power are becoming available and can be used as cold storage in the clusters. Based on policy the data from hot can be moved to the cold. Adding more nodes to the cold storage can grow the storage independent of the compute capacity in the cluster.</p></blockquote><p>Archival storage consists of two key components:</p><ol type="1"><li>Storage Policy Resolution: Determines the storage policy for files (e.g., hot, cold, warm, all SSD, one SSD).</li><li>Data Movement: Ensures data is relocated to match the storage policy, addressing any discrepancies between expected and actual storage locations.</li></ol><p><a href="https://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/ArchivalStorage.html">Apache Hadoop 3.3.6 &gt; Archival Storage, SSD &amp; Memory</a> and <a href="https://issues.apache.org/jira/browse/HDFS-10285">Storage-Policy-Satisfier-in-HDFS-Oct-26-2017.pdf</a> highlight two scenarios requiring data movement:</p><blockquote><ol type="1"><li>Setting a new storage policy on already existing file/dir will change the policy in Namespace, but it will not move the blocks physically across storage medias.</li><li>Other scenario is, when user rename the files from one affected storage policy file (inherited policy from parent directory) to another storage policy effected directory, it will not copy inherited storage policy from source. So it will take effect from destination file/dir parent storage policy. This rename operation is just a metadata change in Namenode. The physical blocks still remain with source storage policy.</li></ol></blockquote><p>Storage policy resolution is straightforward:</p><blockquote><p>The effective storage policy of a file or directory is resolved by the following rules.</p><ol type="1"><li>If the file or directory is specified with a storage policy, return it.</li><li>For an unspecified file or directory, if it is the root directory, return the default storage policy. Otherwise, return its parent's effective storage policy.</li></ol></blockquote><p>Users have two options to move blocks according to a new policy. The first option is the <a href="https://issues.apache.org/jira/browse/HDFS-10285">HDFS-10285: Storage Policy Satisfier in HDFS</a>. The following figures illustrate the basic workflow of SPS:</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/enhancing-inode-attributes-and-storage-policies-in-hdfs/fig-1-namenode-extensions.png" alt="" /><figcaption>Fig-1: Namenode extensions</figcaption></figure><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/enhancing-inode-attributes-and-storage-policies-in-hdfs/fig-2-coordinating-blocks-movement-using-c-dn.png" alt="" /><figcaption>Fig-2: Coordinatingblocksmovement using C-DN</figcaption></figure><p>The primary responsibility of the NameNode extensions is to recursively scan all files within a user-specified directory and connect with the Coordinator DataNode using the <code>BlockStorageMovementCommand</code>. The details are illustrated in <a href="https://issues.apache.org/jira/browse/HDFS-10285">Storage-Policy-Satisfier-in-HDFS-Oct-26-2017.pdf</a>:</p><blockquote><p>If the source path is a directory then all the files under the directory recursively would be considered for satisfying the policy. All the submitted directory inodes will be tracked separately at queue <code>BlockStorageMovementNeeded#spsDirsToBeTraversedLater</code>, these directories will be asynchronously traversed and all the file inodes under each directory will be added to the queue <code>BlockStorageMovementNeeded#storageMovementNeeded</code>. There could be a case of large directory, which can have several files under it. Here, traversing all files and collecting Inodes would be time consuming and its not recommended to hold Namenode locks longer time until the directory is fully scanned. Again, this could increase memory consumption if we keep lot of files inode into memory. To avoid these issues, SPS will throttle itself and traverse the directories in batch wise. Added a limit of 1000 size to the queue <code>storageMovementNeeded</code>. If <code>storageMovementNeeded</code> becomes full with 1000 elements, directory traversal will be suspended until <code>storageMovementNeeded</code> has some free slots available, lower than 1000. When scan was suspended, it releases the Namenode lock, so that other Namenode operations will not be blocked.</p></blockquote><h2 id="limitations-in-xattr-resolution-and-improvements">Limitations in Xattr Resolution and Improvements</h2><p>In general, we not only consider storage policy as a standalone concept but treat it as a type of xattr. The following section discusses xattrs in this broader context.</p><h3 id="current-limitations-in-xattr-resolution">Current Limitations in Xattr Resolution</h3><p>In HDFS, the biggest shortcoming of storage policy resolution is its counter-intuitive nature. Consider this example, where TxID (transaction ID) represents the logical clock for capturing "happen-before" relationships - transactions with smaller TxID values occur before those with larger ones:</p><ul><li>Operations:<ul><li>[TxID=1] Set storage policy to "hot" on directory /a/b.</li><li>[TxID=2] Set storage policy to "all ssd" on directory /a.</li></ul></li><li>Result: The file /a/b/c unexpectedly retains the "hot" storage policy, even when the policy for the entire /a directory is reset. Let's take the Linux <code>chown</code> command as an example. In Linux, if a user executes <code>chown -R</code> on /a, it may not affect /a/b/c if <code>chown -R</code> was previously executed on /a/b. This behavior can seem unexpected and counter-intuitive.</li></ul><h3 id="desired-behavior-for-xattr-resolution">Desired Behavior for Xattr Resolution</h3><p>Let's define the following terms for our discussion:</p><ul><li>Immediate Parent (or Parent): /a is the immediate parent of /a/b, but not of /a/b/c.</li><li>Ancestor: Both /a and /a/b are ancestors of /a/b/c.</li><li>Immediate Child (or Child): /a/b is the immediate child of /a, but /a/b/c is not.</li><li>Descendant: Both /a/b and /a/b/c are descendants of /a.</li><li>Non-inherited Xattr: When an xattr is set on /a, only /a is affected; its descendants are not.</li><li>Inherited Xattr: When an xattr is set on /a, it also affects the xattrs of /a's descendants.</li><li>Rename Affected Inherited Xattr: When /a/c is renamed to /b/c, /b/c's xattr aligns with /b instead of retaining its original xattr.</li><li>Non-rename Affected Inherited Xattr: When /a/c is renamed to /b/c, /b/c retains its original xattr without change.</li></ul><p>In this section, we focus on inherited xattrs. The implementation of non-inherited xattrs is straightforward and not worth discussing in detail. Below, we explore the desired behavior for inherited xattrs. Let's define what kind of xattr resolution is intuitive and straightforward:</p><ul><li>Imagine a "magician" who can instantly modify the xattr of the target inode and all its descendant inodes.</li><li>Each inode's xattr is determined by the most recent operation applied to it.</li></ul><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-enhancing-inode-attributes-and-storage-policies-in-hdfs/illustration-of-intuitive-rename-affected-inherited-xattr-resolution.excalidraw.svg" alt="" /><figcaption>Illustration of Intuitive Rename Affected Inherited Xattr Resolution</figcaption></figure><p>The graph above illustrates how the "magician" handles rename affected inherited xattr:</p><ul><li>In TxID 1, a and all its descendants are set to blue when the user sets /a to blue.</li><li>In TxID 3, d inherits the blue xattr from its destination parent.</li></ul><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-enhancing-inode-attributes-and-storage-policies-in-hdfs/illustration-of-intuitive-non-rename-affected-inherited-xattr-resolution.excalidraw.svg" alt="" /><figcaption>Illustration of Intuitive Non-rename Affected Inherited Xattr Resolution</figcaption></figure><p>The graph above illustrates how the "magician" handles non-rename affected inherited xattr. It is similar to rename affected inherited xattr, but with one key difference: when /a/b is renamed to /a/c/b, b and <strong>its descendant inodes</strong> retain their original xattrs.</p><h3 id="implementation-outline-for-improved-resolution">Implementation Outline for Improved Resolution</h3><h4 id="rename-affected-inherited-xattr">Rename Affected Inherited Xattr</h4><p>Let's discuss the rename affected inherited xattr first. We define the following symbols to aid our discussion:</p><ul><li><span class="math inline">\(\operatorname{TxID}(\text{node}, \text{setxattr})\)</span>: The transaction ID when xattr is set on <span class="math inline">\(\text{node}\)</span>.</li><li><span class="math inline">\(\operatorname{TxID}(\text{node}, \text{renamed})\)</span>: The transaction ID when <span class="math inline">\(\text{node}\)</span> is renamed.</li><li><span class="math inline">\(\operatorname{TxID}(\text{node})\)</span>: The transaction ID that determines the xattr of <span class="math inline">\(\text{node}\)</span>.</li></ul><p>There are three operations for a node: create, rename, and delete. We'll focus on the most complex operation, rename.</p><p>To simplify the process, imagine that a setxattr event always accompanies a rename event. For example, when [TxID=3] renames /a/b/d to /a/c/d, it also generates a setxattr event [TxID=3] to set /a/c/d's xattr to /a/c's xattr. This introduces a constraint: <span class="math inline">\(\operatorname{TxID}(\text{node}, \text{setxattr}) \ge \operatorname{TxID}(\text{node}, \text{renamed})\)</span>.</p><p>Now, let's denote the node we are calculating as <span class="math inline">\(\text{self}\)</span> and its parent as <span class="math inline">\(\text{parent}\)</span>. There are three cases to consider:</p><ul><li><span class="math inline">\(\operatorname{TxID}(\text{parent}) &gt; \operatorname{TxID}(\text{self}, \text{setxattr}) \ge \operatorname{TxID}(\text{self}, \text{renamed})\)</span>: This means that <span class="math inline">\(\text{self}\)</span> was first moved into <span class="math inline">\(\text{parent}\)</span>, then <span class="math inline">\(\text{parent}\)</span> or its ancestors had their xattr set by a user's direct setxattr request or an accompanying event triggered by a user's rename request. The xattr should be determined by the parent's xattr. This is correct because the event at <span class="math inline">\(\text{parent}\)</span> or its ancestors is more recent.</li><li><span class="math inline">\(\operatorname{TxID}(\text{self}, \text{setxattr}) &gt; \operatorname{TxID}(\text{parent}) &gt; \operatorname{TxID}(\text{self}, \text{renamed})\)</span>: Here, <span class="math inline">\(\text{self}\)</span> is renamed into <span class="math inline">\(\text{parent}\)</span>, then the ancestor's xattr is set, and finally, <span class="math inline">\(\text{self}\)</span>'s xattr is set. The xattr should be determined by the setxattr event on <span class="math inline">\(\text{self}\)</span>. This is straightforward.</li><li><span class="math inline">\(\operatorname{TxID}(\text{self}, \text{setxattr}) \ge \operatorname{TxID}(\text{self}, \text{renamed}) &gt; \operatorname{TxID}(\text{parent})\)</span>: The xattr should be determined by the setxattr event on <span class="math inline">\(\text{self}\)</span>. This is also straightforward.</li></ul><p>The above three cases can be simplified to two:</p><ul><li><span class="math inline">\(\operatorname{TxID}(\text{parent}) &gt; \operatorname{TxID}(\text{self}, \text{setxattr})\)</span>: The xattr should be determined by the parent's xattr.</li><li><span class="math inline">\(\operatorname{TxID}(\text{self}, \text{setxattr}) &gt; \operatorname{TxID}(\text{parent})\)</span>: The xattr should be determined by the setxattr event on <span class="math inline">\(\text{self}\)</span>.</li></ul><p>Interestingly, we find that we don't need to record <span class="math inline">\(\operatorname{TxID}(\text{self}, \text{renamed})\)</span> because it is unnecessary. The xattr of <span class="math inline">\(\text{self}\)</span> is determined by the maximum <span class="math inline">\(\operatorname{TxID}(\text{node}, \text{setxattr})\)</span>, where <span class="math inline">\(\text{node}\)</span> is <span class="math inline">\(\text{self}\)</span> or its ancestors.</p><h4 id="non-rename-affected-inherited-xattr">Non-rename Affected Inherited Xattr</h4><p>In discussing non-rename affected inherited xattrs, we encounter more complexity compared to rename-affected inherited xattrs. The following two graphs illustrate these complexities. Notice that the color represents the expected xattr (also referred to as the "magician" xattr), while the actual xattr of each node is indicated by text.</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-enhancing-inode-attributes-and-storage-policies-in-hdfs/illustration-for-tracking-txids-in-xattr-resolution-graph-1.excalidraw.svg" alt="" /><figcaption>Illustration for Tracking TxIDs in Xattr Resolution (Graph 1)</figcaption></figure><p>In Graph 1, at TxID 6, the expected xattr of d is not influenced by its parent c, because d was renamed after c set its xattr. Conversely, e's expected xattr is affected by its parent c since it was renamed before c's setxattr. At TxID 7, when e's xattr is set, it is no longer influenced by its parent. Therefore, the expected xattr is calculated using its rename TxID, setxattr TxID, and its parent's setxattr TxID.</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/design-document-enhancing-inode-attributes-and-storage-policies-in-hdfs/illustration-for-tracking-txids-in-xattr-resolution-graph-2.excalidraw.svg" alt="" /><figcaption>Illustration for Tracking TxIDs in Xattr Resolution (Graph 2)</figcaption></figure><p>In Graph 2, TxID 6 shows a rename operation. When renaming d:</p><ul><li>d should inherit the actual xattr blue from its source parent c. Otherwise, if its actual xattr remains white after renaming, the expected xattr for d and its children cannot be calculated.</li><li>Naturally, d should also inherit the setxattr TxID from its source parent c.<ul><li>One way to think about this is that when setxattr was applied to c at TxID 3, the "magician" set all of its descendants' setxattr TxID to 3 at that moment. To avoid losing this information during renaming, d should inherit the TxID from its parent.</li><li>Another perspective is that d's setxattr TxID should be greater than e's setxattr TxID (2) and smaller than f's setxattr TxID (4), which can only be 3. Otherwise, at least one of d's children's xattrs cannot be calculated.</li></ul></li></ul><p>Combining insights from Graph 1 and Graph 2, the algorithm for calculating non-rename affected inherited xattrs becomes clear:</p><ul><li>Compare the inode's setxattr TxID, rename TxID, and the parent's setxattr TxID to determine the inode's xattr. Recursively apply this process up to the root.</li><li>When a rename occurs, the renamed inode should inherit the setxattr TxID and xattr from its ancestors if necessary. The setxattr TxID should be from the ancestor whose setxattr influences the renamed inode's xattr. Similarly, the xattr should be from the ancestor whose setxattr affects the renamed inode's xattr.</li></ul><h3 id="formal-verification-with-tla">Formal Verification with TLA+</h3><p>In the following TLA+ specification, we do not use natural numbers as TxIDs for rename and setxattr operations. Instead, we use a variable <code>modOrder</code> to capture the "happens-before" relationship of operations. This approach reduces the number of states TLA+ needs to calculate, as the specific TxID values become irrelevant. For example, the setxattr of a and b at TxIDs 1 and 3, or at 2 and 4, are considered identical when using <code>modOrder</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><code class="hljs tla">---------------------------------------- MODULE Xattr ----------------------------------------<br>EXTENDS Naturals, Sequences, TLC<br>CONSTANTS root, inodes, null, values, rename, setxattr, operations<br><br>ASSUME<br>  /\ root \notin inodes<br>  /\ null \in values<br>  /\ operations = &#123;rename, setxattr&#125;<br><br>VARIABLES parent,<br>          expRenAffXattr, actRenAffXattr,<br>          expNonRenAffXattr, actNonRenAffXattr,<br>          modOrder<br>SYMM == Permutations(inodes) \union Permutations(values \ &#123;null&#125;)<br><br>\* Utility Operations.<br>Min(set) == CHOOSE x \in set: \A y \in set: x &lt;= y<br>Max(set) == CHOOSE x \in set: \A y \in set: x &gt;= y<br>RECURSIVE IndexOf(_, _)<br>IndexOf(seq, ele) ==<br>  IF seq = &lt;&lt;&gt;&gt; THEN 0<br>  ELSE IF Head(seq) = ele THEN 1<br>  ELSE LET i == IndexOf(Tail(seq), ele) IN<br>       IF i = 0 THEN 0 ELSE i + 1<br>RECURSIVE Remove(_, _)<br>Remove(seq, set) ==<br>  IF Len(seq) = 0 THEN seq<br>  ELSE (<br>       (IF Head(seq) \in set THEN &lt;&lt;&gt;&gt; ELSE &lt;&lt;Head(seq)&gt;&gt;)<br>    \o Remove(Tail(seq), set))<br>Reinsert(seq, fromIndex, toIndex) ==<br>  IF toIndex &gt;= fromIndex<br>  THEN LET elem == seq[fromIndex]<br>           withoutEleSeq ==<br>                SubSeq(seq, 1, fromIndex - 1)<br>             \o SubSeq(seq, fromIndex + 1, Len(seq))<br>       IN   SubSeq(withoutEleSeq, 1, toIndex - 1)<br>         \o &lt;&lt;elem&gt;&gt;<br>         \o SubSeq(withoutEleSeq, toIndex, Len(withoutEleSeq))<br>  ELSE Assert(FALSE, &quot;toIndex must be greater than or equal to fromIndex.&quot;)<br><br>NodeSet == inodes \cup &#123;root&#125;<br>IsParent(p, c) == &lt;&lt;p, c&gt;&gt; \in parent<br>RECURSIVE IsAncestor(_, _)<br>IsAncestor(a, d) ==<br>  \/ IsParent(a, d)<br>  \/ (\E p \in NodeSet: IsParent(a, p) /\ IsAncestor(p, d))<br>IsSelfOrAncestor(sa, d) ==<br>  \/ sa = d<br>  \/ IsAncestor(sa, d)<br>IsDescendant(d, a) == IsAncestor(a, d)<br>IsSelfOrDescendant(sd, a) == IsDescendant(sd, a) \/ sd = a<br><br>CalcRenAffXattr(n) ==<br>  LET ancestors == &#123;a \in NodeSet: IsSelfOrAncestor(a, n)&#125;<br>      filteredSeq == SelectSeq(modOrder, LAMBDA x: x[1] \in ancestors)<br>      len == Len(filteredSeq)<br>  IN IF len = 0<br>     THEN null<br>     ELSE actRenAffXattr[filteredSeq[len][1]]<br><br>RECURSIVE GetNonRenXattrModIDR(_, _, _)<br>GetNonRenXattrModIDR(n, renameID, setXattrID) ==<br>  IF ~IsAncestor(root, n) THEN setXattrID<br>  ELSE LET p == CHOOSE x \in NodeSet: IsParent(x, n)<br>           parentRenameID == IndexOf(modOrder, &lt;&lt;p, rename&gt;&gt;)<br>           parentSetXattrID == IndexOf(modOrder, &lt;&lt;p, setxattr&gt;&gt;)<br>           maxRenameID == Max(&#123;parentRenameID, renameID&#125;)<br>           maxSetXattrID == IF parentSetXattrID &gt; Max(&#123;setXattrID, renameID&#125;)<br>                            THEN parentSetXattrID<br>                            ELSE setXattrID<br>       IN GetNonRenXattrModIDR(p, maxRenameID, maxSetXattrID)<br>GetNonRenXattrModID(n) ==<br>  LET renameID == IndexOf(modOrder, &lt;&lt;n, rename&gt;&gt;)<br>      setXattrID == IndexOf(modOrder, &lt;&lt;n, setxattr&gt;&gt;)<br>  IN GetNonRenXattrModIDR(n, renameID, setXattrID)<br>CalcNonRenAffXattr(n) ==<br>  LET id == GetNonRenXattrModID(n)<br>  IN IF id = 0<br>     THEN null<br>     ELSE actNonRenAffXattr[modOrder[id][1]]<br><br>Init ==<br>  /\ parent = &#123;&#125;<br>  /\ expRenAffXattr = [n \in NodeSet |-&gt; null]<br>  /\ actRenAffXattr = [n \in NodeSet |-&gt; null]<br>  /\ expNonRenAffXattr = [n \in NodeSet |-&gt; null]<br>  /\ actNonRenAffXattr = [n \in NodeSet |-&gt; null]<br>  /\ modOrder = &lt;&lt;&gt;&gt;<br><br>Create(n, p) ==<br>  /\ ~IsDescendant(n, root)<br>  /\ IsSelfOrDescendant(p, root)<br>  /\ parent&#x27; = parent \cup &#123;&lt;&lt;p, n&gt;&gt;&#125;<br>  /\ expRenAffXattr&#x27; = [expRenAffXattr EXCEPT ![n] = expRenAffXattr[p]]<br>  /\ actRenAffXattr&#x27; = [actRenAffXattr EXCEPT ![n] = CalcRenAffXattr(p)]<br>  /\ UNCHANGED &lt;&lt;expNonRenAffXattr, actNonRenAffXattr&gt;&gt;<br>  /\ modOrder&#x27; = Append(Append(modOrder, &lt;&lt;n, rename&gt;&gt;), &lt;&lt;n, setxattr&gt;&gt;)<br>Rename(n, p1, p2) ==<br>  /\ IsSelfOrDescendant(p1, root)<br>  /\ IsSelfOrDescendant(p2, root)<br>  /\ IsParent(p1, n)<br>  /\ ~IsSelfOrAncestor(n, p2)<br>  /\ parent&#x27; = (parent \ &#123;&lt;&lt;p1, n&gt;&gt;&#125;) \union &#123;&lt;&lt;p2, n&gt;&gt;&#125;<br>  /\ expRenAffXattr&#x27; = [x \in NodeSet |-&gt;<br>                          IF IsSelfOrDescendant(x, n)<br>                          THEN expRenAffXattr[p2]<br>                          ELSE expRenAffXattr[x]]<br>  /\ actRenAffXattr&#x27; = [actRenAffXattr EXCEPT ![n] = CalcRenAffXattr(p2)]<br>  /\ UNCHANGED &lt;&lt;expNonRenAffXattr&gt;&gt;<br>  /\ actNonRenAffXattr&#x27; = [actNonRenAffXattr EXCEPT ![n] = CalcNonRenAffXattr(n)]<br>  /\ modOrder&#x27; =<br>       Append(<br>         Remove(<br>           Reinsert(modOrder,<br>                    IndexOf(modOrder, &lt;&lt;n, setxattr&gt;&gt;),<br>                    GetNonRenXattrModID(n)),<br>           &#123;&lt;&lt;n, rename&gt;&gt;&#125;),<br>         &lt;&lt;n, rename&gt;&gt;)<br>  /\ LET i == IndexOf(modOrder&#x27;, &lt;&lt;n, setxattr&gt;&gt;)<br>         j == IndexOf(modOrder&#x27;, &lt;&lt;modOrder[GetNonRenXattrModID(n)][1], setxattr&gt;&gt;)<br>     IN Assert(i = j \/ i = j + 1,<br>               &quot;n&#x27;s setxattr should be directly after its latest ancestor&#x27;s setxattr.&quot;)<br>Delete(n) ==<br>  LET descendants == &#123;x \in NodeSet: IsSelfOrDescendant(x, n)&#125; IN<br>  /\ IsDescendant(n, root)<br>  /\ parent&#x27; = &#123;&lt;&lt;p, c&gt;&gt; \in parent: ~IsDescendant(c, n) /\ c # n&#125;<br>  /\ expRenAffXattr&#x27; = [x \in NodeSet |-&gt;<br>                          IF IsSelfOrDescendant(x, n)<br>                          THEN null<br>                          ELSE expRenAffXattr[x]]<br>  /\ actRenAffXattr&#x27; = [x \in NodeSet |-&gt;<br>                          IF IsSelfOrDescendant(x, n)<br>                          THEN null<br>                          ELSE actRenAffXattr[x]]<br>  /\ expNonRenAffXattr&#x27; = [x \in NodeSet |-&gt;<br>                             IF IsSelfOrDescendant(x, n)<br>                             THEN null<br>                             ELSE expNonRenAffXattr[x]]<br>  /\ actNonRenAffXattr&#x27; = [x \in NodeSet |-&gt;<br>                             IF IsSelfOrDescendant(x, n)<br>                             THEN null<br>                             ELSE actNonRenAffXattr[x]]<br>  /\ modOrder&#x27; =<br>       Remove(<br>         modOrder,<br>         &#123;x \in inodes: IsSelfOrDescendant(x, n)&#125; \times operations)<br>SetXattr(n, v) ==<br>  /\ IsDescendant(n, root)<br>  /\ expRenAffXattr&#x27; = [x \in NodeSet |-&gt;<br>                         IF IsSelfOrDescendant(x, n) THEN v<br>                         ELSE expRenAffXattr[x]]<br>  /\ actRenAffXattr&#x27; = [actRenAffXattr EXCEPT ![n] = v]<br>  /\ expNonRenAffXattr&#x27; = [x \in NodeSet |-&gt;<br>                            IF IsSelfOrDescendant(x, n) THEN v<br>                            ELSE expNonRenAffXattr[x]]<br>  /\ actNonRenAffXattr&#x27; = [actNonRenAffXattr EXCEPT ![n] = v]<br>  /\ modOrder&#x27; = Append(Remove(modOrder, &#123;&lt;&lt;n, setxattr&gt;&gt;&#125;), &lt;&lt;n, setxattr&gt;&gt;)<br>  /\ UNCHANGED &lt;&lt;parent&gt;&gt;<br>Next ==<br>  \/ \E n \in inodes, p \in NodeSet: Create(n, p)<br>  \/ \E n \in inodes, p1, p2 \in NodeSet: Rename(n, p1, p2)<br>  \/ \E n \in inodes: Delete(n)<br>  \/ \E n \in inodes, v \in values: SetXattr(n, v)<br><br>Spec ==<br>  /\ Init<br>  /\ [][Next]_&lt;&lt;parent,<br>               expRenAffXattr, actRenAffXattr,<br>               expNonRenAffXattr, actNonRenAffXattr,<br>               modOrder&gt;&gt;<br><br>TypeOK ==<br>  /\ \A &lt;&lt;p, c&gt;&gt; \in parent:<br>      p \in NodeSet /\ c \in inodes /\ IsSelfOrDescendant(p, root)<br>  /\ expRenAffXattr \in [NodeSet -&gt; values]<br>  /\ actRenAffXattr \in [NodeSet -&gt; values]<br>  /\ expNonRenAffXattr \in [NodeSet -&gt; values]<br>  /\ actNonRenAffXattr \in [NodeSet -&gt; values]<br>  /\ modOrder \in Seq(inodes \times operations)<br>  /\ \A n \in inodes:<br>          (IndexOf(modOrder, &lt;&lt;n, rename&gt;&gt;) # 0 /\ IndexOf(modOrder, &lt;&lt;n, setxattr&gt;&gt;) # 0)<br>      &lt;=&gt; IsDescendant(n, root)<br>  /\ \A n \in inodes, op \in operations:<br>       \A i, j \in 1..Len(modOrder):<br>         (modOrder[i] = &lt;&lt;n, op&gt;&gt; /\ modOrder[j] = &lt;&lt;n, op&gt;&gt;) =&gt; i = j<br><br>Consistent ==<br>  /\ \A n \in NodeSet: CalcRenAffXattr(n) = expRenAffXattr[n]<br>  /\ \A n \in NodeSet: CalcNonRenAffXattr(n) = expNonRenAffXattr[n]<br><br>Invariant ==<br>  /\ TypeOK<br>  /\ Consistent<br>==============================================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* Xattr.cfg<br>CONSTANT<br>root = root<br>inodes = &#123;a, b, c, d&#125;<br>null = null<br>blue = blue<br>green = green<br>values = &#123;null, blue, green&#125;<br>rename = rename<br>setxattr = setxattr<br>operations = &#123;rename, setxattr&#125;<br><br>SYMMETRY<br>SYMM<br><br>SPECIFICATION<br>Spec<br><br>INVARIANT<br>Invariant<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># java -Xms60g -XX:+UseParallelGC -XX:MaxDirectMemorySize=60g -Dtlc2.tool.fp.FPSet.impl=tlc2.tool.fp.OffHeapDiskFPSet -cp /usr/local/lib/tla2tools.jar tlc2.TLC Xattr -workers auto -checkpoint 0</span><br>Model checking completed. No error has been found.<br>  Estimates of the probability that TLC did not check all reachable states<br>  because two distinct states had the same fingerprint:<br>  calculated (optimistic):  val = .0010<br>  based on the actual fingerprints:  val = 3.4E-6<br>740384039 states generated, 26449486 distinct states found, 0 states left on queue.<br>The depth of the complete state graph search is 19.<br>The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 25 and the 95th percentile is 5).<br>Finished <span class="hljs-keyword">in</span> 01h 25min at (2024-10-17 00:34:40)<br></code></pre></td></tr></table></figure><h2 id="proposing-enhancements-for-data-movement">Proposing Enhancements for Data Movement</h2><p>Some xattrs, such as storage policies, can affect data placement. HDFS proposes a storage policy satisfier that performs data movement based on recursive scanning to fulfill storage policies. However, it has a shortcoming: if the active namenode fails over during the process, it must rescan from the beginning. To overcome this, we propose:</p><ul><li>For newly created files, calculate the exact xattr using the above method and choose block locations based on the resolved xattr.</li><li>For renamed directories or files, if their xattr does not match the xattr after renaming, generate an index to inform the satisfier that this subtree needs handling.</li><li>For setxattr operations that change the xattr of a subtree, also generate an index to inform the satisfier.</li><li>The xattr satisfier scans the subtree indicated by the indices. When scanning a node, after setting the actual xattr of all <strong>immediate children</strong> to the expected xattr (note: if a child's actual xattr and expected xattr do not match, generate a new index), remove the corresponding index for that node.</li></ul><p>With this approach, each inode is scanned at most once, even if a namenode failover occurs.</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>DFS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Under the Hood - Implementing system_clock and steady_clock</title>
    <link href="/2024/08/21/computer-science/programming-language/c++/under-the-hood-implementing-system-clock-and-steady-clock/"/>
    <url>/2024/08/21/computer-science/programming-language/c++/under-the-hood-implementing-system-clock-and-steady-clock/</url>
    
    <content type="html"><![CDATA[<p>Time measurement and interval calculation are crucial components in various software systems, particularly for metrics, tracing, and logging. As these operations are frequently performed, there's a legitimate concern about their potential impact on program performance. To address this concern and gain a deeper understanding of time-related functions, this blog post delves into the implementation details of <code>system_clock</code> and <code>steady_clock</code>. By exploring their underlying mechanisms, we aim to shed light on the efficiency of these time-keeping tools and alleviate worries about performance overhead.</p><h2 id="unveiling-the-implementation-of-system_clock">Unveiling the Implementation of <code>system_clock</code></h2><p>The key point to understand is that <code>system_clock</code> operates with zero syscalls. As noted in <a href="https://stackoverflow.com/questions/71848553/how-does-one-do-a-zero-syscall-clock-gettime-without-dynamic-linking">Stack Overflow: How does one do a "zero-syscall clock_gettime" without dynamic linking?</a>:</p><blockquote><p>Call into the <code>clock_gettime</code> implementation in the VDSO, to use code+data exported by the kernel.</p></blockquote><p>According to <a href="https://en.wikipedia.org/wiki/VDSO">Wikipedia: vDSO</a>:</p><blockquote><p>vDSO (virtual dynamic shared object) is a kernel mechanism for exporting a carefully selected set of kernel space routines to user space applications so that applications can call these kernel space routines in-process, <strong>without incurring the performance penalty of a mode switch from user mode to kernel mode</strong> that is inherent when calling these same kernel space routines by means of the system call interface.</p></blockquote><p>In the vDSO, <code>clock_gettime</code> uses the <code>RDTSC</code> instruction to obtain the time, as explained on <a href="https://unix.stackexchange.com/questions/553845/should-i-be-seeing-non-vdso-clock-gettime-syscalls-on-x86-64-using-hpet">Stack Exchange: Should I be seeing (non-VDSO) clock_gettime() syscalls on x86_64 using HPET?</a>:</p><blockquote><p>In the vDSO, <code>clock_gettimeofday</code> and related functions are reliant on specific clock modes; see <code>__arch_get_hw_counter</code>. If the clock mode is <code>VCLOCK_TSC</code>, the time is read without a syscall, using <code>RDTSC</code>; if it's <code>VCLOCK_PVCLOCK</code> or <code>VCLOCK_HVCLOCK</code>, it's read from a specific page to retrieve the information from the hypervisor.</p></blockquote><p>To check the clock mode, <a href="https://repost.aws/knowledge-center/manage-ec2-linux-clock-source">AWS re:Post: How do I manage the clock source for EC2 instances running Linux?</a> suggests:</p><blockquote><p>To find the currently set clock source, list the contents of the current_clocksource file:</p><p><code>cat /sys/devices/system/clocksource/clocksource0/current_clocksource</code></p></blockquote><p>In my virtual machine, it shows <code>tsc</code>.</p><p><a href="https://www.felixcloutier.com/x86/rdtsc">Félix Cloutier: RDTSC</a> describes <code>RDTSC</code>:</p><blockquote><p>The processor monotonically increments the time-stamp counter <code>MSR</code> every clock cycle and resets it to 0 whenever the processor is reset. See "Time Stamp Counter" in Chapter 18 of the Intel@64 and IA-32 Architectures Software Developer's Manual, Volume 3B, for specific details of the time stamp counter behavior.</p></blockquote><p>Let's trace the <code>system_clock::now</code> function from GCC to Linux:</p><ol type="1"><li><a href="https://github.com/gcc-mirror/gcc/blob/723b30bee4e4fa3feba9ef03ce7dca95501e1555/libstdc%2B%2B-v3/src/c%2B%2B11/chrono.cc#L59"><code>system_clock::now</code></a> calls <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/arch/x86/entry/vdso/vclock_gettime.c#L38"><code>__vdso_clock_gettime</code></a>.</li><li><code>__vdso_clock_gettime</code> calls <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/lib/vdso/gettimeofday.c#L268"><code>__cvdso_clock_gettime_common</code></a>.</li><li><code>__cvdso_clock_gettime_common</code> calls <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/lib/vdso/gettimeofday.c#L164"><code>do_hres</code></a>.</li><li><code>do_hres</code> calls <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/arch/x86/include/asm/vdso/gettimeofday.h#L254"><code>__arch_get_hw_counter</code></a></li><li>Finally, <code>__arch_get_hw_counter</code> calls <code>rdtsc_ordered</code>.</li></ol><h2 id="system_clock-vs.-steady_clock-key-differences"><code>system_clock</code> vs. <code>steady_clock</code>: Key Differences</h2><p>When measuring time, both <code>system_clock</code> and <code>steady_clock</code> are suitable. However, I'm unsure about their differences and which one to use.</p><p>The key difference between system_clock and steady_clock lies in their base times: <a href="https://github.com/gcc-mirror/gcc/blob/723b30bee4e4fa3feba9ef03ce7dca95501e1555/libstdc%2B%2B-v3/src/c%2B%2B11/chrono.cc#L59"><code>system_clock::now</code></a> uses <code>CLOCK_REALTIME</code> with <code>clock_gettime</code>, <a href="https://github.com/gcc-mirror/gcc/blob/723b30bee4e4fa3feba9ef03ce7dca95501e1555/libstdc%2B%2B-v3/src/c%2B%2B11/chrono.cc#L87"><code>steady_clock::now</code></a> uses <code>CLOCK_MONOTONIC</code>. In the vDSO, <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/lib/vdso/gettimeofday.c#L133">do_hres</a> uses <code>CLOCK_REALTIME</code> and <code>CLOCK_MONOTONIC</code> as indices for <code>vd-&gt;basetime</code> to retrieve different base timestamps. I suspect that different indices of <code>vd-&gt;basetime</code> provide different base times. However, since <code>__arch_get_vdso_data</code> is a kernel function, I can't call it directly to test this.</p><p><code>system_clock</code> uses <code>vd-&gt;basetime[CLOCK_REALTIME]</code> to get its base time, which is not monotonic and can be adjusted at any moment. As noted in the <a href="https://en.cppreference.com/w/cpp/chrono/system_clock">C++ reference: std::chrono::system_clock</a>:</p><blockquote><p>It may not be monotonic: on most systems, the system time can be adjusted at any moment.</p></blockquote><h2 id="efficiency-comparison-clock_thread_cputime_id-vs.-system_clock">Efficiency Comparison: <code>CLOCK_THREAD_CPUTIME_ID</code> vs. <code>system_clock</code></h2><p>Besides measuring real time, measuring CPU time is also useful. For example, if a step takes a lot of real time and also a lot of CPU time, it indicates heavy computation (like a for loop). If it uses little CPU time, it might be due to insufficient CPU quota.</p><p>In the implementation of <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/lib/vdso/gettimeofday.c#L259-L266"><code>__cvdso_clock_gettime_common</code></a>, when <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/include/uapi/linux/time.h#L52"><code>CLOCK_THREAD_CPUTIME_ID</code></a> is used, it doesn't match any of the masks <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/include/vdso/datapage.h#L29"><code>VDSO_HRES</code></a>, <code>VDSO_COARSE</code>, or <code>VDSO_RAW</code>. As a result, the function returns -1. This return value triggers the caller function <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/lib/vdso/gettimeofday.c#L278"><code>__cvdso_clock_gettime_data</code></a> to fallback to <a href="https://github.com/torvalds/linux/blob/6e4436539ae182dc86d57d13849862bcafaa4709/arch/x86/include/asm/vdso/gettimeofday.h#L116"><code>clock_gettime_fallback</code></a>, leading to a syscall. Retrieving thread CPU time using <code>CLOCK_THREAD_CPUTIME_ID</code> is slower than using <code>system_clock::now</code> because it requires a syscall.</p><h2 id="benchmark">Benchmark</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> begin = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>  &#125;<br>  <span class="hljs-keyword">auto</span> end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>  std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - begin).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>  <span class="hljs-comment">//</span><br>  begin = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    std::chrono::steady_clock::<span class="hljs-built_in">now</span>();<br>  &#125;<br>  end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>  std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - begin).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>  <span class="hljs-comment">//</span><br>  begin = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    timespec t;<br>    <span class="hljs-built_in">clock_gettime</span>(CLOCK_THREAD_CPUTIME_ID, &amp;t);<br>  &#125;<br>  end = std::chrono::system_clock::<span class="hljs-built_in">now</span>();<br>  std::cout &lt;&lt; std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::nanoseconds&gt;(end - begin).<span class="hljs-built_in">count</span>() &lt;&lt; std::endl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># g++ test.cc -O0 -o test</span><br><span class="hljs-comment"># ./test</span><br>24975888<br>23460648<br>581884166<br></code></pre></td></tr></table></figure><p>The benchmark results support the analysis:</p><ul><li><code>system_clock</code> and <code>steady_clock</code> have similar performance, while <code>CLOCK_THREAD_CPUTIME_ID</code> is significantly slower due to the syscall fallback.</li><li>Calling <code>system_clock::now</code> costs 25 nanoseconds, demonstrating its high efficiency.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Understanding Raft within the Context of a Generalized Solution to Distributed Consensus</title>
    <link href="/2024/02/02/computer-science/consensus/understanding-raft-within-the-context-of-a-generalized-solution-to-distributed-consensus/"/>
    <url>/2024/02/02/computer-science/consensus/understanding-raft-within-the-context-of-a-generalized-solution-to-distributed-consensus/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p><a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a> introduces an abstract framework for reasoning about the correctness of consensus protocols. Within this framework, four rules are specified to ensure the protocol's correctness, with the following two being particularly crucial:</p><blockquote><ul><li>Before a client writes a value to a register <span class="math inline">\(R_i\)</span> in register set <span class="math inline">\(i\)</span>, it needs to ensure that no other values could be decided in register sets <span class="math inline">\(0\)</span> through <span class="math inline">\(i\)</span> (inclusive). The client plans to write into register <span class="math inline">\(R_i\)</span>; however, it's the client's responsibility to verify that none of the previous registers could decide on a different value prior to doing so. This is a crucial step for maintaining safety. All clients must perform this check to prevent conflicting decisions.<ul><li>Interestingly, if writing to a register <span class="math inline">\(R_i\)</span> wouldn't lead to a value being decided, then the client has the freedom to write any value of their preference. This implies that a more relaxed condition could be proposed. However, this relaxed aspect is not significant in the current context, so it is omitted.</li><li>Rule 3: <strong>Current decision</strong>. A client may only write a (non-nil) value <span class="math inline">\(v\)</span> to register <span class="math inline">\(r\)</span> on server <span class="math inline">\(s\)</span> provided that if <span class="math inline">\(v\)</span> is decided in register set <span class="math inline">\(r\)</span> by a quorum <span class="math inline">\(Q \in \mathcal{Q}_r\)</span> where <span class="math inline">\(s \in Q\)</span> then no value <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v \neq v^\prime\)</span> can also be decided in register set <span class="math inline">\(r\)</span>.</li><li>Rule 4: <strong>Previous decisions</strong>. A client may only write a (non-nil) value <span class="math inline">\(v\)</span> to register <span class="math inline">\(r\)</span> provided no value <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v \neq v^\prime\)</span> can be decided by the quorums in register sets <span class="math inline">\(0\)</span> to <span class="math inline">\(r − 1\)</span>.</li></ul></li></ul></blockquote><p>I am going to understand Raft by examining how it adheres to these two critical rules.</p><h2 id="how-does-raft-satisfy-the-current-decision-rule">How Does Raft Satisfy the Current Decision Rule?</h2><blockquote><p>Alternatively, we can support disjoint quorums if we require that all values written to a given register set are the same. This can be achieved by assigning register sets to clients and requiring that clients write only to their own register sets, with at most one value. In practice, this could be implemented by using an allocation such as that in Figure 4 and by requiring clients to keep a persistent record of which register sets they have written too. We refer to these as <strong>client restricted configurations</strong>.</p></blockquote><p>In <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>, Leslie Lamport introduces the concept of a ballot number as a tuple, where each ballot number is composed of an integer and a unique identifier of a participant, referred to as a "priest". I have named this approach <strong>preallocation</strong> or <strong>static allocation</strong>, which enables client restricted configurations.</p><table><thead><tr class="header"><th style="text-align: center;">Ballot ID</th><th style="text-align: center;">Priest/Client</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">(13, <span class="math inline">\(\Gamma \rho \alpha \breve{\iota}\)</span>)</td><td style="text-align: center;"><span class="math inline">\(\Gamma \rho \alpha \breve{\iota}\)</span></td></tr><tr class="even"><td style="text-align: center;">(15, <span class="math inline">\(\Gamma \rho \alpha \breve{\iota}\)</span>)</td><td style="text-align: center;"><span class="math inline">\(\Gamma \rho \alpha \breve{\iota}\)</span></td></tr><tr class="odd"><td style="text-align: center;">(13, <span class="math inline">\(\Lambda \iota \nu \sigma \epsilon \breve{\iota}\)</span>)</td><td style="text-align: center;"><span class="math inline">\(\Lambda \iota \nu \sigma \epsilon \breve{\iota}\)</span></td></tr><tr class="even"><td style="text-align: center;">(15, <span class="math inline">\(\Lambda \iota \nu \sigma \epsilon \breve{\iota}\)</span>)</td><td style="text-align: center;"><span class="math inline">\(\Lambda \iota \nu \sigma \epsilon \breve{\iota}\)</span></td></tr></tbody></table><p><a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a> presents a round robin allocation mechanism for enabling client restricted configurations:</p><table><thead><tr class="header"><th style="text-align: center;">Register</th><th style="text-align: center;">Client</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">R0</td><td style="text-align: center;">C0</td></tr><tr class="even"><td style="text-align: center;">R3</td><td style="text-align: center;">C0</td></tr><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: center;">C0</td></tr><tr class="even"><td style="text-align: center;">R1</td><td style="text-align: center;">C1</td></tr><tr class="odd"><td style="text-align: center;">R4</td><td style="text-align: center;">C1</td></tr><tr class="even"><td style="text-align: center;">...</td><td style="text-align: center;">C1</td></tr><tr class="odd"><td style="text-align: center;">R2</td><td style="text-align: center;">C2</td></tr><tr class="even"><td style="text-align: center;">R5</td><td style="text-align: center;">C2</td></tr><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: center;">C2</td></tr></tbody></table><p><a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm</a> utilizes the <strong>election safety</strong> property (at most one leader can be elected in a given term) to enable client restricted configurations. This property is guaranteed through a specific electoral process: a candidate wins an election if it receives votes from a <strong>majority</strong> of the servers in the full cluster for the same term. Each server will vote for <strong>at most one</strong> candidate in a given term, on a first-come-first-served basis. The majority rule ensures that at most one candidate can win the election for a particular term. I have named this approach <strong>dynamic allocation</strong>.</p><h2 id="how-does-raft-satisfy-the-previous-decisions-rule">How Does Raft Satisfy the Previous Decisions Rule?</h2><p>Let's conceptualize Raft as an algorithm designed to reach agreement on a single decision (analogous to The Single-Decree Synod), focusing on a single replicated log entry, rather than its full implementation that reaches agreement on a series of decisions such as a log (akin to The Multi-Decree Parliament).</p><p>Raft and Paxos employ similar methods to adhere to Rule 4. Both algorithms initially apply a "fence-and-read-majority" strategy to create a decision table consisting of all entries from terms less than <span class="math inline">\(r\)</span>. Subsequently, they introduce a minor optimization: rather than assessing the entire decision table, they focus solely on identifying the highest term <span class="math inline">\(k\)</span> where <span class="math inline">\(k &lt; r\)</span> that holds a non-nil value in the responses. Unlike Paxos, Raft ensures through its leader election algorithm that the leader possesses the entry with the highest term <span class="math inline">\(k\)</span>, so the Raft paper states:</p><blockquote><p>In some consensus algorithms, such as Viewstamped Replication, a leader can be elected even if it doesn't initially contain all of the committed entries. These algorithms contain additional mechanisms to <strong>identify the missing entries and transmit them to the new leader</strong>, either during the election process or shortly afterwards. Unfortunately, this results in considerable additional mechanism and complexity.</p><p>Raft uses a simpler approach where it guarantees that all the committed entries from previous terms are present on each new leader from the moment of its election, without the need to transfer those entries to the leader. This means that log entries only flow in <strong>one direction</strong>, from leaders to followers, and leaders never overwrite existing entries in their logs.</p></blockquote><p>If the leader writes values to registers for term <span class="math inline">\(r\)</span>, the preceding argument holds true. However, in Raft, the leader writes the value <span class="math inline">\(v\)</span> to registers of term <span class="math inline">\(k\)</span> — the highest term for which registers contain the non-nil value <span class="math inline">\(v\)</span> as determined from the responses of the fence-and-read-majority action, and where <span class="math inline">\(k &lt; r\)</span> — instead of term <span class="math inline">\(r\)</span>. This deviation challenges the premise that each register is written to only once, and the assumption that each replica's local state table will always contain a subset of the values from the global state table.</p><blockquote><p>Raft incurs this extra complexity in the commitment rules because log entries retain their original term numbers when a leader replicates entries from previous terms. In other consensus algorithms, if a new leader re-replicates entries from prior "terms," it must do so with its new "term number." Raft's approach makes it easier to reason about log entries, since they maintain the same term number over time and across logs.</p></blockquote><p>Due to this deviation, Raft no longer conforms to Rule 4. To illustrate this, consider the following example from the Raft paper:</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/understanding-raft-within-the-context-of-a-generalized-solution-to-distributed-consensus/figure-8-a-time-sequence-showing-why-a-leader-cannot-determine-commitment-using-log-entries-from-older-terms.png" alt="" /><figcaption>Figure 8: A time sequence showing why a leader cannot determine commitment using log entries from older terms.</figcaption></figure><blockquote><p>... At this point, the log entry from term 2 has been replicated on a majority of the servers, but it is not committed. ... However, if S1 replicates an entry from its current term on a majority of the servers before crashing, as in (e), then this entry is committed (S5 cannot win an election).</p></blockquote><blockquote><p>To eliminate problems like the one in Figure 8, Raft never commits log entries from previous terms by counting replicas. <strong>Only log entries from the leader's current term are committed by counting replicas;</strong> once an entry from the current term has been committed in this way, then all prior entries are committed indirectly because of the Log Matching Property.</p></blockquote><p>In summary, due to a minor divergence, Raft does not align with the previous decisions rule outlined in <a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a>. To address this problem, Raft reinterprets the criteria for commitment or decision: a value <span class="math inline">\(v\)</span> is considered decided or committed if a quorum of servers contains the same non-nil value <span class="math inline">\(v\)</span> in their registers of the <strong>initial</strong> register set, as opposed to having it in corresponding registers across any same register sets as required by <a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a>.</p><h2 id="reference">Reference</h2><ul><li><a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li><li><a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Consensus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - Building Consistent Transactions with Inconsistent Replication</title>
    <link href="/2023/12/10/computer-science/serializability/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/"/>
    <url>/2023/12/10/computer-science/serializability/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>The paper <a href="https://syslab.cs.washington.edu/papers/tapir-tr14.pdf">Building Consistent Transactions with Inconsistent Replication</a> introduces an innovative approach to jointly optimizing concurrency control and consensus protocols, offering valuable insights that enhance my understanding of related works such as <a href="https://www.cs.cmu.edu/~dga/papers/epaxos-sosp2013.pdf">There Is More Consensus in Egalitarian Parliaments</a> and <a href="https://cwiki.apache.org/confluence/display/CASSANDRA/CEP-15%3A+General+Purpose+Transactions?preview=/188744725/188744736/Accord.pdf">CEP-15: Fast General Purpose Transaction</a>. The Q&amp;A section on the accompanying blog captures the questions I had when initially exploring this paper.</p><blockquote><p>Our key insight is that existing transactional storage systems <strong>waste</strong> work and performance by integrating a distributed transaction protocol and a replication protocol that <strong>both</strong> enforce strong consistency.</p></blockquote><blockquote><p>Maintaining the ordered log abstraction means that replicated transactional storage systems use expensive distributed coordination to enforce strict serial ordering in two places: the transaction protocol enforces a serial ordering of transactions across data partitions or shards, and the replication protocol enforces a serial ordering of operations within a shard.</p></blockquote><blockquote><p>By enforcing strong consistency only in the transaction protocol, TAPIR is able to commit transactions <strong>in a single round-trip</strong> and schedule distributed transactions <strong>with no centralized coordination</strong>.</p></blockquote><blockquote><p>To support IR’s weak consistency model, TAPIR integrates several novel techniques:</p><ul><li>Loosely synchronized clocks for optimistic transaction ordering at clients.</li><li>New use of optimistic concurrency control to detect conflicts with only a <strong>partial transaction history</strong>.</li><li>Multi-versioning for executing transactions out-of-order.</li></ul></blockquote><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/figure-2-example-read-write-transaction-using-two-phase-commit-viewstamped-replication-and-strict-two-phase-locking.png" alt="" /><figcaption><em>Figure 2: Example read-write transaction using two-phase commit, Viewstamped Replication and strict two-phase locking.</em> Each zone represents an availablity region, which could be a cluster, datacenter or geographic region. Each shard holds a partition of the data stored in the system and is replicated across zones for fault-tolerance. For each read-write transaction, there is a large amount of distributed coordination. The transaction protocol must coordinate reads with the designated leader in each shard to acquire locks. To commit a transaciton, the transaction protocol coordinates across shards and then the replication protocol must coordinate within each shard.</figcaption></figure><p>As illustrated in Figure 2, the two-phase commit protocol, when applied with viewstamped replication or Raft, requires a minimum of two round-trip times (RTTs). Considering the prepare phase within a Raft-based replication scenario: initially, the client communicates its intention to prepare a transaction to the leaders of Shard A, Shard B, and Shard C. Subsequently, each leader synchronizes this preparation event with its followers. Upon receiving affirmative responses from a majority, a leader then conveys its acknowledgment back to the client. In conclusion, the transaction preparation process from the client's perspective incurs a total of two RTTs: the first RTT occurs between the client and the leaders across Shard A, Shard B, and Shard C, while the second RTT takes place between these leaders and their respective followers.</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/figure-4-tapir-protocol.png" alt="" /><figcaption>Figure 4: TAPIR protocol.</figcaption></figure><p>Figure 4 shows the messages sent during a sample transaction in TAPIR. Compared to the protocol shown in Figure 2, TAPIR has three immediately apparent advantages:</p><ol type="1"><li><strong>Reads go to the closest replica.</strong> Unlike protocols that must send reads to the leader, TAPIR sends reads to the replica closest to the client.</li><li><strong>Successful transactions commit in one round-trip.</strong> Unlike protocols that use consistent replication, TAPIR commits most transactions in a single round- trip by eliminating cross-replica coordination.</li><li><strong>No leader needed.</strong> Unlike protocols that order operations at a leader, TAPIR replicas all process the same number of messages, eliminating a bottleneck.</li></ol><h2 id="qa">Q&amp;A</h2><h3 id="qa-on-tapir-fundamentals">Q&amp;A on TAPIR Fundamentals</h3><h4 id="understanding-the-key-distinctions-between-operatornamepreparetransaction-timestamp-and-operatornamecommittransaction-timestamp-operations">Understanding the Key Distinctions Between <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> and <span class="math inline">\(\operatorname{Commit}(transaction, timestamp)\)</span> Operations</h4><p>The most significant distinction is that replicas can <strong>independently</strong> decide to return <span class="math inline">\(\text{PREPARE-OK}\)</span> or <span class="math inline">\(\text{ABORT}\)</span>, without needing to communicate with other replicas. This independent decision is based on the outcome of the TAPIR validation checks, which may vary due to the different states that each replica might be in at the time of validation. Consequently, replicas may yield <strong>varying responses</strong>. The final decision is reached by a <strong>majority</strong> vote amongst the replicas, a process that is essentially a form of consensus. This is why the original paper refers to the <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> as a <strong>consensus operation</strong>. In contrast, the <span class="math inline">\(\operatorname{Commit}(transaction, timestamp)\)</span> operation is processed <strong>identically</strong> by all replicas, who then return the same result: they simply commit the transaction. Therefore, the <span class="math inline">\(\operatorname{Commit}(transaction, timestamp)\)</span> operation is termed an <strong>inconsistent operation</strong>.</p><blockquote><p>The result of <span class="math inline">\(\operatorname{Prepare}\)</span> at <strong>each</strong> replica depends on the outcome of the TAPIR validation checks. As noted, TAPIR validation checks have four possible outcomes.</p></blockquote><blockquote><p>Thus, in addition to normal-case execution, TAPIR performs the following checks for each operation:</p><ul><li><span class="math inline">\(\operatorname{Prepare}\)</span>: If the transaction has been committed or aborted (logged in the transaction log), <strong>ignore</strong>. Otherwise, TAPIR validation checks are run.</li><li><span class="math inline">\(\operatorname{Commit}\)</span>: Commit the transaction to the transaction log and update the data store. If prepared, remove from prepared transaction list.</li><li><span class="math inline">\(\operatorname{Abort}\)</span>: Log abort in the transaction log. If prepared, remove from prepared list.</li></ul></blockquote><blockquote><p>TAPIR prepares are consensus operations, while commits and aborts are inconsistent operations.</p></blockquote><p>Let's delve deeper into why the <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> operation <strong>is designed as</strong> a consensus operation, while the <span class="math inline">\(\operatorname{Commit}(transaction, timestamp)\)</span> operation is an inconsistent operation. TAPIR employs a typical two-phase commit (2PC) protocol, which requires a transaction to be committed only if all participating shards confirm that there are no conflicts. <strong>Once this confirmation is given, the decision to commit or abort is final</strong>, and thus, it should be uniformly persisted across all replicas of each shard. In other words, the replicas <strong>do not need to reconsider the decision</strong>; they only need to execute it, making it an inconsistent operation. Conversely, during the preparation phase, TAPIR necessitates that each replica independently performs validation checks. The final decision is derived from aggregating these individual responses. For this reason, it must be a consensus operation.</p><h4 id="evaluating-the-necessity-of-finalizing-successful-but-unfinalized-operatornamepreparetransaction-timestamp-operations">Evaluating the Necessity of Finalizing Successful but Unfinalized <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> Operations</h4><blockquote><p>If the <span class="math inline">\(\operatorname{Prepare}\)</span> times out without finalizing the result in one of the participant shards, then the TAPIR client must take a <strong>slow path</strong> to finish the transaction. If <span class="math inline">\(\operatorname{Prepare}\)</span> succeeded with <span class="math inline">\(\text{PREPARE-OK}\)</span> in every shard, the client commits the transaction, otherwise it aborts. To complete the transaction, the client first logs the outcome of the transaction to the backup coordinator group. It then notifies the client, and sends a <span class="math inline">\(\operatorname{Commit}\)</span> or <span class="math inline">\(\operatorname{Abort}\)</span> to all participant replicas.</p></blockquote><p>Is there a need to impose an obligation to finalize <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> operations that have been successful but remain unfinalized, specifically in cases where the transaction has not been committed via the fast path and subsequently enters the slow path?</p><p>Without that obligation in place, after a system endures up to <span class="math inline">\(f\)</span> simultaneous failures and subsequently undergoes recovery, the most critical scenario that could emerge are as follows. Because these operations had been successful but were not finalized at the time of system failures, following the recovery process, it is possible that replicas might <strong>achieve different consensuses</strong>. After the system has recovered from the failures, it's possible to find that some <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> operations have resulted in <span class="math inline">\(\text{ABORT}\)</span>, yet the corresponding transaction has already been committed through the slow path.</p><p>At first glance, these scenarios might suggest the presence of inconsistency within the system in the absence of such an obligation. However, this is not an issue of concern if the replicas are designed to unconditionally accept and process the <span class="math inline">\(\operatorname{Commit}(transaction, timestamp)\)</span> operation, regardless of the state of the corresponding <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> operation. By adhering to this straightforward rule, any appearance of inconsistency is effectively resolved, ensuring the system maintains consistent post-recovery.</p><p>In conclusion, such an obligation is <strong>unnecessary</strong>.</p><h4 id="evaluating-the-necessity-of-the-slow-path-for-abortion-processes">Evaluating the Necessity of the Slow Path for Abortion Processes</h4><blockquote><p>If the <span class="math inline">\(\operatorname{Prepare}\)</span> times out without finalizing the result in one of the participant shards, then the TAPIR client must take a slow path to finish the transaction. If <span class="math inline">\(\operatorname{Prepare}\)</span> succeeded with <span class="math inline">\(\text{PREPARE-OK}\)</span> in every shard, the client commits the transaction, otherwise it aborts. To complete the transaction, the client first logs the outcome of the transaction to the backup coordinator group. It then notifies the client, and sends a <span class="math inline">\(\operatorname{Commit}\)</span> or <span class="math inline">\(\operatorname{Abort}\)</span> to all participant replicas. The client <strong>uses the same slow path to abort the transaction</strong> if <span class="math inline">\(\operatorname{Prepare}\)</span> does not succeed in any shard because there were not enough matching responses.</p></blockquote><p>Why should the abortion process also be required to go through the slow path?</p><p>Because the TAPIR protocol is not designed to finalize unsuccessful <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> operations. In the event of failures and subsequent recovery, replicas can arrive at divergent consensus outcomes — <span class="math inline">\(\text{PREPARE-OK}\)</span> as opposed to the original <span class="math inline">\(\text{ABORT}\)</span> consensus. Without the slow path mechanism, a client might erroneously commit a transaction post-recovery that was initially aborted prior to recovery, leading to inconsistency within the system.</p><p>We could potentially design an alternative IR protocol capable of finalizing unsuccessful <span class="math inline">\(\operatorname{Prepare}\)</span> operations, which would allow TAPIR to abort transactions without resorting to the slow path. However, this would add complexity to the overall protocol.</p><h4 id="qa-on-coordinator-recovery">Q&amp;A on Coordinator Recovery</h4><h5 id="mechanisms-of-operatornamecoordinatorchangetransaction-viewtext-num-in-fencing-the-operatornamepreparetransaction-timestamp-operation">Mechanisms of <span class="math inline">\(\operatorname{CoordinatorChange}(transaction, view\text{-}num)\)</span> in Fencing the <span class="math inline">\(\operatorname{Prepare}(transaction, timestamp)\)</span> Operation</h5><blockquote><p>Coordinator recovery uses a coordinator change protocol, conceptually similar to Viewstamped Replication's view change protocol. The currently active backup coordinator is identified by indexing into the list <strong>with a coordinator-view number</strong>; it is the only coordinator permitted to log an outcome for the transaction.</p></blockquote><blockquote><p>If the new coordinator does not find a logged outcome, it sends a <span class="math inline">\(\operatorname{CoordinatorChange}(transaction, view\text{-}num)\)</span> message to all replicas in participating shards. Upon receiving this message, replicas agree <strong>not to process messages from the previous coordinator</strong>; they also reply to the new coordinator with any previous <span class="math inline">\(\operatorname{Prepare}\)</span> result for the transaction. Once the <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> is successful (at <span class="math inline">\(f+1\)</span> replicas in each participating shard), the new coordinator determines the outcome of the transaction in the following way.</p></blockquote><p>In the Single-Decree Synod protocol from <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>, a fencing mechanism is employed to halt the advancement of consensus on lower ballots that have not yet achieved consensus:</p><blockquote><p>Upon receipt of a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message from <span class="math inline">\(p\)</span> with <span class="math inline">\(b &gt; \operatorname{nextBal}(q)\)</span>, priest <span class="math inline">\(q\)</span> sets <span class="math inline">\(\operatorname{nextBal}(q)\)</span> to <span class="math inline">\(b\)</span> and sends a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message to <span class="math inline">\(p\)</span>, where <span class="math inline">\(v\)</span> equals <span class="math inline">\(\operatorname{prevVote}(q)\)</span>. A <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message is ignored if <span class="math inline">\(b \le \operatorname{nextBal}(q)\)</span>.</p></blockquote><p>This critical fencing mechanism is also implemented within coordinator recovery as the coordinator change protocol. In this context, <span class="math inline">\(view\text{-}num\)</span> is analogous to the Single-Decree Synod protocol's ballot number <span class="math inline">\(b\)</span>, and <span class="math inline">\(transaction\)</span> is comparable to the instance ID. Similar to the Synod's protocol commitment that a <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message is ignored if a higher <span class="math inline">\(\operatorname{NextBallot}(b^\prime)\)</span> message has been received, the coordinator change protocol ensures that messages from the previous coordinator are not processed.</p><h5 id="why-must-every-conflicting-transaction-use-the-slow-path">Why Must Every Conflicting Transaction Use the Slow Path?</h5><blockquote><p>However, every conflicting transaction must have used the slow path.</p></blockquote><p>A transaction is considered conflicting if any of its <span class="math inline">\(\operatorname{Prepare}\)</span> operations within a shard results in an <span class="math inline">\(\text{ABORT}\)</span> status, indicating a conflict. As previously discussed, the abortion process is required to go through the slow path. Therefore, by design, every conflicting transaction inevitably takes the slow path.</p><p>However, not all transactions that go through the slow path are necessarily conflicting. A transaction that has taken the slow path may also be a non-conflicting transaction that contains any successful but not yet finalized <span class="math inline">\(\operatorname{Prepare}\)</span> operations. In other words, transactions that use the slow path consist of two types: non-conflicting transactions still awaiting the finalization of at least one successful <span class="math inline">\(\operatorname{Prepare}\)</span> operation, and conflicting transactions.</p><h5 id="why-must-the-new-coordinator-await-the-completion-of-all-transactions">Why Must the New Coordinator Await the Completion of All Transactions?</h5><blockquote><p>In doing so, it receives any slow-path outcome that was logged by a previous coordinator. If such an outcome has been logged, the new coordinator must follow that decision; it notifies the client and all replicas in every shard.</p><p>... the new coordinator determines the outcome of the transaction in the following way:</p><ul><li>If any replica in any shard has recorded a <span class="math inline">\(\operatorname{Commit}\)</span> or <span class="math inline">\(\operatorname{Abort}\)</span>, it must be preserved.</li><li>If any shard has less than <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses, the transaction could not have committed on the fast path, so the new coordinator aborts it.</li><li>If at least <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> replicas in every shard have <span class="math inline">\(\text{PREPARE-OK}\)</span> responses, <strong>the outcome of the transaction is uncertain: it may or may not have committed on the fast path.</strong> However, every conflicting transaction must have used the slow path. <strong>The new coordinator polls the coordinator (or backup coordinators) of each of these transactions until they have completed.</strong> If those transactions committed, it aborts the transaction; otherwise, it sends <span class="math inline">\(\text{Prepare}\)</span> operations to the remaining replicas until it receives a total of <span class="math inline">\(f+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses and then commits.</li></ul></blockquote><p>I would like to emphasize the following part:</p><blockquote><p>... the outcome of the transaction is uncertain: it may or may not have committed on the fast path. ... The new coordinator polls the coordinator (or backup coordinators) of each of these transactions until they have completed.</p></blockquote><p>Consider the following, Case 1:</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/case-1-uncommitted-transaction-tau.drawio.svg" alt="" /><figcaption>Case 1: Uncommitted Transaction <span class="math inline">\(\tau\)</span></figcaption></figure><ul><li>In the combined context of Part A and Part B, we consider a collective group of <span class="math inline">\(\lfloor\frac{3f}{2}\rfloor\)</span> replicas. Each replica in this group first receives an <span class="math inline">\(\operatorname{Prepare}(\gamma, t_\gamma)\)</span> operation, and subsequently receives an <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> operation. Given that transactions <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\tau\)</span> are in conflict, and the replicas have already responded to <span class="math inline">\(\operatorname{Prepare}(\gamma, t_\gamma)\)</span> with <span class="math inline">\(\text{PREPARE-OK}\)</span>, they are compelled to respond to <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> with <span class="math inline">\(\text{ABORT}\)</span>.<ul><li>In Part A, there are <span class="math inline">\(f\)</span> replicas. These replicas do not respond to the <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> message from the new coordinator.</li><li>In Part B, there are <span class="math inline">\(\lfloor\frac{f}{2}\rfloor\)</span> replicas. These replicas inform the new coordinator of their previous <span class="math inline">\(\text{ABORT}\)</span> response for the <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> operation associated with transaction <span class="math inline">\(\tau\)</span>.</li></ul></li><li>In Part C, a group of <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> replicas is considered. These replicas have not received any operations about transaction <span class="math inline">\(\gamma\)</span>. Consequently, they respond to the <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> operation with <span class="math inline">\(\text{PREPARE-OK}\)</span>. Upon receiving a <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> message, they inform the new coordinator of their previous <span class="math inline">\(\text{PREPARE-OK}\)</span> response for the <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> operation associated with transaction <span class="math inline">\(\tau\)</span>.</li><li>After successfully receiving <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> responses from a combined total of <span class="math inline">\(f+1\)</span> replicas, encompassing both Part B and Part C (thereby the <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> is successful), the new coordinator is unable to commit the transaction <span class="math inline">\(\tau\)</span>. Such a commitment could result in a conflict where both transactions <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\tau\)</span> are committed within the system, leading to inconsistency. This situation arises from the potential that the client of transaction <span class="math inline">\(\gamma\)</span> might obtain <span class="math inline">\(f+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses and attempt to commit the successful but not yet finalized transaction <span class="math inline">\(\gamma\)</span> via the slow path at some future point (this action is unstoppable).</li></ul><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/timeline-for-case-1.drawio.svg" alt="" /><figcaption>Timeline for Case 1</figcaption></figure><ul><li>At time <span class="math inline">\(t_1\)</span>, the client of transaction <span class="math inline">\(\gamma\)</span> receives <span class="math inline">\(\lfloor\frac{3f}{2}\rfloor\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses from replicas in Part A and Part B.</li><li>At time <span class="math inline">\(t_5\)</span>, the <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> for transaction <span class="math inline">\(\tau\)</span> is successful, with <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> replicas of Part C providing <span class="math inline">\(\text{PREPARE-OK}\)</span> responses for transaction <span class="math inline">\(\tau\)</span>, and <span class="math inline">\(\lfloor\frac{f}{2}\rfloor\)</span> replicas of Part B providing <span class="math inline">\(\text{ABORT}\)</span> responses for transaction <span class="math inline">\(\tau\)</span>. The new coordinator must refrain from committing transaction <span class="math inline">\(\tau\)</span> at this point to avoid system inconsistency at <span class="math inline">\(t_9\)</span>.</li><li>At time <span class="math inline">\(t_8\)</span>, the client of transaction <span class="math inline">\(\gamma\)</span> initiates the slow path, writing the commit outcome of transaction <span class="math inline">\(\gamma\)</span> to a backup coordinator group.</li><li>At time <span class="math inline">\(t_9\)</span>, the client of transaction <span class="math inline">\(\gamma\)</span> completes the slow path, with the commit outcome of transaction <span class="math inline">\(\gamma\)</span> now recorded by the backup coordinator group.</li></ul><p>Consider the following, Case 2:</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/case-2-committed-transaction-tau.drawio.svg" alt="" /><figcaption>Case 2: Committed Transaction <span class="math inline">\(\tau\)</span></figcaption></figure><ul><li>In Part D, a group of <span class="math inline">\(\lfloor\frac{f}{2}\rfloor\)</span> replicas is considered. Each replica in this group first receives an <span class="math inline">\(\operatorname{Prepare}(\gamma, t_\gamma)\)</span> operation, and subsequently receives an <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> operation. Given that transactions <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\tau\)</span> are in conflict, and the replicas have already responded to <span class="math inline">\(\operatorname{Prepare}(\gamma, t_\gamma)\)</span> with <span class="math inline">\(\text{PREPARE-OK}\)</span>, they are compelled to respond to <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> with <span class="math inline">\(\text{ABORT}\)</span>.</li><li>In the combined context of Part E and Part F, we consider a collective group of <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> replicas. Each replica in this group have not received any operations about transaction <span class="math inline">\(\gamma\)</span>. Consequently, they respond to the <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> operation with <span class="math inline">\(\text{PREPARE-OK}\)</span>.<ul><li>In Part E, there are <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> replicas. These replicas inform the new coordinator of their previous <span class="math inline">\(\text{PREPARE-OK}\)</span> response for the <span class="math inline">\(\operatorname{Prepare}(\tau, t_\tau)\)</span> operation associated with transaction <span class="math inline">\(\tau\)</span>.</li><li>In Part F, there are <span class="math inline">\(f\)</span> replicas. These replicas do not respond to the <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> message from the new coordinator.</li></ul></li><li>After successfully receiving <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> responses from a combined total of <span class="math inline">\(f+1\)</span> replicas, encompassing both Part D and Part E (thereby the <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> is successful), the new coordinator is unable to abort the transaction <span class="math inline">\(\tau\)</span>. Aborting the transaction <span class="math inline">\(\tau\)</span> at this stage could lead to inconsistencies, as there is a possibility that the client of transaction <span class="math inline">\(\tau\)</span> has already committed <span class="math inline">\(\tau\)</span> on some replicas prior to this coordinator recovery.</li></ul><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/timeline-for-case-2.drawio.svg" alt="" /><figcaption>Timeline for Case 2</figcaption></figure><ul><li>At time <span class="math inline">\(t_1^\prime\)</span>, the client of transaction <span class="math inline">\(\tau\)</span> receives <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses from replicas in Part E and Part F.</li><li>At time <span class="math inline">\(t_2^\prime\)</span>, some replicas within Part F receive the <span class="math inline">\(\operatorname{Commit}(t_\tau, \tau)\)</span> message from the client of transaction <span class="math inline">\(\tau\)</span>.</li><li>At time <span class="math inline">\(t_3^\prime\)</span>, the client of transaction <span class="math inline">\(\tau\)</span> fails.</li><li>At time <span class="math inline">\(t_4^\prime\)</span>, the new coordinator initiates coordinator recovery.</li><li>At time <span class="math inline">\(t_5^\prime\)</span>, the <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> for transaction <span class="math inline">\(\tau\)</span> is successful, with <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> replicas of Part C providing <span class="math inline">\(\text{PREPARE-OK}\)</span> responses for transaction <span class="math inline">\(\tau\)</span>, and <span class="math inline">\(\lfloor\frac{f}{2}\rfloor\)</span> replicas of Part B providing <span class="math inline">\(\text{ABORT}\)</span> responses for transaction <span class="math inline">\(\tau\)</span>. The new coordinator must refrain from aborting transaction <span class="math inline">\(\tau\)</span> at this point to avoid system inconsistency.</li></ul><p>At times <span class="math inline">\(t_5\)</span> and <span class="math inline">\(t_5^\prime\)</span>, the new coordinator observes the same set of responses, confirming a successful <span class="math inline">\(\operatorname{CoordinatorChange}\)</span> with a total of <span class="math inline">\(f+1\)</span> replicas responding: <span class="math inline">\(\lfloor\frac{f}{2}\rfloor\)</span> replicas send <span class="math inline">\(\text{ABORT}\)</span> responses, and <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> replicas send <span class="math inline">\(\text{PREPARE-OK}\)</span> responses. In Case 1, the coordinator cannot commit transaction <span class="math inline">\(\tau\)</span>; in Case 2, it cannot abort transaction <span class="math inline">\(\tau\)</span>. It is stuck in a dilemma.</p><p>The only way to resolve this dilemma is to wait for all conflicting transactions to be conclusively committed or aborted. In the above two cases described, if the new coordinator of transaction <span class="math inline">\(\tau\)</span> has already received <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses for a <span class="math inline">\(\operatorname{CoordinatorChange}\)</span>, then a conflicting transaction <span class="math inline">\(\gamma\)</span> cannot be finalized through the fast path. This is because the client of transaction <span class="math inline">\(\gamma\)</span> will not be able to receive <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses for the corresponding <span class="math inline">\(\operatorname{Prepare}\)</span> operation. As a result, transaction <span class="math inline">\(\gamma\)</span> is required to proceed through the slow path. More generally, any conflicting transactions are compelled to take the slow path. This is the rationale behind the author's statement:</p><blockquote><p>However, every conflicting transaction must have used the slow path. The new coordinator polls the coordinator (or backup coordinators) of each of these transactions until they have completed.</p></blockquote><h4 id="a-sketch-of-the-proof-for-tapirs-correctness">A Sketch of the Proof for TAPIR's Correctness</h4><p>Databases are traditionally expected to maintain four key properties, collectively known as ACID. Atomicity, isolation, and durability are intrinsic guarantees provided by the database system, while consistency is typically ensured by the application logic implemented by the user:</p><ul><li>Atomicity: If a transaction commits at any participating shard, it commits at them all. This is usually secured by the two-phase commit (2PC) mechanism; in cases of client or coordinator failures, the coordinator recovery protocol ensures that a backup coordinator will reach the same decision. Essentially, the integrity of atomicity is maintained by 2PC along with a strict adherence to making no more than one decision per transaction.</li><li>Isolation: There exists a global linearizable ordering of committed transactions. I speculate that the CLOCC protocol ensures that if any two committed transactions in a history do not conflict and adhere to timestamp ordering, then the history is serializable. TAPIR supports this assumption by guaranteeing that any transactions that could potentially conflict intersect at a sufficient number of replicas, a condition that remains valid even after replica or coordinator failovers. Subsequently, any two conflicting transactions are detected by a sufficient number of replicas, which leads to the abortion of at least one of the transactions. Consequently, when any two transactions do not conflict and adhere to timestamp ordering, the result is that the entire history is serializable.</li><li>Duration: Committed transactions stay committed, maintaining the original linearizable order. Duration is principally preserved through the IR protocol, which we will delve into in subsequent discussions.</li></ul><p>The following excerpt from <a href="https://clcanny.github.io/2023/03/06/computer-science/serializability/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/">Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed</a> explains the core principles of the CLOCC protocol in ensuring isolation:</p><blockquote><p>The start-depends conflict from Snapshot Isolation can help in understanding Read Object Set (ROS) and Modified Object Set (MOS) tests more effectively. This is particularly useful when utilizing the Start-ordered Serialization Graph. If the timestamp of transaction <span class="math inline">\(T_i\)</span> is less than the timestamp of transaction <span class="math inline">\(T_j\)</span> (<span class="math inline">\(\operatorname{ts}(T_i) &lt; \operatorname{ts}(T_j)\)</span>), then we draw a Start-Depends edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span>, denoted as <span class="math inline">\(T_i \stackrel{s}{\longrightarrow} T_j\)</span>.</p><p>Suppose transaction <span class="math inline">\(T\)</span> reaches the server for validation such that <span class="math inline">\(\operatorname{ts}(S_i) &lt; \operatorname{ts}(T) &lt; \operatorname{ts}(S_j)\)</span>. Notice that every transaction in the transaction history must be validated against <span class="math inline">\(T\)</span>, not only adjacent transactions.</p><ul><li>To simplify our algorithm, we arrange the read set to always contain the write set (no blind writes), i.e., if a transaction modifies an object but does not read it, the client enters the object in the read set anyway. As a result, we don't need to consider Direct Write-Depends, since accounting for Direct Read-Depends achieves the same effect when determining whether any cycles exist in the SSG. Thus, we need not consider the following four conflicts:<ul><li><span class="math inline">\(S_i \stackrel{ww}{\longrightarrow} T\)</span></li><li><span class="math inline">\(T \stackrel{ww}{\longrightarrow} S_i\)</span></li><li><span class="math inline">\(T \stackrel{ww}{\longrightarrow} S_j\)</span></li><li><span class="math inline">\(S_j \stackrel{ww}{\longrightarrow} T\)</span></li></ul></li><li>The following three conflicts are valid because they have the same directions as the start-dependence conflicts in the SSG.<ul><li><span class="math inline">\(S_i \stackrel{wr}{\longrightarrow} T\)</span><ul><li>However, if transaction <span class="math inline">\(S_i\)</span> is prepared but not yet committed, transaction <span class="math inline">\(T\)</span> should not read versions of objects written by <span class="math inline">\(S_i\)</span>. If <span class="math inline">\(T\)</span> reads versions of objects written by <span class="math inline">\(S_i\)</span> before <span class="math inline">\(S_i\)</span> commits, it would constitute a dirty read if the coordinator ultimately aborts <span class="math inline">\(S_i\)</span>.</li></ul></li><li><span class="math inline">\(S_i \stackrel{rw}{\longrightarrow} T\)</span></li><li><span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_j\)</span></li></ul></li><li>Since <span class="math inline">\(S_i\)</span> is prepared/committed, it could not have observed <span class="math inline">\(T\)</span>'s updates (there are no dirty reads in CLOCC). In simpler terms, <span class="math inline">\(T \stackrel{wr}{\longrightarrow} S_i\)</span> is not possible. Similarly, <span class="math inline">\(T \stackrel{wr}{\longrightarrow} S_j\)</span> is not possible.</li><li>(1) <strong>ROS test.</strong> This test validates the objects that have been read by <span class="math inline">\(T\)</span>. Let <span class="math inline">\(S_k\)</span> be the transaction from which <span class="math inline">\(T\)</span> has read <span class="math inline">\(x\)</span>, i.e., <span class="math inline">\(\operatorname{ts}(S_k)\)</span> is equal to the value of <span class="math inline">\(\text{install_ts}\)</span> in <span class="math inline">\(x\)</span>'s ROS tuple.<ul><li>(1a) If <span class="math inline">\(\operatorname{ts}(S_k) &lt; \operatorname{ts}(S_i)\)</span>, then the transaction manager (TM) verifies that <span class="math inline">\(S_i\)</span> has not modified <span class="math inline">\(x\)</span>. This rule disables <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span>.</li><li>(1b) Furthermore, the TM also verifies that <span class="math inline">\(\operatorname{ts}(T)\)</span> is greater than <span class="math inline">\(\operatorname{ts}(S_k)\)</span>. This rule disables <span class="math inline">\(S_j \stackrel{wr}{\longrightarrow} T\)</span>.</li></ul></li><li>(2) <strong>MOS test</strong>. The TM validates <span class="math inline">\(\operatorname{MOS}(T)\)</span> by verifying that <span class="math inline">\(T\)</span> has not modified any object <span class="math inline">\(y\)</span> that has been read by <span class="math inline">\(S_j\)</span>. This rule disables <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span>.</li></ul></blockquote><h3 id="qa-on-ir-fundamentals">Q&amp;A on IR Fundamentals</h3><h4 id="finalized-vs.-successful-but-not-finalized-operations-understanding-the-distinction">Finalized vs. Successful But Not Finalized Operations: Understanding the Distinction</h4><p>The fundamental differences between finalized and successful but not finalized operations hinge on their respective behaviors in response to replica failures and recoveries. The first distinction addresses the robustness following failures, while the second focuses on the ability to maintain success after a failure has occurred and a subsequent recovery takes place.</p><p>The first distinction is that finalized operations can withstand up to <span class="math inline">\(f\)</span> failures out of <span class="math inline">\(2f+1\)</span> total replicas — the maximum failure count that still allows the corresponding partition to process client requests. In such a worst-case scenario, there will be at least <span class="math inline">\((\lceil\frac{3f}{2}\rceil+1) - f = \lceil\frac{f}{2}\rceil+1\)</span> functioning replicas out of the <span class="math inline">\(f+1\)</span> survivors that have acknowledged the operation with a <span class="math inline">\(\text{PREPARE-OK}\)</span> response. This represents a majority of the remaining active replicas, ensuring the operation's success despite the failures.</p><p>Conversely, successful but not finalized operations are less resilient. With <span class="math inline">\(f\)</span> replica failures, it's possible that only <span class="math inline">\((f+1) - f = 1\)</span> replica is aware it returned a <span class="math inline">\(\text{PREPARE-OK}\)</span> response. This lone replica does not constitute a majority of the living replicas, which means the operation may no longer be considered successful in the face of these failures.</p><p>The second distinction is that finalized operations remain successful through replica failures and subsequent <strong>recoveries</strong>, whereas successful but not finalized operations do not. The specifics of the IR recovery protocol, which guarantees that a failed replica can recover any operation that it may have executed previously and maintain success, will be addressed in the upcoming Q&amp;A section.</p><h4 id="the-single-operation-ir-spec">The Single-Operation IR Spec</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><code class="hljs tla">--------------------------------- MODULE IR ---------------------------------<br>(***************************************************************************)<br>(* This is a TLA+ specification of the Inconsistent Replication algorithm. *)<br>(***************************************************************************)<br><br>EXTENDS FiniteSets, Naturals, TLC<br><br>-----------------------------------------------------------------------------<br>(***************************************************************************)<br>(* `^ \center \large&#123;\textbf&#123;Constants&#125;&#125; ^&#x27;                                *)<br>(***************************************************************************)<br><br>(***************************************************************************)<br>(*  Constant parameters:                                                   *)<br>(*        MaxViewNum: max view number                                      *)<br>(*        Replica: the set of all replicas (Replica IDs)                   *)<br>(*        Quorum: the set of all quorums                                   *)<br>(*        SuperQuorum: the set of all super quorums                        *)<br>(*        F: maximum number of failures allowed (half of n)                *)<br>(***************************************************************************)<br><br>CONSTANTS UNWRITTEN, SUCCEED, FAILED,<br>          NORMAL, RFAILED, VIEWCHANGING,<br>          STARTVIEWCHANGE, DOVIEWCHANGE, STARTVIEW, STARTVIEWREPLY,<br>          Replica, Quorum, SuperQuorum, MaxViewNum, F<br><br>SYMM ==<br>         Permutations(&#123;SUCCEED, FAILED&#125;)<br>  \union Permutations(Replica)<br><br>ViewNum == 0..MaxViewNum<br>ASSUME IsFiniteSet(ViewNum)<br>ASSUME IsFiniteSet(Replica)<br>ASSUME \A Q \in Quorum: Q \subseteq Replica<br>ASSUME \A Q \in SuperQuorum: Q \subseteq Replica<br>ASSUME \A Q \in Quorum: \A S1, S2 \in SuperQuorum: Q \cap S1 \cap S2 # &#123;&#125;<br><br>(***************************************************************************)<br>(* The possible states of a replica and the two types of operations        *)<br>(* currently defined by IR.                                                *)<br>(***************************************************************************)<br><br>Val == &#123;UNWRITTEN, SUCCEED, FAILED&#125;<br>ReplicaState == &#123;NORMAL, RFAILED, VIEWCHANGING&#125;<br><br>(***************************************************************************)<br>(* Message is defined to be the set of all possible messages               *)<br>(***************************************************************************)<br><br>Message ==<br>       [type: &#123;STARTVIEWCHANGE&#125;,<br>        vn: ViewNum,<br>        src: Replica]<br>  \cup<br>       [type: &#123;DOVIEWCHANGE&#125;,<br>        val: Val,<br>        vn: ViewNum,<br>        src: Replica,<br>        dst: Replica]<br>  \cup<br>       [type: &#123;STARTVIEW&#125;,<br>        vn: ViewNum,<br>        src: Replica]<br>  \cup<br>       [type: &#123;STARTVIEWREPLY&#125;,<br>        vn: ViewNum,<br>        src: Replica,<br>        dst: Replica]<br><br>-----------------------------------------------------------------------------<br>(***************************************************************************)<br>(* `^ \center \large&#123;\textbf&#123;Variables and State Predicates&#125;&#125; ^&#x27;           *)<br>(***************************************************************************)<br><br>(***************************************************************************)<br>(* Variables:                                                              *)<br>(*        1. State at each replica:                                        *)<br>(*            rState = Denotes current replica state. Either:              *)<br>(*                       - NORMAL (processing operations)                  *)<br>(*                       - VIEW-CHANGING (participating in recovery)       *)<br>(*            rVal = Operation result                                      *)<br>(*            rViewNum = current view number                               *)<br>(*        2. State of communication medium:                                *)<br>(*            sentMsg = sent (but not yet received) messages               *)<br>(*                                                                         *)<br>(***************************************************************************)<br><br>VARIABLES rState, rVal, rViewNum, sentMsg, aFinalized<br><br>(***************************************************************************)<br>(* Defining these tuples makes it easier to express which varibles remain  *)<br>(* unchanged.                                                              *)<br>(***************************************************************************)<br><br>rVars == &lt;&lt;rState, rVal, rViewNum&gt;&gt; \* Replica variables.<br>aVars == &lt;&lt;aFinalized&gt;&gt;             \* Application variables<br>oVars == &lt;&lt;sentMsg&gt;&gt;                \* Other variables.<br>vars == &lt;&lt;rVars, aVars, oVars&gt;&gt;     \* All variables.<br><br>TypeOK ==<br>  /\ rState \in [Replica -&gt; ReplicaState]<br>  /\ rVal \in [Replica -&gt; Val]<br>  /\ rViewNum \in [Replica -&gt; ViewNum]<br>  \* /\ sentMsg \in SUBSET Message<br>  \* /\ aFinalized \subseteq Val<br><br>Init ==<br>  /\ rState = [r \in Replica |-&gt; NORMAL]<br>  /\ rVal = [r \in Replica |-&gt; UNWRITTEN]<br>  /\ rViewNum = [r \in Replica |-&gt; 0]<br>  /\ sentMsg = &#123;&#125;<br>  /\ aFinalized = &#123;&#125;<br><br>-----------------------------------------------------------------------------<br>(***************************************************************************)<br>(* `^ \center \large&#123;\textbf&#123;Actions&#125;&#125; ^&#x27;                                  *)<br>(***************************************************************************)<br><br>Send(m) == sentMsg&#x27; = sentMsg \cup &#123;m&#125;<br><br>-----------------------------------------------------------------------------<br>(***************************************************************************)<br>(* `^ \center \large&#123;\textbf&#123;Replica Actions&#125;&#125; ^&#x27;                          *)<br>(***************************************************************************)<br><br>\* Replica executes the operation.<br>ReplicaExecute(r, val) ==<br>  /\ rState[r] = NORMAL<br>  /\ rVal[r] = UNWRITTEN<br>  /\ rVal&#x27; = [rVal EXCEPT ![r] = val]<br>  /\ UNCHANGED &lt;&lt;rState, rViewNum, aVars, oVars&gt;&gt;<br><br>\* A replica fails and looses everything.<br>ReplicaFail(r) ==<br>  \* We assume less than F replicas are allowed to fail.<br>  /\ Cardinality(&#123;re \in Replica: rState[re] = RFAILED&#125; \cup &#123;r&#125;) &lt;= F<br>  /\ rState&#x27; = [rState EXCEPT ![r] = RFAILED]<br>  /\ rVal&#x27; = [rVal EXCEPT ![r] = UNWRITTEN]<br>  \* If rViewNum[r] is reset, TLC will report a counterexample.<br>  \* /\ rViewNum&#x27; = [rViewNum EXCEPT ![r] = 0]<br>  /\ UNCHANGED &lt;&lt;rViewNum, aVars, oVars&gt;&gt;<br><br>AppFinalizedVal(val) ==<br>  \* A super-quorum of replicas with matching view numbers and results.<br>  \* https://lamport.azurewebsites.net/video/video5-script.pdf<br>  \* The scope of \A and \E extends as far as possible.<br>  \* The expression ... extends to the end of its enclosing expression<br>  \* unless explicitly ended<br>  \*   - by parentheses<br>  \*   - or by the end of a list item<br>  \* https://lamport.azurewebsites.net/pubs/spec-book-chap.pdf<br>  \* A list bulleted by /\ or \/ represents the conjunction or disjunction<br>  \* of the items. Indentation is used to eliminate parentheses in<br>  \* nested lists of conjunctions and/or disjunctions.<br>  /\ \E Q \in SuperQuorum, vn \in ViewNum:<br>    /\ \A r \in Q:<br>      /\ rState[r] = NORMAL<br>      /\ rVal[r] = val<br>      /\ rViewNum[r] = vn<br>  /\ aFinalized&#x27; = aFinalized \cup &#123;val&#125;<br>  /\ UNCHANGED &lt;&lt;rVars, oVars&gt;&gt;<br><br>\* A replica starts the view change procedure<br>\* supports concurrent view changes (id by src).<br>ReplicaStartViewChange(r) ==<br>  /\ rState[r] = RFAILED<br>  /\ Send([type |-&gt; STARTVIEWCHANGE, vn |-&gt; rViewNum[r], src |-&gt; r])<br>  /\ UNCHANGED &lt;&lt;rVars, aVars&gt;&gt;<br><br>\* A replica received a message to start view change.<br>ReplicaReceiveStartViewChange(r) ==<br>  /\ rState[r] # RFAILED<br>  /\ \E m \in &#123;m \in sentMsg: m.type = STARTVIEWCHANGE&#125;:<br>       LET vn == (IF m.vn &gt; rViewNum[r] THEN m.vn ELSE rViewNum[r]) + 1<br>       IN<br>         /\ vn \in ViewNum<br>         /\ rState&#x27; = [rState EXCEPT ![r] = VIEWCHANGING]<br>         /\ rViewNum&#x27; = [rViewNum EXCEPT ![r] = vn]<br>         /\ Send([type |-&gt; DOVIEWCHANGE,<br>                  vn   |-&gt; vn,<br>                  val  |-&gt; rVal[r],<br>                  src  |-&gt; r,<br>                  dst  |-&gt; m.src])<br>         /\ UNCHANGED &lt;&lt;rVal, aVars&gt;&gt;<br><br>\* A replica received enough view change replies<br>\* to start processing in the new view.<br>ReplicaReceiveDoViewChange(r) ==<br>  /\ rState[r] = RFAILED<br>  /\ \E Q \in Quorum:<br>       LET receivedMsg == &#123;m \in sentMsg:<br>                             /\ m.type = DOVIEWCHANGE<br>                             /\ m.vn &gt; rViewNum[r]<br>                             /\ m.src \in Q<br>                             /\ m.dst = r&#125;<br>           vn == IF Cardinality(receivedMsg) = 0 THEN 0<br>                 ELSE CHOOSE x \in &#123;m.vn: m \in receivedMsg&#125;:<br>                        \A y \in &#123;m.vn: m \in receivedMsg&#125;:<br>                          x &gt;= y<br>           IsMatchingMajorityVal(val) ==<br>             \E P \in SuperQuorum:<br>               \A s \in Q \cap P:<br>                 \E m \in receivedMsg:<br>                   /\ m.val = val<br>                   /\ m.src = s<br>           IsNotMatchingMajorityVal(val) == \neg IsMatchingMajorityVal(val)<br>           CanRecover(val) ==<br>             \/ IsMatchingMajorityVal(val)<br>             \/ IsNotMatchingMajorityVal(<br>                  CHOOSE v \in Val: v \notin &#123;val, UNWRITTEN&#125;)<br>       IN<br>         /\ &#123;m.src: m \in receivedMsg&#125; = Q<br>         /\ \/ /\ CanRecover(SUCCEED)<br>               /\ rVal&#x27; = [rVal EXCEPT ![r] = SUCCEED]<br>            \/ /\ CanRecover(FAILED)<br>               /\ rVal&#x27; = [rVal EXCEPT ![r] = FAILED]<br>         /\ rViewNum&#x27; = [rViewNum EXCEPT ![r] = vn]<br>         /\ Send([type |-&gt; STARTVIEW, vn |-&gt; vn, src |-&gt; r])<br>         /\ UNCHANGED &lt;&lt;rState, aVars&gt;&gt;<br><br>\*A replica receives a start view message.<br>ReplicaReceiveStartView(r) ==<br>  /\ rState[r] # RFAILED<br>  /\ \E msg \in sentMsg:<br>       /\ msg.type = STARTVIEW<br>       /\ msg.vn &gt;= rViewNum[r]<br>       \* Don&#x27;t reply to myself.<br>       /\ msg.src # r<br>       /\ rState&#x27; = [rState EXCEPT ![r] = NORMAL]<br>       /\ rViewNum&#x27; = [rViewNum EXCEPT ![r] = msg.vn]<br>       /\ Send([type |-&gt; STARTVIEWREPLY,<br>                vn   |-&gt; msg.vn,<br>                src  |-&gt; r,<br>                dst  |-&gt; msg.src])<br>       /\ UNCHANGED &lt;&lt;rVal, aVars&gt;&gt;<br><br>ReplicaReceiveStartViewReply(r) ==<br>  /\ rState[r] = RFAILED<br>  /\ rVal[r] # UNWRITTEN<br>  /\ \E Q \in Quorum:<br>       /\ r \in Q<br>       /\ \A p \in Q \ &#123;r&#125;:<br>            \E msg \in sentMsg:<br>              /\ msg.type = STARTVIEWREPLY<br>              \* This differs from the author&#x27;s original specification.<br>              /\ msg.vn = rViewNum[r]<br>              /\ msg.src = p<br>              /\ msg.dst = r<br>  /\ rState&#x27; = [rState EXCEPT ![r] = NORMAL]<br>  /\ UNCHANGED &lt;&lt;rVal, rViewNum, aVars, oVars&gt;&gt;<br><br>-----------------------------------------------------------------------------<br>(***************************************************************************)<br>(* `^ \center \large&#123;\textbf&#123;High-Level Actions&#125;&#125; ^&#x27;                       *)<br>(***************************************************************************)<br><br>Next ==<br>  \/ \E r \in Replica:<br>       \/ ReplicaExecute(r, SUCCEED)<br>       \/ ReplicaExecute(r, FAILED)<br>       \/ ReplicaFail(r)<br>       \/ ReplicaStartViewChange(r)<br>       \/ ReplicaReceiveStartViewChange(r)<br>       \/ ReplicaReceiveDoViewChange(r)<br>       \/ ReplicaReceiveStartView(r)<br>       \/ ReplicaReceiveStartViewReply(r)<br>  \/ \/ AppFinalizedVal(SUCCEED)<br>     \/ AppFinalizedVal(FAILED)<br><br>Spec ==<br>  TypeOK /\ Init /\ [] [Next]_vars<br><br>FaultTolerance ==<br>  /\ Cardinality(aFinalized) &lt;= 1<br>  /\ \A finalizedVal \in aFinalized, Q \in Quorum:<br>         (\A r \in Q: rState[r] = NORMAL \/ rState[r] = VIEWCHANGING)<br>      =&gt; (\E P \in SuperQuorum:<br>            \A p \in Q \cap P:<br>              rVal[p] = finalizedVal)<br><br>Inv ==<br>  /\ TypeOK<br>  /\ FaultTolerance<br><br>THEOREM Spec =&gt; []Inv<br><br>=============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cfg">CONSTANT<br>UNWRITTEN = UNWRITTEN<br>SUCCEED = SUCCEED<br>FAILED = FAILED<br>NORMAL = NORMAL<br>RFAILED = RFAILED<br>VIEWCHANGING = VIEWCHANGING<br>STARTVIEWCHANGE = STARTVIEWCHANGE<br>DOVIEWCHANGE = DOVIEWCHANGE<br>STARTVIEW = STARTVIEW<br>STARTVIEWREPLY = STARTVIEWREPLY<br>Replica = &#123;r1, r2, r3, r4, r5&#125;<br>Quorum = &#123;&#123;r1, r2, r3&#125;, &#123;r1, r2, r4&#125;, &#123;r1, r2, r5&#125;, &#123;r1, r3, r4&#125;, &#123;r1, r3, r5&#125;, &#123;r1, r4, r5&#125;, &#123;r2, r3, r4&#125;, &#123;r2, r3, r5&#125;, &#123;r2, r4, r5&#125;, &#123;r3, r4, r5&#125;&#125;<br>SuperQuorum = &#123;&#123;r2, r3, r4, r5&#125;, &#123;r1, r3, r4, r5&#125;, &#123;r1, r2, r4, r5&#125;, &#123;r1, r2, r3, r5&#125;, &#123;r1, r2, r3, r4&#125;&#125;<br>MaxViewNum = 2<br>F = 2<br><br>SYMMETRY<br>SYMM<br><br>SPECIFICATION<br>Spec<br><br>INVARIANT<br>Inv<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xms50g -XX:+UseParallelGC -XX:MaxDirectMemorySize=300g -Dtlc2.tool.fp.FPSet.impl=tlc2.tool.fp.OffHeapDiskFPSet -<span class="hljs-built_in">cp</span> /usr/local/lib/tla2tools.jar tlc2.TLC IR -workers auto -checkpoint 0 &gt;stdout 2&gt;stderr<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">Model checking completed. No error has been found.<br>  Estimates of the probability that TLC did not check all reachable states<br>  because two distinct states had the same fingerprint:<br>  calculated (optimistic):  val = .0033<br>  based on the actual fingerprints:  val = 2.5E-4<br>765862621 states generated, 88535063 distinct states found, 0 states left on queue.<br>The depth of the complete state graph search is 37.<br>The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 14 and the 95th percentile is 3).<br>Finished in 02h 40min at (2024-01-02 14:20:54)<br></code></pre></td></tr></table></figure><h4 id="ensuring-the-success-of-finalized-operations-post-recovery-with-the-ir-protocol">Ensuring the Success of Finalized Operations Post-Recovery with the IR Protocol</h4><blockquote><p>IR's recovery protocol is carefully designed to ensure that a failed replica recovers any operation that it may have executed previously and can still succeed. Without this property, successful IR operations could be lost. For example, suppose an IR client receives a quorum of responses and reports success to the application. Then, each replica in the quorum fails in sequence and each lose the operation, leading to the previously successful operation being lost by the group.</p></blockquote><p>In <a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a>, Heidi Howard and Richard Mortier propose a generalised solution to consensus that uses only immutable state to enable more intuitive reasoning about correctness, encompassing both Paxos and Fast Paxos as specific instances. In this section, I intend to demonstrate that the IR protocol aligns with this generalized consensus framework, thereby affirming its correctness. I will specifically address the agreement requirement of consensus, which mandates all clients that output a value must output the same value. Given that in IR every operation can only yield a binary outcome - SUCCEED or FAILED, non-triviality is inherently satisfied when clients input these values. However, I will also discuss the protocol's limitations with respect to the progress requirement, acknowledging the potential for IR to be indecisive under certain conditions.</p><p>Below is a table designed to align the terminology between the two papers for clarity:</p><table><thead><tr class="header"><th style="text-align: left;">A Generalised Solution to Distributed Consensus</th><th style="text-align: left;">Building Consistent Transactions with Inconsistent Replication</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">server</td><td style="text-align: left;">replica</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">quorum</td></tr><tr class="odd"><td style="text-align: left;">quorum</td><td style="text-align: left;">super-quorum</td></tr><tr class="even"><td style="text-align: left;">register</td><td style="text-align: left;"></td></tr><tr class="odd"><td style="text-align: left;">register set</td><td style="text-align: left;">view</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(v\)</span> is decided.</td><td style="text-align: left;"><span class="math inline">\(v\)</span> is finalized.</td></tr></tbody></table><p>An important distinction exists between the concepts of quorums in "A Generalized Solution to Distributed Consensus" (GSDC) and "Building Consistent Transactions with Inconsistent Replication" (IR) that may lead to confusion. To clarify: what GSDC refers to as a quorum is analogous to a super-quorum in IR. In IR, a value <span class="math inline">\(v\)</span> is considered finalized when it is written to all registers within the same view of a super-quorum <span class="math inline">\(S\)</span>. Conversely, in the context of IR, a regular quorum <span class="math inline">\(Q\)</span> is utilized for recovery purposes, and writing value <span class="math inline">\(v\)</span> to all registers in the same view of <span class="math inline">\(Q\)</span> <strong>does not</strong> imply the value is finalized.</p><p>The following three rules ensure the fulfillment of the agreement requirement:</p><ul><li>Rule 1: <strong>Super-quorum agreement</strong>. A client may only output a (non-nil) value <span class="math inline">\(v\)</span> if it has read <span class="math inline">\(v\)</span> from a super-quorum of replicas in the same view, where a super-quorum consists of <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> replicas.</li><li>Rule 3: <strong>Current decision</strong>. A client may only write a (non-nil) value <span class="math inline">\(v\)</span> to register <span class="math inline">\(reg\)</span> on replica <span class="math inline">\(r\)</span> provided that if <span class="math inline">\(v\)</span> is finalized in view <span class="math inline">\(vw\)</span> by a super-quorum <span class="math inline">\(S \in \mathcal{S}_{vw}\)</span> where <span class="math inline">\(r \in S\)</span> then no value <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v \neq v^\prime\)</span> can also be finalized in view <span class="math inline">\(vw\)</span>. Given that super-quorums intersect, it is guaranteed within a single view, only one value can be finalized.</li><li>Rule 4: <strong>Previous decisions</strong>. A client may only write a (non-nil) value <span class="math inline">\(v\)</span> to register <span class="math inline">\(reg\)</span> provided no value <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v \neq v^\prime\)</span> can be finalized by the super-quorums in views <span class="math inline">\(0\)</span> to <span class="math inline">\(r − 1\)</span>. This rule poses challenges to implement; it will be further explained in the following paragraph.</li></ul><p>In addition to the three rules from GSDC, IR includes three specific rules:</p><ul><li>Rule 5: <strong>Value preservation</strong>. If a replica <span class="math inline">\(r\)</span> has voted for a value <span class="math inline">\(v\)</span> in view <span class="math inline">\(vw\)</span>, and there are no failures, then replica <span class="math inline">\(r\)</span> should only vote for <span class="math inline">\(v\)</span> in any subsequent view <span class="math inline">\({vw}&#39;\)</span> where <span class="math inline">\({vw}&#39; &gt; vw\)</span>.</li><li>Rule 6: <strong>Recovering only myself</strong>. During recovery, a failover replica <span class="math inline">\(r\)</span> is restricted to writing solely to its own register, avoiding writes to registers of other replicas. This approach significantly deviates from that of Paxos.</li><li>Rule 7: <strong>View number preservation</strong>. If a failure occurs, the view number <span class="math inline">\(vw\)</span> is preserved and remains usable after failover, while all other states are lost.</li></ul><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-building-consistent-transactions-with-inconsistent-replication/sample-state-tables-for-a-system-with-two-replicas-across-three-views-demonstrating-rule-5.svg" alt="" /><figcaption>Sample state tables for a system with two replicas across three views demonstrating rule 5</figcaption></figure><h5 id="modifing-the-ir-recovery-protocol-for-easier-correctness-proveness">Modifing the IR Recovery Protocol for Easier Correctness Proveness</h5><p>To enhance the original IR Recovery Protocol in alignment with Rule 4: Previous decisions, the following modifications are proposed:</p><ol start="3" type="1"><li>... <del>It then adds the operation to its record.</del> The operation will be recorded at a later stage, as outlined in step 6.</li><li>The replica then sends a <span class="math inline">\(\langle\text{START-VIEW}, val, {vn}_{new}\rangle\)</span>, where <span class="math inline">\(val\)</span> represents the value determined from steps 3.a or 3.b, <span class="math inline">\({vn}_{new}\)</span> is the max of the view numbers from other replicas.</li><li>Any replica that receives <span class="math inline">\(\text{START-VIEW}\)</span> checks whether it has not voted for any value other than <span class="math inline">\(val\)</span>. If this conditions is met, the replica updates its current view number to <span class="math inline">\(\operatorname{max}(vn, {vn}_{new})\)</span>, enters the <span class="math inline">\(\text{NORMAL}\)</span> state, and replies with a <span class="math inline">\(\langle\text{START-VIEW-REPLY}, {vn}_{new}\rangle\)</span> message. If not, the replica remains in its current state without sending any reply.</li><li>After the recovering replica receives <span class="math inline">\(\lfloor\frac{f}{2}\rfloor+1\)</span> <span class="math inline">\(\text{START-VIEW-REPLY}\)</span> responses, it adds <span class="math inline">\(val\)</span> to its record, enters the <span class="math inline">\(\text{NORMAL}\)</span> state and resumes processing client requests. At this point, the replica is considered to be recovered.</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs tla">\* A replica received enough view change replies<br>\* to start processing in the new view.<br>ReplicaReceiveDoViewChange(r, val) ==<br>  /\ rState[r] = RFAILED<br>  /\ \E Q \in Quorum:<br>       LET receivedMsg == &#123;m \in sentMsg:<br>                             /\ m.type = DOVIEWCHANGE<br>                             /\ m.vn &gt; rViewNum[r]<br>                             /\ m.src \in Q<br>                             /\ m.dst = r&#125;<br>           vn == IF Cardinality(receivedMsg) = 0 THEN 0<br>                 ELSE CHOOSE x \in &#123;m.vn: m \in receivedMsg&#125;:<br>                        \A y \in &#123;m.vn: m \in receivedMsg&#125;:<br>                          x &gt;= y<br>           IsMatchingMajorityVal(v) ==<br>             \E P \in SuperQuorum:<br>               \A s \in Q \cap P:<br>                 \E m \in receivedMsg:<br>                   /\ m.val = v<br>                   /\ m.src = s<br>           IsNotMatchingMajorityVal(v) == \neg IsMatchingMajorityVal(v)<br>           CanRecover(v) ==<br>             \/ IsMatchingMajorityVal(v)<br>             \/ IsNotMatchingMajorityVal(<br>                  CHOOSE x \in Val: x \notin &#123;val, UNWRITTEN&#125;)<br>       IN<br>         /\ &#123;m.src: m \in receivedMsg&#125; = Q<br>         /\ CanRecover(val)<br>         /\ rViewNum&#x27; = [rViewNum EXCEPT ![r] = vn]<br>         /\ Send([type |-&gt; STARTVIEW, val |-&gt; val, vn |-&gt; vn, src |-&gt; r])<br>         /\ UNCHANGED &lt;&lt;rState, rVal, aVars&gt;&gt;<br><br>\*A replica receives a start view message.<br>ReplicaReceiveStartView(r) ==<br>  /\ rState[r] # RFAILED<br>  /\ \E msg \in sentMsg:<br>       /\ msg.type = STARTVIEW<br>       /\ rVal[r] \in &#123;msg.val, UNWRITTEN&#125;<br>       \* /\ rViewNum[r] &lt;= msg.vn<br>       /\ rState&#x27; = [rState EXCEPT ![r] = NORMAL]<br>       /\ rViewNum&#x27; = [rViewNum EXCEPT ![r] = IF msg.vn &gt; @ THEN msg.vn ELSE @]<br>       /\ Send([type |-&gt; STARTVIEWREPLY,<br>                val  |-&gt; msg.val,<br>                vn   |-&gt; msg.vn,<br>                src  |-&gt; r,<br>                dst  |-&gt; msg.src])<br>       /\ UNCHANGED &lt;&lt;rVal, aVars&gt;&gt;<br><br>ReplicaReceiveStartViewReply(r, val) ==<br>  /\ rState[r] = RFAILED<br>  /\ rVal[r] # UNWRITTEN<br>  /\ \E Q \in Quorum, S \in SuperQuorum:<br>       \A p \in Q \cap S:<br>         \E msg \in sentMsg:<br>           /\ msg.type = STARTVIEWREPLY<br>           /\ msg.val = val<br>           /\ msg.vn = rViewNum[r]<br>           /\ msg.src = p<br>           /\ msg.dst = r<br>  /\ rState&#x27; = [rState EXCEPT ![r] = NORMAL]<br>  /\ rVal&#x27; = [rVal EXCEPT ![r] = val]<br>  /\ UNCHANGED &lt;&lt;rViewNum, aVars, oVars&gt;&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xms50g -XX:+UseParallelGC -XX:MaxDirectMemorySize=300g -Dtlc2.tool.fp.FPSet.impl=tlc2.tool.fp.OffHeapDiskFPSet -<span class="hljs-built_in">cp</span> /usr/local/lib/tla2tools.jar tlc2.TLC IR -workers auto -checkpoint 0 &gt;stdout 2&gt;stderr<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">Model checking completed. No error has been found.<br>  Estimates of the probability that TLC did not check all reachable states<br>  because two distinct states had the same fingerprint:<br>  calculated (optimistic):  val = 1.7E-5<br>  based on the actual fingerprints:  val = 2.4E-6<br>59799625 states generated, 5739708 distinct states found, 0 states left on queue.<br>The depth of the complete state graph search is 31.<br>The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 11 and the 95th percentile is 3).<br>Finished in 13min 52s at (2024-01-09 01:40:37)<br></code></pre></td></tr></table></figure><p>The correctness of the above-modified IR Recovery Protocol is straightforward to establish. Because at least <span class="math inline">\(\lfloor\frac{f}{2}\rfloor+1\)</span> replicas confirm that they have not written, and will not write (the view number is maintained and remains valid even post-failover), votes for any value other than <span class="math inline">\(val\)</span>. This assurance means that no values other than <span class="math inline">\(val\)</span> could have been or will be finalized by a quorum of <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> in any prior view. Thus, it is safe for the recovering replica to write <span class="math inline">\(val\)</span> in <span class="math inline">\({vn}_{new}\)</span>, which is in full compliance with Rule 4: Previous Decisions.</p><h5 id="proving-the-correctness-of-the-original-ir-recovery-protocol-a-more-complex-task">Proving the Correctness of the Original IR Recovery Protocol: A More Complex Task</h5><p>I have made minor revisions to the original IR Recovery protocol, omitting extraneous steps that could potentially obfuscate the proof process. These modifications are subtle and retain the essence of the original protocol:</p><ol start="3" type="1"><li>Once the recovering replica receives <span class="math inline">\(f+1\)</span> responses, it updates its record using the received records: ... It updates its current view number to <span class="math inline">\({vn}_{new}\)</span> as the <strong>max</strong> view number received from other replicas, enters the <span class="math inline">\(\text{NORMAL}\)</span> state and resumes processing client requests. <strong>At this point, the replica is considered to be recovered.</strong></li><li>The replica then sends a <span class="math inline">\(\langle\text{START-VIEW}, val, {vn}_{new}\rangle\)</span>, where <span class="math inline">\({vn}_{new}\)</span> is the <strong>max</strong> of the view numbers from other replicas.</li><li>Any replica that receives <span class="math inline">\(\text{START-VIEW}\)</span> checks ... The replica then always replies with a <span class="math inline">\(\langle\text{START-VIEW}, val, {vn}_{new}\rangle\)</span> message.</li><li><del>After the recovering replica receives <span class="math inline">\(f\)</span> <span class="math inline">\(\text{START-VIEW-REPLY}\)</span> responses, it enters the <span class="math inline">\(\text{NORMAL}\)</span> state and resumes processing client requests. At this point, the replica is considered to be recovered.</del></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs tla">\* A replica received enough view change replies<br>\* to start processing in the new view.<br>ReplicaReceiveDoViewChange(r) ==<br>  /\ rState[r] = RFAILED<br>  /\ \E Q \in Quorum:<br>       LET receivedMsg == &#123;m \in sentMsg:<br>                             /\ m.type = DOVIEWCHANGE<br>                             /\ m.vn &gt; rViewNum[r]<br>                             /\ m.src \in Q<br>                             /\ m.dst = r&#125;<br>           vn == IF Cardinality(receivedMsg) = 0 THEN 0<br>                 ELSE CHOOSE x \in &#123;m.vn: m \in receivedMsg&#125;:<br>                        \A y \in &#123;m.vn: m \in receivedMsg&#125;:<br>                          x &gt;= y<br>           IsMatchingMajorityVal(val) ==<br>             \E P \in SuperQuorum:<br>               \A s \in Q \cap P:<br>                 \E m \in receivedMsg:<br>                   /\ m.val = val<br>                   /\ m.src = s<br>           IsNotMatchingMajorityVal(val) == \neg IsMatchingMajorityVal(val)<br>           CanRecover(val) ==<br>             \/ IsMatchingMajorityVal(val)<br>             \/ IsNotMatchingMajorityVal(<br>                  CHOOSE v \in Val: v \notin &#123;val, UNWRITTEN&#125;)<br>       IN<br>         /\ &#123;m.src: m \in receivedMsg&#125; = Q<br>         /\ rState&#x27; = [rState EXCEPT ![r] = NORMAL]<br>         /\ \/ /\ CanRecover(SUCCEED)<br>               /\ rVal&#x27; = [rVal EXCEPT ![r] = SUCCEED]<br>            \/ /\ CanRecover(FAILED)<br>               /\ rVal&#x27; = [rVal EXCEPT ![r] = FAILED]<br>         /\ rViewNum&#x27; = [rViewNum EXCEPT ![r] = vn]<br>         /\ Send([type |-&gt; STARTVIEW, vn |-&gt; vn, src |-&gt; r])<br>         /\ UNCHANGED &lt;&lt;aVars&gt;&gt;<br><br>Next ==<br>  \/ \E r \in Replica:<br>       \/ ReplicaExecute(r, SUCCEED)<br>       \/ ReplicaExecute(r, FAILED)<br>       \/ ReplicaFail(r)<br>       \/ ReplicaStartViewChange(r)<br>       \/ ReplicaReceiveStartViewChange(r)<br>       \/ ReplicaReceiveDoViewChange(r)<br>       \/ ReplicaReceiveStartView(r)<br>       \* \/ ReplicaReceiveStartViewReply(r)<br>  \/ \/ AppFinalizedVal(SUCCEED)<br>     \/ AppFinalizedVal(FAILED)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xms50g -XX:+UseParallelGC -XX:MaxDirectMemorySize=300g -Dtlc2.tool.fp.FPSet.impl=tlc2.tool.fp.OffHeapDiskFPSet -<span class="hljs-built_in">cp</span> /usr/local/lib/tla2tools.jar tlc2.TLC IR -workers auto -checkpoint 0 &gt;stdout 2&gt;stderr<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">Model checking completed. No error has been found.<br>  Estimates of the probability that TLC did not check all reachable states<br>  because two distinct states had the same fingerprint:<br>  calculated (optimistic):  val = 4.4E-4<br>  based on the actual fingerprints:  val = 2.9E-5<br>274556881 states generated, 33937916 distinct states found, 0 states left on queue.<br>The depth of the complete state graph search is 33.<br>The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 16 and the 95th percentile is 3).<br>Finished in 16min 00s at (2024-01-12 23:20:32)<br></code></pre></td></tr></table></figure><p>The complexity in establishing the correctness of the original IR Recovery Protocol arises from its third step. Here, the recovering replica selects the highest view number, denoted as <span class="math inline">\({vn}_{max}\)</span>, from the <span class="math inline">\(\text{DO-VIEW-CHANGE}\)</span> messages received from other replicas, and then uses this view number in the steps that follow.</p><p>Consider the scenario where the response from replica <span class="math inline">\(r_1\)</span> is <span class="math inline">\(\langle\text{DO-VIEW-CHANGE}, {val}_1, {vn}_1\rangle\)</span>, from <span class="math inline">\(r_2\)</span> is <span class="math inline">\(\langle\text{DO-VIEW-CHANGE}, {val}_2, {vn}_2\rangle\)</span>, and so on, up to the response from <span class="math inline">\(r_{f+1}\)</span>, which is <span class="math inline">\(\langle\text{DO-VIEW-CHANGE}, {val}_{f+1}, {vn}_{f+1}\rangle\)</span>, with the condition that <span class="math inline">\({vn}_1 &lt; {vn}_{max}\)</span>, <span class="math inline">\({vn}_2 &lt; {vn}_{max}\)</span>, ..., and <span class="math inline">\({vn}_{f+1} = {vn}_{max}\)</span>.</p><p>In such a case, only replica <span class="math inline">\(r_{f+1}\)</span> is promised to not voting for any value other than <span class="math inline">\({val}_{f+1}\)</span>. The remaining replicas, <span class="math inline">\(r_1\)</span> through <span class="math inline">\(r_f\)</span>, have made no such promisement regarding their respective values <span class="math inline">\({val}_1\)</span> through <span class="math inline">\({val}_f\)</span>. This lack of promisement could result in a situation where the recovering replica may vote for <span class="math inline">\(val\)</span> in <span class="math inline">\({vn}_{max}\)</span>, while other replicas might have already finalized a different value, <span class="math inline">\({val}^\prime\)</span> (where <span class="math inline">\({val}^\prime \neq val\)</span>), in a previous view number <span class="math inline">\({vn}_k\)</span> with <span class="math inline">\({vn}_k &lt; {vn}_{max}\)</span>. Thus, demonstrating that the original IR recovery protocol adheres to previous decisions, becomes a challenging endeavor.</p><p>I suggest the term <strong>Subsequent Decisions</strong>: After a non-nil value <span class="math inline">\(v\)</span> is finalized by the super-quorums in view <span class="math inline">\(r\)</span>, it is guaranteed that no other non-nil value <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v \neq v^\prime\)</span> can be finalized in subsequent views <span class="math inline">\(r+1\)</span>, <span class="math inline">\(r+2\)</span>, ... I posit, with some uncertainty, that "subsequent decisions" and "previous decisions" are simply different facets of the same consistency constraint, applied to different views -- in essence, they are two sides of the same coin. Contrary to the complexity involved in proving adherence to "previous decisions," demonstrating that the original IR protocol complies with "subsequent decisions" is notably more straightforward.</p><p>The proof unfolds as follows: at the juncture when a value <span class="math inline">\(v\)</span> is finalized, at least <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> replicas are operational and have recorded the value <span class="math inline">\(v\)</span> in their registers. Should any of these replicas fail thereafter, upon recovery, they will encounter at least <span class="math inline">\(\lfloor\frac{f}{2}\rfloor+1\)</span> out of <span class="math inline">\(f+1\)</span> replicas that had <span class="math inline">\(v\)</span> written in their registers, compelling them to also write <span class="math inline">\(v\)</span> to their own register. Thus, post-finalization, regardless of how the involved replicas may experience failures, they are destined to re-adopt the value <span class="math inline">\(v\)</span> upon recovery. With a maximum of <span class="math inline">\(\lfloor\frac{f}{2}\rfloor-1\)</span> replicas not participating in the finalization process, these may cast their vote for any value. However, their votes are inconsequential to the outcome as they lack the numbers to influence or alter the already finalized value <span class="math inline">\(v\)</span>.</p><h3 id="qa-on-conflict-detection-and-ensuring-isolation-correctness">Q&amp;A on Conflict Detection and Ensuring Isolation Correctness</h3><p>The original paper maintains that isolation is guaranteed by employing optimistic concurrency control and quorum intersection mechanisms. However, I posit there's a flaw in the quorum intersection during failover events. To elaborate, a transaction <span class="math inline">\(X\)</span> can be committed only if it obtains at least <span class="math inline">\(f+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses. Nonetheless, in the worst-case scenario, only <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> of the <span class="math inline">\(f+1\)</span> replicas may independently decide to record and return <span class="math inline">\(\text{PREPARE-OK}\)</span>, with the remaining replicas succumbing to sequential failovers. Consequently, these replicas are compelled to record and send <span class="math inline">\(\text{PREPARE-OK}\)</span> based on the matching <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses from <span class="math inline">\(f+1\)</span> responses during the recovery protocol. These failover replicas do not execute the operation independently and, consequently, do not perform conflict detection. In such cases, transaction <span class="math inline">\(X\)</span> could be committed with just <span class="math inline">\(\lceil\frac{f}{2}\rceil+1\)</span> replicas genuinely detecting conflicts and voluntarily responding with <span class="math inline">\(\text{PREPARE-OK}\)</span>. As a result, the condition for quorum intersection may not be satisfied, as the overlap between quorums could be insufficient. If a conflicting transaction <span class="math inline">\(Y\)</span> had already committed on <span class="math inline">\(f+1\)</span> replicas, the calculation <span class="math inline">\((\lceil\frac{f}{2}\rceil+1)+(f+1)-(2f+1)=-\lfloor\frac{f}{2}\rfloor+1\)</span> yields a negative number, indicating an overlap of less than zero, which means there is no guarantee of a common replica between the quorums.</p><blockquote><p>TAPIR solves this problem using optimistic concurrency control and quorum intersection. OCC validation checks occur between the committing transaction and one previous transaction at a time. Thus, it not necessary or a single server to perform all the checks. Since IR ensures that every <span class="math inline">\(\text{Commit}\)</span> executes at at least 1 replica in any set of <span class="math inline">\(f+1\)</span> replicas, and every <span class="math inline">\(\text{Prepare}\)</span> executes at at least <span class="math inline">\(\lceil\frac{f}{2}\rceil\)</span> replicas in any set of <span class="math inline">\(f+1\)</span>, at least one replica will detect any possible OCC conflict between transactions, thus ensuring correctness.</p></blockquote><blockquote><p>Because <span class="math inline">\(\text{Prepare}\)</span> is a consensus operation, a transaction <span class="math inline">\(X\)</span> can be committed only if <span class="math inline">\(f+1\)</span> replicas return <span class="math inline">\(\text{PREPARE-OK}\)</span>. We show that this means the transaction is consistent with the serial timestamp ordering of transactions.</p><p>If a replica returns <span class="math inline">\(\text{PREPARE-OK}\)</span>, it has not prepared or committed any conflicting transactions. If a conflicting transaction <span class="math inline">\(Y\)</span> had committed, then there is one common participant shard where at least <span class="math inline">\(f+1\)</span> replicas responded <span class="math inline">\(\text{PREPARE-OK}\)</span> to <span class="math inline">\(Y\)</span>. However, those replicas would not return <span class="math inline">\(\text{PREPARE-OK}\)</span> to <span class="math inline">\(X\)</span>. Thus, by quorum intersection, <span class="math inline">\(X\)</span> cannot obtain <span class="math inline">\(f+1\)</span> <span class="math inline">\(\text{PREPARE-OK}\)</span> responses.</p></blockquote><p>To address the identified flaw, I propose reducing the tolerance for simultaneous failures from <span class="math inline">\(f\)</span> to <span class="math inline">\(\lfloor\frac{f}{2}\rfloor\)</span>. Consequently, during the recovery protocol, a recovering replica would need to gather <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> responses. The "force recover operation", denoted as <span class="math inline">\(\operatorname{Recover}(op, res)\)</span>, would only be invoked if at least <span class="math inline">\((\lceil\frac{3f}{2}\rceil+1)+(\lceil\frac{3f}{2}\rceil+1)-(2f+1) \ge f+1\)</span> responses are matching results <span class="math inline">\(res\)</span>. This ensures that a minimum of <span class="math inline">\(f+1\)</span> replicas, which have independently detected conflicts, respond with <span class="math inline">\(\text{PREPARE-OK}\)</span> before transaction <span class="math inline">\(X\)</span> is committed. By implementing this change, the requirement for quorum intersection is satisfied, thus upholding the integrity of the isolation guarantee.</p><h2 id="replacing-ir-with-fast-paxos-a-protocol-substitution-analysis">Replacing IR with Fast Paxos: A Protocol Substitution Analysis</h2><blockquote><p>The inconsistent replication protocol shares many features with Viewstamped Replication. Like VR, inconsistent replication is designed for <strong>in-memory</strong> replication without relying on synchronous disk writes. The possibility of data loss on replica failure, which does not happen in protocols like Paxos that assume durable writes, necessitates the use of viewstamps for both replication protocols. Our decision to focus on in-memory replication is motivated by the popularity of recent inmemory systems like RAMCloud and H-Base.</p></blockquote><blockquote><p><strong>IR does not rely on synchronous disk writes;</strong> it ensures guarantees are maintained even if clients or replicas <strong>lose state on failure</strong>. This property allows IR to provide better performance, especially within a datacenter, compared to Paxos and its variants, which require synchronous disk writes and recovery from disk on failure. IR also provide better fault-tolerance because this property allows it to tolerate disk failures at replicas.</p></blockquote><p>The authors highlight that IR is an in-memory replication protocol that operates independently of synchronous disk writes. However, the need for persistence is critical in certain systems, like the metadata components of distributed file systems, where the marginal slowdown due to sequential writes on industrial-grade SSDs is often negligible and tolerable. Consequently, I believe the practical advantages of in-memory replication may not be as significant as suggested. With this perspective, I am keen to explore the integration of synchronous log-writing capabilities into the IR framework. The original paper states:</p><blockquote><p>Given the ability to synchronously log to durable storage (e.g. hard disk, NVRAM), we can reduce the quorum requirements for TAPIR. As long as we can recover the log after failures, we can reduce the replica group size to <span class="math inline">\(2f+1\)</span> and reduce all consensus and synchronization quorums to <span class="math inline">\(f+1\)</span>.</p></blockquote><p>Considering the capability to synchronously log to durable storage, the benefits extend beyond just lowering quorum requirements for TAPIR. I am contemplating the use of Fast Paxos to replace IR because Fast Paxos is a well-established protocol with broader adoption in industrial applications.</p><p>The Modified Fast Paxos, designed as a replacement for the IR protocol, deviates from the original Fast Paxos in several key aspects:</p><ol type="1"><li><strong>Transaction Scope</strong>: Unlike the original Fast Paxos, which orders multiple transactions, the Modified Fast Paxos protocol handles a single transaction independently. It does not consider the order or relationship with other transactions.</li><li><strong>Fast Round</strong>: The initial round is the only one fast round in the protocol. The protocol initiates with a fast round, where a client may propose a <span class="math inline">\(\text{Prepare}\)</span> command as a consensus operation without a predetermined result (<span class="math inline">\(\text{PREPARE-OK}\)</span> or <span class="math inline">\(\text{ABORT}\)</span>). Replicas decide independently whether to record and return <span class="math inline">\(\text{PREPARE-OK}\)</span> or <span class="math inline">\(\text{ABORT}\)</span>, eliminating the need for inter-replica communication at this stage. This <span class="math inline">\(\text{Prepare}\)</span> command and its subsequent result are analogous to the client-proposed value in the original Fast Paxos.</li><li><strong>Slow Round</strong>: Rounds following the initial one are classified as slow rounds.<ol type="1"><li>The slow quorum requirement is set at <span class="math inline">\(f\)</span>, consistent with the original Fast Paxos.</li><li>If all phase 1b messages only contain the same <span class="math inline">\(\operatorname{vrnd}(a)\)</span> value that matches the fast round's ID, but no other ballot IDs, the slow round must receive more than <span class="math inline">\(\lceil\frac{3f}{2}\rceil+1\)</span> of these messages to move on to phase 2. This step is crucial for detecting conflicting transactions and maintaining isolation correctness, as mentioned previously. In contrast, the original Fast Paxos protocol only requires more than <span class="math inline">\(f+1\)</span> phase 1b messages to enter phase 2. As a result, the failure tolerance has been decreased from <span class="math inline">\(f\)</span> to <span class="math inline">\(\lfloor\frac{f}{2}\rfloor\)</span> in the modified protocol.</li><li>In alignment with Quorum Requirement of the original protocol, the Modified Fast Paxos ensures that every two fast quorums and each slow quorum have non-empty intersection. Consequently, no more than one value can fulfill the original Fast Paxos's Observation 4. During phase 1 of the slow round, if a value satisfying this requirement exists, it should be proposed in phase 2. If no such value exists, the protocol defaults to proposing an <span class="math inline">\(\text{ABORT}\)</span> for safety reasons.</li></ol></li></ol><h2 id="reference">Reference</h2><ul><li><a href="https://syslab.cs.washington.edu/papers/tapir-tr14.pdf">Building Consistent Transactions with Inconsistent Replication</a></li><li><a href="https://github.com/UWSysLab/tapir">GitHub: UWSysLab/tapir</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li><li><a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a></li><li><a href="https://clcanny.github.io/2023/03/06/computer-science/serializability/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/">Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed</a></li><li><a href="https://www.cs.cmu.edu/~dga/papers/epaxos-sosp2013.pdf">There Is More Consensus in Egalitarian Parliaments</a></li><li><a href="https://cwiki.apache.org/confluence/display/CASSANDRA/CEP-15%3A+General+Purpose+Transactions?preview=/188744725/188744736/Accord.pdf">CEP-15: Fast General Purpose Transaction</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Serializability</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - A Generalised Solution to Distributed Consensus</title>
    <link href="/2023/11/04/computer-science/consensus/paper-interpretation-a-generalised-solution-to-distributed-consensus/"/>
    <url>/2023/11/04/computer-science/consensus/paper-interpretation-a-generalised-solution-to-distributed-consensus/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>This paper presents an inspiring piece of work. Creating a distributed consensus algorithm from scratch is no easy task, as Leslie Lamport, the Turing Award winner, once said: "...this consensus algorithm follows almost unavoidably from the properties we want it to satisfy." What this paper does beautifully is to demystify this process, showing even those of us who aren't Turing laureates how to design a consensus algorithm from the ground up.</p><p>Building upon the insights from this paper, I plan to revisit the proofs of classical Paxos, Flexible Paxos, and Fast Paxos. My aim is to reinterpret and understand them within the framework presented in this paper.</p><h2 id="problem-definition">Problem Definition</h2><p>The classic formulation of consensus considers how to decide upon a <strong>single</strong> value in a distributed system. We consider systems comprised of two types of participant: servers, which store the value, and clients, which read/write the value. If you have read <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>, you'll see that the priest's role is like a mix of the server and client roles as defined in this paper. Interestingly, in most consensus literature, the server role combines the functions of both the client and server as defined here. So, when studying consensus in this context, it's best to forget the usual definitions of server and client roles and instead follow Heidi Howard's definition.</p><p>An algorithm solves consensus if it satisfies the following three requirements:</p><ul><li><strong>Non-triviality</strong>. All output values must have been the input value of a client.</li><li><strong>Agreement</strong>. All clients that output a value must output the same value.</li><li><strong>Progress</strong>. All clients must eventually output a value if the system is reliable and synchronous for a sufficient period. This requirement rules out algorithms that could reach deadlock, but it doesn't exclude those that could enter a state of livelock or become stuck when the liveness condition isn't satisfied. As termination cannot be guaranteed in an asynchronous system where failures may occur, algorithms need only guarantee termination assuming liveness.</li></ul><h2 id="single-server-solution">Single-Server Solution</h2><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/single-server-1.png" alt="" /><figcaption>Single Server</figcaption></figure><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/single-server-2.png" alt="" /><figcaption>Single Server</figcaption></figure><p>If we have only one server, the solution is straightforward. The server has a single persistent write-once register, <span class="math inline">\(R0\)</span>, to store the decided value. Clients send requests to the server with their input value. If <span class="math inline">\(R0\)</span> is unwritten, the value received is written to <span class="math inline">\(R0\)</span> and is returned to the client. If <span class="math inline">\(R0\)</span> is already written, then the value in <span class="math inline">\(R0\)</span> is read and returned to the client. The client then outputs the returned value. This algorithm achieves consensus but requires the server to be available for clients to terminate. To overcome this limitation requires deployment of more than one server, so we now consider how to generalise to multiple servers.</p><h2 id="multiple-servers-each-with-a-single-write-once-persistent-register-solution">Multiple Servers, Each with a Single Write-Once Persistent Register Solution</h2><p>We could say a client has to write to all the registers to decide a value, but then that would be even worse than the original algorithm, because now we have three servers and if any one of the three fails, we won't be able to make progress. So let's write to a majority of servers (two or three). That means that there would be an overlap between any two majorities and if one failed, we could still reach a decision. We have got safety, which is great. Unfortunately, we <strong>don't actually have the progress property</strong>. So we could have a scenario like this, three clients come along, and each of these three clients talks to one of the three servers first and then we've got one register with the value <span class="math inline">\(A\)</span>, one register with the value <span class="math inline">\(B\)</span>, and one register with the value <span class="math inline">\(C\)</span>. We said we wanted <strong>immutability</strong> property. We're pretty stuck now, there's nothing we can do without overwriting these registers, so we don't have progress.</p><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/multi-server-each-with-a-sginle-register-split-votes.png" alt="" /><figcaption>Split Votes</figcaption></figure><h2 id="multiple-servers-each-with-multiple-write-once-persistent-registers-solution">Multiple Servers, Each with Multiple Write-Once Persistent Registers Solution</h2><p>Consider a set of servers, <span class="math inline">\(\{S_0, S_1, \ldots, S_n\}\)</span>, where each has a infinite series of write-once, persistent registers, <span class="math inline">\(\{R_0, R_1, \ldots, R_n\}\)</span>. Clients read and write registers on servers and, at any time, each register is in one of the three states:</p><ul><li><strong>unwritten</strong>, the starting state for all registers; or</li><li><strong>contains a value</strong>, e.g., <span class="math inline">\(A\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(C\)</span>; or</li><li><strong>contains nil</strong>, a special value denoted as <span class="math inline">\(\perp\)</span>.</li></ul><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/multi-server-each-with-multi-registers.png" alt="" /><figcaption>Multiple Servers, Each with Multiple Write-Once Persistent Registers</figcaption></figure><p>The following concepts need to be clarified:</p><ul><li>A <strong>quorum</strong>, <span class="math inline">\(Q\)</span>, is a (non-empty) subset of servers, such that if all servers have a same (non-nil) value <span class="math inline">\(v\)</span> in <strong>the same register</strong> then <span class="math inline">\(v\)</span> is said to be decided. If you're familiar with distributed systems, you might be thinking about concepts like quorums, majorities, and read-write quorums. However, for now, please set aside any ideas about the necessity for these constructs to intersect. We'll see later whether we do or do not need any intersection properties between them.</li><li>A <strong>register set</strong>, <span class="math inline">\(i\)</span>, is the set comprised of the register <span class="math inline">\(R_i\)</span> from each server. Each register set <span class="math inline">\(i\)</span> is configured with a set of quorums, <span class="math inline">\(\mathcal{Q}_i\)</span>, and four example configurations are given in Figure 1.</li><li>The state of all registers can be represented in a table, known as a <strong>state table</strong>, where each column represents the state of one server and each row represents a register set.</li></ul><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/figure-1-sample-configurations-for-systems-of-three-or-four-servers.png" alt="" /><figcaption>Figure 1: Sample configurations for systems of three or four servers.</figcaption></figure><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/figure-2-sample-state-tables-for-a-system-using-the-configuration-in-figure-1a.png" alt="" /><figcaption>Figure 2: Sample state tables for a system using the configuration in Figure 1a.</figcaption></figure><p>We define a value as being decided when we can identify at least one register set <span class="math inline">\(i\)</span>, and a quorum <span class="math inline">\(Q_i\)</span> such that <span class="math inline">\(Q_i \in \mathcal{Q}_i\)</span> (where <span class="math inline">\(\mathcal{Q}_i\)</span> represents the configured quorum sets of the register set <span class="math inline">\(i\)</span>), and every server in <span class="math inline">\(Q_i\)</span> has its register <span class="math inline">\(R_i\)</span> uniformly written with the identical non-nil value <span class="math inline">\(v\)</span>. By combining a configuration with a state table, we can determine whether any decision(s) have been reached (indicated by the gray highlights), as shown in Figure 2.</p><h3 id="correctness">Correctness</h3><p>The algorithm adheres to the following four rules, which in turn ensures the satisfaction of the non-triviality, agreement, and progress requirements. Fulfilling these requirements ultimately leads to the successful resolution of consensus.</p><ul><li>Rule 1: <strong>Quorum agreement</strong>. A client may only output a (non-nil) value <span class="math inline">\(v\)</span> if it has read <span class="math inline">\(v\)</span> from a quorum of servers in the same register set. This rule ensures that clients only output values that have been decided. When combined with rules 3 and 4 (which guarantee that at most only one value can be decided), this rule ensures the fulfillment of the <strong>agreement</strong> requirement.</li><li>Rule 2: <strong>New value</strong>. A client may only write a (non-nil) value <span class="math inline">\(v\)</span> provided that either <span class="math inline">\(v\)</span> is the client's input value or that the client has read <span class="math inline">\(v\)</span> from a register. This rule ensures the fulfillment of the <strong>non-triviality</strong> requirement.</li><li>Before a client writes a value to a register <span class="math inline">\(R_i\)</span> in register set <span class="math inline">\(i\)</span>, it needs to ensure that no other values could be decided in register sets <span class="math inline">\(0\)</span> through <span class="math inline">\(i\)</span> (inclusive). The client plans to write into register <span class="math inline">\(R_i\)</span>; however, it's the client's responsibility to verify that none of the previous registers could decide on a different value prior to doing so. This is a crucial step for maintaining safety. All clients must perform this check to prevent conflicting decisions.<ul><li>Interestingly, if writing to a register <span class="math inline">\(R_i\)</span> wouldn't lead to a value being decided, then the client has the freedom to write any value of their preference. This implies that a more relaxed condition could be proposed. However, this relaxed aspect is not significant in the current context, so it is omitted.</li><li>Rule 3: <strong>Current decision</strong>. A client may only write a (non-nil) value <span class="math inline">\(v\)</span> to register <span class="math inline">\(r\)</span> on server <span class="math inline">\(s\)</span> provided that if <span class="math inline">\(v\)</span> is decided in register set <span class="math inline">\(r\)</span> by a quorum <span class="math inline">\(Q \in \mathcal{Q}_r\)</span> where <span class="math inline">\(s \in Q\)</span> then no value <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v \neq v^\prime\)</span> can also be decided in register set <span class="math inline">\(r\)</span>.</li><li>Rule 4: <strong>Previous decisions</strong>. A client may only write a (non-nil) value <span class="math inline">\(v\)</span> to register <span class="math inline">\(r\)</span> provided no value <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v \neq v^\prime\)</span> can be decided by the quorums in register sets <span class="math inline">\(0\)</span> to <span class="math inline">\(r − 1\)</span>.</li></ul></li></ul><p>Implementing rule 1 and rule 2 is straightforward. We will not delve into their details in the later sections. Instead, our focus will be on providing guidance on the correct implementation of rule 3 and rule 4.</p><h3 id="how-the-single-decree-synod-implements-the-correctness-rules">How the Single-Decree Synod Implements the Correctness Rules</h3><p><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Single-Decree Synod</a> employs <strong>disjoint quorums</strong> to implement rule 3, whereby all values written to a particular register set must be identical. This can be achieved by assigning register sets to clients and requiring that <strong>clients write only to their own register sets, with at most one value</strong>. In practice, this could be implemented by using an allocation such as that in Figure 4 and by requiring clients to keep a persistent record of which register sets they have written too. We refer to these as <strong>client restricted configurations</strong>.</p><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/figure-4-sample-round-robin-allocation-of-register-sets-to-clients.png" alt="" /><figcaption>Figure 4: Sample round robin allocation of register sets to clients.</figcaption></figure><p>For those familiar with <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>, a useful correspondence can be drawn between register sets in the current paper and the concept of ballots in Paxos.</p><p>Upholding rule 4 presents a more formidable challenge. A tool we can utilize to address this difficulty is the <strong>decision table</strong>. Each client's state table consistently contains a subset of the values from the global state table, which is a consequence of the registers being write-once. Consequently, each client possesses the capability to generate a decision table drawing from their individual local state table. At any given time, each <strong>quorum</strong> is in one of four decision states:</p><ul><li><span class="math inline">\(\text{Any}\)</span>: Any value could be decided by this quorum.</li><li><span class="math inline">\(\text{Maybe}(v)\)</span>: If this quorum reaches a decision, then value <span class="math inline">\(v\)</span> will be decided.</li><li><span class="math inline">\(\text{Decided}(v)\)</span>: The value <span class="math inline">\(v\)</span> has been decided by this quorum; a final state.</li><li><span class="math inline">\(\text{None}\)</span>: This quorum will not decide a value; a final state.</li></ul><p>Here are the rules that govern the update of the decision table for client-restricted register sets:</p><ul><li>Initially, the decision state of all quorums is <span class="math inline">\(\text{Any}\)</span>.</li><li>If there is a quorum where all registers contain the same value <span class="math inline">\(v\)</span> then its decision state is <span class="math inline">\(\text{Decided}(v)\)</span>.</li><li>When a client reads a non-nil value <span class="math inline">\(v\)</span> at a specific register <span class="math inline">\(R_r\)</span> (which is one register in the register set <span class="math inline">\(r\)</span>),<ul><li>According to client restricted configurations, only one client can write a singular value, <span class="math inline">\(v\)</span>, to register set <span class="math inline">\(i\)</span>.</li><li>According to Rule 4, prior to the client writing the value <span class="math inline">\(v\)</span> to register sets <span class="math inline">\(r\)</span>, it must have already ensured that no other value <span class="math inline">\(v^\prime \neq v\)</span> can be decided by the register sets ranging from <span class="math inline">\(0\)</span> to <span class="math inline">\(r - 1\)</span>.</li><li>Consequently, we can update the decision state as follows. For all quorums over register sets <span class="math inline">\(0\)</span> to <span class="math inline">\(r\)</span>,<ul><li>The decision state <span class="math inline">\(\text{Any}\)</span> becomes <span class="math inline">\(\text{Maybe}(v)\)</span>,</li><li>And the decision state <span class="math inline">\(\text{Maybe}(v^\prime)\)</span> where <span class="math inline">\(v^\prime \neq v\)</span> becomes <span class="math inline">\(\text{None}\)</span>. The client restricted configurations ensure that only one value can be written to this register set. If the current state is <span class="math inline">\(\text{Maybe}(v^\prime)\)</span>, then the final state can either be <span class="math inline">\(\text{Decided}(v^\prime)\)</span> or <span class="math inline">\(\text{None}\)</span>. However, when a client writes a value <span class="math inline">\(v\)</span> to register <span class="math inline">\(R_r\)</span>, it must adhere to Rule 4. This rule stipulates that the client must ensure no other value <span class="math inline">\(v^\prime \neq v\)</span> can be decided for this register set. This requirement implies that the final state cannot be <span class="math inline">\(\text{Decided}(v^\prime)\)</span>. Therefore, the only possible final state is <span class="math inline">\(\text{None}\)</span>.</li></ul></li></ul></li></ul><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-a-generalised-solution-to-distributed-consensus/figure-6-sample-client-state-tables-left-and-decision-tables-right.png" /></p><p>There are numerous ways to finalize every decision state of preceding register sets to end states (<span class="math inline">\(\text{Decided}(v)\)</span> and <span class="math inline">\(\text{None}\)</span>). A straightforward but inefficient way is to simply wait. However, the Single-Decree Synod employs a faster and simpler method, which I term "fence-and-read-majority". Before writing to any registers in register set <span class="math inline">\(r\)</span>, the client requests <strong>all</strong> servers to place a "fence" on the registers of register sets from <span class="math inline">\(0\)</span> to <span class="math inline">\(r - 1\)</span>: if a register state is unwritten, the server writes "nil" to it to prevent further writing; if not, it does nothing. The server then returns the value post-fencing. It's important to note that this fence-and-read-majority is an atomic action on each server. After collecting a <strong>majority (not all)</strong> of responses from the fence-and-read-majority action, the client can create a decision table that excludes <span class="math inline">\(\text{Any}\)</span> states, instead only including <span class="math inline">\(\text{Maybe}(v)\)</span>, <span class="math inline">\(\text{Decided}(v)\)</span>, or <span class="math inline">\(\text{None}\)</span> states. Given that each register is written to only once, the client's local state table will invariably be a subset of the global state table. Consequently, the local decision table will remain consistent with the global decision table both now and in the future. Based on this local decision table, the client can then select a value while complying with Rule 4.</p><p>A minor optimization is available in this procedure. Instead of calculating all decision states from <span class="math inline">\(0\)</span> to <span class="math inline">\(r - 1\)</span>, the client only needs to identify the highest register set <span class="math inline">\(k\)</span> containing the non-nil value <span class="math inline">\(v\)</span> and then calculate the decision state of register set <span class="math inline">\(k\)</span>. Here, "highest" means that no other registers of register sets from <span class="math inline">\(k + 1\)</span> to <span class="math inline">\(r - 1\)</span> in the response have non-nil values. The client then calculates the decision state of register set <span class="math inline">\(k\)</span>.</p><ul><li>Following Rule 4, before the client (which may not necessarily be the same client that writes the value to register set <span class="math inline">\(r\)</span>) writes <span class="math inline">\(v\)</span> to register set <span class="math inline">\(k\)</span>, it must have already ensured that no other value <span class="math inline">\(v^\prime \neq v\)</span> can be decided in register sets from <span class="math inline">\(0\)</span> to <span class="math inline">\(k - 1\)</span>. This means it's safe for the client to write <span class="math inline">\(v\)</span> to register set <span class="math inline">\(r\)</span> without violating Rule 4 on register sets from <span class="math inline">\(0\)</span> to <span class="math inline">\(k - 1\)</span>.</li><li>According to client-restricted configurations, it's also safe for the client to write <span class="math inline">\(v\)</span> to register set <span class="math inline">\(r\)</span> without violating Rule 4 on register set <span class="math inline">\(k\)</span>.</li><li>Since <span class="math inline">\(k\)</span> is the highest register set and the majority of registers in register sets from <span class="math inline">\(k + 1\)</span> to <span class="math inline">\(r - 1\)</span> have been fenced (written to nil), no value can be decided in these register sets. Therefore, it's safe for the client to write <span class="math inline">\(v\)</span> to register set <span class="math inline">\(r\)</span> without violating Rule 4 on register sets from <span class="math inline">\(k + 1\)</span> to <span class="math inline">\(r - 1\)</span>.</li></ul><p>You might question whether the client can use the decision state of any register set instead of the highest register set. However, this is incorrect. Let's consider a scenario where a client writes <span class="math inline">\(v_n\)</span> to register set <span class="math inline">\(r\)</span> <strong>solely based on</strong> its observation that the decision state of register <span class="math inline">\(n\)</span> (<span class="math inline">\(n &lt; m &lt; r\)</span>) is <span class="math inline">\(\text{Maybe}(v_n)\)</span>. In this situation, the client could potentially write a value that violates Rule 4. This violation can occur because another client may perceive the decision state of register <span class="math inline">\(n\)</span> as <span class="math inline">\(\text{None}\)</span> (due to getting register values from a different quorum, resulting in a different decision state) and write a value <span class="math inline">\(v_m \neq v_n\)</span> to register set <span class="math inline">\(m\)</span> (<span class="math inline">\(n &lt; m &lt; r\)</span>). Consequently, <span class="math inline">\(v_m\)</span> gets decided in register set <span class="math inline">\(m\)</span>, leading to a conflict.</p><h3 id="how-fast-paxos-implements-the-correctness-rules">How Fast Paxos Implements the Correctness Rules</h3><p>Fast Paxos generalises Paxos by permitting intersecting quorum configurations for some register sets, known as <strong>fast sets</strong>, whilst still utilising client restricted configurations for remaining sets, known as <strong>classic sets</strong>.</p><p>The process to determine which register sets are designated as fast sets and which are classic sets can be somewhat intricate. If you're interested in a more detailed exploration of this topic, I recommend reading the Fast Paxos paper. However, in this discussion, we'll focus on the simplest scenario. We designate register set <span class="math inline">\(0\)</span> as the sole fast set, with all remaining register sets classified as classic sets. In this setup, a client does not need to be assigned to register set <span class="math inline">\(0\)</span> nor do they need to ensure that they write to it with only one value. Clients can write many different non-nil values to various registers of register set <span class="math inline">\(0\)</span>.</p><p>This introduces a complexity for clients that are preparing to write to register sets with larger indices, such as register set <span class="math inline">\(1\)</span>. Recall that Heidi Howard stated "each quorum is in one of four decision states". However, each register set has multiple quorums, each of which could be in the state <span class="math inline">\(\text{Maybe}(v)\)</span> or <span class="math inline">\(\text{Maybe}(v^\prime)\)</span> (where <span class="math inline">\(v^\prime \neq v\)</span>), or other similar states. This results in the decision table of the corresponding register set presenting as <span class="math inline">\(\text{Maybe}(v, v^\prime)\)</span>. While the Single-Decree Synod avoids this situation by using client restricted configurations, Fast Paxos may encounter this issue. For instance, when a client writes to register set <span class="math inline">\(1\)</span>, it cannot determine the decision state of register set <span class="math inline">\(0\)</span> as simply as in the Single-Decree Synod. This is because different registers of register set <span class="math inline">\(0\)</span> can be written with different values, leading to the client receiving different decision states based on different quorums - it could be <span class="math inline">\(\text{Maybe}(v)\)</span> based on one quorum, and <span class="math inline">\(\text{Maybe}(v^\prime)\)</span> where <span class="math inline">\(v^\prime \neq v\)</span> based on another quorum. This situation leaves the client in a quandary - it cannot write to register set <span class="math inline">\(1\)</span> until it has ascertained that at most one value could potentially be decided on in register set <span class="math inline">\(0\)</span>.</p><p>This issue is addressed through the <strong>Quorum Requirement</strong>. For any round numbers <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, if <span class="math inline">\(j\)</span> is designated as a fast round number, then any <span class="math inline">\(i\)</span>-quorum and any two <span class="math inline">\(j\)</span>-quorums will have a non-empty intersection. Let <span class="math inline">\(N\)</span> be the number of servers, and let us choose <span class="math inline">\(F\)</span> and <span class="math inline">\(E\)</span> such that any set of at least <span class="math inline">\(N - F\)</span> servers is a classic quorum and any set of at least <span class="math inline">\(N - E\)</span> servers is a fast quorum. In any given round, any two fast quorums, <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>, will intersect at least <span class="math inline">\(2 * (N - E) - N\)</span> servers, represented by <span class="math inline">\(R_1 \cap R_2\)</span>. If we consider <span class="math inline">\(Q\)</span> to be any classic quorum, there will be at least <span class="math inline">\((2 * (N - E) - N) + (N - F) - N\)</span> servers in the intersection <span class="math inline">\(Q \cap R_1 \cap R_2\)</span>. Therefore, if we ensure that <span class="math inline">\(N &gt; 2E + F\)</span>, it guarantees that the intersection <span class="math inline">\(Q \cap R_1 \cap R_2\)</span> is not empty.</p><h3 id="how-flexible-paxos-implements-the-correctness-rules">How Flexible Paxos Implements the Correctness Rules</h3><p>We observe that quorum intersection is required only between <strong>the phase one quorum</strong> for register set <span class="math inline">\(r\)</span> and <strong>the phase two quorums</strong> of register sets <span class="math inline">\(0\)</span> to <span class="math inline">\(r − 1\)</span>. This is the case because a client can always proceed to phase two after intersecting with all previous phase two quorums since Rule 4 will be satisfied.</p><h2 id="revisiting-the-proofs">Revisiting the Proofs</h2><h3 id="revisiting-the-proof-of-the-single-decree-synod">Revisiting the Proof of the Single-Decree Synod</h3><p>Based on the sketch provided in the current paper, it's clear that a client (denoted as <span class="math inline">\(C_n\)</span>) writing a different value (such as <span class="math inline">\(v^\prime\)</span> where <span class="math inline">\(v^\prime \neq v\)</span>) to a register set (like <span class="math inline">\(n\)</span>) violates Rule 4 if a value (like <span class="math inline">\(v\)</span>) has already been decided on a smaller register set (like <span class="math inline">\(m\)</span> where <span class="math inline">\(m &lt; n\)</span>). Without loss of generality, we can assume that register set <span class="math inline">\(n\)</span> is the register set with the lowest index greater than <span class="math inline">\(m\)</span> that been written with a different value. Our goal is to prove that obeying Rule 4 and adhering to <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> as proposed by The Part-Time Parliament are equivalent under client-restricted configurations. We will demonstrate this by contradiction, starting with the assumption that client <span class="math inline">\(C_n\)</span> complies with <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span>. This suggests that there should be another register set, referred to as <span class="math inline">\(k\)</span>, where <span class="math inline">\(m &lt; k &lt; n\)</span>. Additionally, the decision state observed by client <span class="math inline">\(C_n\)</span> for register set <span class="math inline">\(k\)</span> must be either <span class="math inline">\(\text{Maybe}(v^\prime)\)</span> or <span class="math inline">\(\text{Decided}(v^\prime)\)</span>. If this isn't the case, and the observed decision states of all register sets from <span class="math inline">\(m + 1\)</span> to <span class="math inline">\(n - 1\)</span> by client <span class="math inline">\(C_n\)</span> are either <span class="math inline">\(\text{Any}\)</span>, <span class="math inline">\(\text{None}\)</span>, <span class="math inline">\(\text{Maybe}(v)\)</span>, or <span class="math inline">\(\text{Decided}(v)\)</span>, it would imply that <span class="math inline">\(C_n\)</span> is breaching <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> when writing <span class="math inline">\(v^\prime\)</span> to register set <span class="math inline">\(n\)</span>. However, this results in a contradiction as register set <span class="math inline">\(k\)</span> is the register set with the lowest index greater than <span class="math inline">\(m\)</span> that been written with a different value. This contradiction solidifies our proof.</p><h3 id="revisiting-the-proof-of-fast-paxos">Revisiting the Proof of Fast Paxos</h3><p>Fast Paxos demonstrates the correctness of classical Paxos through a method of classification and induction, a process analogous to the section titled "How the Single-Decree Synod Implements the Correctness Rules" in the current blog.</p><h2 id="reference">Reference</h2><ul><li><a href="https://arxiv.org/pdf/1902.06776.pdf">A Generalised Solution to Distributed Consensus</a></li><li><a href="https://youtu.be/Pqc6X3sj6q8?feature=shared">Distributed Consensus Revised by Heidi Howard</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Consensus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - There Is More Consensus In Egalitarian Parliaments</title>
    <link href="/2023/08/11/computer-science/consensus/paper-interpretation-there-is-more-consensus-in-egalitarian-parliaments/"/>
    <url>/2023/08/11/computer-science/consensus/paper-interpretation-there-is-more-consensus-in-egalitarian-parliaments/</url>
    
    <content type="html"><![CDATA[<p>This post is the first in a series on EPaxos, focusing specifically on Simplified Egalitarian Paxos. In subsequent posts, I'll delve into Optimized Egalitarian Paxos along with its safety and liveness properties, and explore how Linearizability and Serializability are achieved in Egalitarian Paxos. Additionally, I plan to demonstrate how to transition from Fast Paxos to EPaxos using TLA+ in future posts.</p><h2 id="the-commit-protocol-transitioning-from-fast-paxos-to-egalitarian-paxos">The Commit Protocol: Transitioning from Fast Paxos to Egalitarian Paxos</h2><p>The commentary by <a href="http://drmingdrmer.github.io/">drdr.xp</a> on <a href="https://www.zhihu.com/people/xiangguangyan">xiangguangyan</a>'s article <a href="https://zhuanlan.zhihu.com/p/387468959">EPaxos Trilogy II: EPaxos Core Protocol Process</a> provides valuable insight into the transition from Fast Paxos to Egalitarian Paxos:</p><blockquote><p>The distinction between a fast quorum (or perhaps "fast path" is a more precise term?) and Fast Paxos is essentially non-existent.</p></blockquote><p>We should do the following minor changes to Fast Paxos:</p><ul><li>In fast round, the acceptors will do some minor changes to value, make it <span class="math inline">\(w\)</span>.</li><li>Unify all states to cmds.</li><li>Change message path.</li></ul><p>I have gained a comprehensive understanding of the classic Paxos algorithm through <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>, and of the Fast Paxos algorithm through <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf">Fast Paxos</a>. However, I've noticed that the terminology used in these papers differs from that used in this paper. To ease the transition and ensure clarity, I've compiled a table aligning the terminologies from all these sources. Notably, in this section, I will use the terms "coordinators" and "replicas" interchangeably when they act as designated leaders, and similarly, "acceptors" and "replicas" will also be used interchangeably.</p><table><thead><tr class="header"><th style="text-align: left;">The Part-Time Parliament</th><th style="text-align: left;">Fast Paxos</th><th style="text-align: left;">EPaxos</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">priests</td><td style="text-align: left;">coordinators</td><td style="text-align: left;">replicas, designated leaders</td></tr><tr class="even"><td style="text-align: left;">priests</td><td style="text-align: left;">acceptors</td><td style="text-align: left;">replicas</td></tr><tr class="odd"><td style="text-align: left;">priests</td><td style="text-align: left;">proposers</td><td style="text-align: left;">replicas, designated leaders</td></tr><tr class="even"><td style="text-align: left;">priests</td><td style="text-align: left;">learners</td><td style="text-align: left;">replicas, designated leaders</td></tr><tr class="odd"><td style="text-align: left;">ballot</td><td style="text-align: left;">round</td><td style="text-align: left;">ballot</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{nextBal}(p)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{rnd}(a)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{cmds}_L[L][i_L]\)</span></td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\({\operatorname{prevVote}(p)}_{bal}\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{vrnd}(a)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{cmds}_Q[L][i_L]\)</span></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\({\operatorname{prevVote}(p)}_{dec}\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{vval}(a)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{cmds}_Q[L][i_L]\)</span></td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(\operatorname{lastTried}(p)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{crnd}(c)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{cmds}_L[L][i_L]\)</span></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"><span class="math inline">\(\operatorname{cval}(c)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{cmds}_L[L][i_L]\)</span></td></tr><tr class="odd"><td style="text-align: left;">Step 1 of the Basic Protocol</td><td style="text-align: left;">phase 1a</td><td style="text-align: left;">Explicit Prepare</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{NextBallot}(b)\)</span></td><td style="text-align: left;">phase 1a message</td><td style="text-align: left;"><span class="math inline">\(\operatorname{Prepare}(epoch.(b+1).Q, L.i)\)</span></td></tr><tr class="odd"><td style="text-align: left;">Step 2 of the Basic Protocol</td><td style="text-align: left;">phase 1b</td><td style="text-align: left;">Explicit Prepare</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{LastVote}(b, v)\)</span></td><td style="text-align: left;">phase 1b message</td><td style="text-align: left;"><span class="math inline">\(\operatorname{PrepareOK}(\operatorname{cmds}_R[L][i], epoch.x.Y, L.i)\)</span></td></tr><tr class="odd"><td style="text-align: left;">Step 3 of the Basic Protocol</td><td style="text-align: left;">phase 2a</td><td style="text-align: left;">Paxos-Accept</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span></td><td style="text-align: left;">phase 2a message</td><td style="text-align: left;"><span class="math inline">\(\operatorname{Accept}(\gamma, \text{seq}_\gamma, \text{deps}_\gamma, L.i)\)</span></td></tr><tr class="odd"><td style="text-align: left;">Step 4 of the Basic Protocol</td><td style="text-align: left;">phase 2b</td><td style="text-align: left;">Paxos-Accept</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{Voted}(b, q)\)</span></td><td style="text-align: left;">phase 2b message</td><td style="text-align: left;"><span class="math inline">\(\operatorname{AcceptOK}(\gamma, L.i)\)</span></td></tr></tbody></table><h3 id="bypass-any-messages-in-fast-rounds">Bypass "Any" Messages in Fast Rounds</h3><p>In Fast Paxos, during a fast round <span class="math inline">\(i\)</span>, if the coordinator can pick any proposed value in phase 2a, then instead of picking a single value, it may instead send a special phase 2a message called an any message to the acceptors. When an acceptor receives a phase 2a any message, it may treat <strong>any proposer's message</strong> proposing a value as if it were an ordinary round <span class="math inline">\(i\)</span> phase 2a message with that value.</p><p>Moving on to Egalitarian Paxos, each instance is associated with a predefined instance sub-space. Only specific instances can propose the minimum ballot of each instance. With this knowledge, the coordinator understands that it can select any proposed value in the minimum ballot, even if it <strong>bypasses phase1a and phase1b</strong>. Similarly, the acceptors realize they can treat any proposer's message proposing a value as if it were a ordinary phase 2a message, <strong>without the explicit requirement of receiving an "any" message</strong>.</p><h3 id="unoptimized-coordinated-collision-recovery">Unoptimized Coordinated Collision Recovery</h3><p>In Fast Paxos, the obvious way to recover from a collision is for <span class="math inline">\(c\)</span> to begin a new round, sending phase 1a messages to all acceptors, if it learns that round <span class="math inline">\(i\)</span> may not have chosen a value. Suppose the coordinator <span class="math inline">\(c\)</span> of round <span class="math inline">\(i\)</span> is also coordinator of round <span class="math inline">\(i + 1\)</span>, and that round <span class="math inline">\(i + 1\)</span> is the new one it starts. The phase 1b message that an acceptor a sends in response to <span class="math inline">\(c\)</span>'s round <span class="math inline">\(i + 1\)</span> phase 1a message does two things: it reports the current values of <span class="math inline">\(\operatorname{vrnd}(a)\)</span> and <span class="math inline">\(\operatorname{vval}(a)\)</span>, and it <strong>transmits <span class="math inline">\(a\)</span>'s promise not to cast any further vote in any round numbered less than <span class="math inline">\(i + 1\)</span></strong>. (This promise is implicit in <span class="math inline">\(a\)</span>'s setting <span class="math inline">\(\operatorname{rnd}(a)\)</span> to <span class="math inline">\(i + 1\)</span>.)</p><p>Fast Paxos introduces an optimized approach for collision recovery. However, the Explicit Prepare phase in Egalitarian Paxos starkly resembles an unrefined, straightforward method for handling collisions, which lacks optimization:</p><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-there-is-more-consensus-in-egalitarian-parliaments/the-epaxos-simplified-recovery-procedure.png" alt="" /><figcaption>Figure 3: The EPaxos simplified recovery procedure.</figcaption></figure><h4 id="does-the-acceptor-promise-to-avoid-voting-for-ballots-with-lower-ids-when-responding-to-prepare-messages">Does the Acceptor Promise to Avoid Voting for Ballots with Lower IDs When Responding to "Prepare" Messages?</h4><p><strong>Yes</strong>, the Acceptor promises not to vote for ballots with lower IDs when responding to <span class="math inline">\(Prepare\)</span> messages.</p><p>The above recovery procedure is a simplified version, and it omits a critical detail. For a more thorough and precise understanding, let's reference the TLA+ specification from <a href="https://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-111.pdf">A Proof of Correctness for Egalitarian Paxos</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs tla">ReplyPrepare(replica) ==<br>  \E msg \in sentMsg :<br>    /\ msg.type = &quot;prepare&quot;<br>    /\ msg.dst = replica<br>    /\<br>      \/ \E rec \in cmdLog[replica] :<br>        /\ rec.inst = msg.inst<br>          \* Message ==<br>          \*       ...<br>          \*  \cup [type: &#123;&quot;prepare&quot;&#125;, src: Replicas, dst: Replicas,<br>          \*        inst: Instances, ballot: Nat \X Replicas]<br>          \*  \cup ...<br>          \* When you access ballot[1], you&#x27;re referring to the first element<br>          \* of the tuple, which is a natural number as specified by Nat.<br>          \* Similarly, ballot[2] would refer to the second element of the tuple,<br>          \* which belongs to the set Replicas.<br>          \*<br>          \* The condition ensures that an acceptor will only respond to<br>          \* a prepare message if the ballot ID of the prepare message<br>          \* is greater than that of the preceding message.<br>          \* This response mechanism mirrors the phase 1b of Fast Paxos:<br>          \* If an acceptor $a$ receives a request to participate in round $i$<br>          \* and $i &gt; \operatorname&#123;rnd&#125;(a)$,<br>          \* then $a$ sets $\operatorname&#123;rnd&#125;(a)$ to $i$<br>          \* and sends coordinator $c$ a message containing the round number $i$<br>          \* and the current values of $\operatorname&#123;vrnd&#125;(a)$ and $\operatorname&#123;vval&#125;(a)$.<br>          \* If $i \le \operatorname&#123;rnd&#125;(a)$<br>          \* (so $a$ has begun round $i$ or a higher-numbered round),<br>          \* then $a$ ignores the request.<br>          /\ msg.ballot[1] &gt; rec.ballot[1]<br>          /\ sentMsg&#x27; = (sentMsg \ &#123;msg&#125;) \cup<br>              &#123;[type        |-&gt; &quot;prepare-reply&quot;,<br>                src         |-&gt; replica,<br>                dst         |-&gt; msg.src,<br>                inst        |-&gt; rec.inst,<br>                ballot      |-&gt; msg.ballot,<br>                prev_ballot |-&gt; rec.ballot,<br>                status      |-&gt; rec.status,<br>                cmd         |-&gt; rec.cmd,<br>                deps        |-&gt; rec.deps,<br>                seq         |-&gt; rec.seq]&#125;<br>          /\ cmdLog&#x27; = [cmdLog EXCEPT ![replica] = (@ \ &#123;rec&#125;) \cup<br>              &#123;[inst   |-&gt; rec.inst,<br>                status |-&gt; rec.status,<br>                ballot |-&gt; msg.ballot,<br>                cmd    |-&gt; rec.cmd,<br>                deps   |-&gt; rec.deps,<br>                seq    |-&gt; rec.seq]&#125;]<br>          /\ ...<br>      \/<br>        /\ ~(\E rec \in cmdLog[replica] : rec.inst = msg.inst)<br>        /\ sentMsg&#x27; = (sentMsg \ &#123;msg&#125;) \cup<br>            &#123;[type        |-&gt; &quot;prepare-reply&quot;,<br>              src         |-&gt; replica,<br>              dst         |-&gt; msg.src,<br>              inst        |-&gt; msg.inst,<br>              ballot      |-&gt; msg.ballot,<br>              prev_ballot |-&gt; &lt;&lt; 0, replica &gt;&gt;,<br>              status      |-&gt; &quot;not-seen&quot;,<br>              cmd         |-&gt; none,<br>              deps        |-&gt; &#123;&#125;,<br>              seq         |-&gt; 0]&#125;<br>        /\ cmdLog&#x27; = [cmdLog EXCEPT ![replica] = @ \cup<br>            &#123;[inst   |-&gt; msg.inst,<br>              status |-&gt; &quot;not-seen&quot;,<br>              ballot |-&gt; msg.ballot,<br>              cmd    |-&gt; none,<br>              deps   |-&gt; &#123;&#125;,<br>              seq    |-&gt; 0]&#125;]<br>        /\ ...<br></code></pre></td></tr></table></figure><p>The condition <code>msg.ballot[1] &gt; rec.ballot[1]</code> ensures that an acceptor will only respond to a prepare message if the ballot ID of the prepare message is greater than that of the preceding message. This response mechanism mirrors the phase 1b of Fast Paxos: If an acceptor <span class="math inline">\(a\)</span> receives a request to participate in round <span class="math inline">\(i\)</span> and <span class="math inline">\(i &gt; \operatorname{rnd}(a)\)</span>, then <span class="math inline">\(a\)</span> sets <span class="math inline">\(\operatorname{rnd}(a)\)</span> to <span class="math inline">\(i\)</span> and sends coordinator <span class="math inline">\(c\)</span> a message containing the round number <span class="math inline">\(i\)</span> and the current values of <span class="math inline">\(\operatorname{vrnd}(a)\)</span> and <span class="math inline">\(\operatorname{vval}(a)\)</span>. If <span class="math inline">\(i \le \operatorname{rnd}(a)\)</span> (so <span class="math inline">\(a\)</span> has begun round <span class="math inline">\(i\)</span> or a higher-numbered round), then <span class="math inline">\(a\)</span> ignores the request.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs tla">Phase1Reply(replica) ==<br>  \E msg \in sentMsg:<br>    /\ msg.type = &quot;pre-accept&quot;<br>    /\ msg.dst = replica<br>    /\ LET oldRec == &#123;rec \in cmdLog[replica]: rec.inst = msg.inst&#125; IN<br>      \* The condition guarantees that an acceptor will refrain from<br>      \* pre-accepting ballots if it has already prepared, pre-accepted,<br>      \* or accepted other ballots possessing a larger ID.<br>      /\ (\A rec \in oldRec :<br>          (rec.ballot = msg.ballot \/ rec.ballot[1] &lt; msg.ballot[1]))<br>      /\ LET newDeps == ...<br>             newSeq == ...<br>             instCom == ... IN<br>        /\ cmdLog&#x27; = [cmdLog EXCEPT ![replica] = (@ \ oldRec) \cup<br>            &#123;[inst   |-&gt; msg.inst,<br>              status |-&gt; &quot;pre-accepted&quot;,<br>              ballot |-&gt; msg.ballot,<br>              cmd    |-&gt; msg.cmd,<br>              deps   |-&gt; newDeps,<br>              seq    |-&gt; newSeq]&#125;]<br>        /\ sentMsg&#x27; = (sentMsg \ &#123;msg&#125;) \cup<br>            &#123;[type      |-&gt; &quot;pre-accept-reply&quot;,<br>              src       |-&gt; replica,<br>              dst       |-&gt; msg.src,<br>              inst      |-&gt; msg.inst,<br>              ballot    |-&gt; msg.ballot,<br>              deps      |-&gt; newDeps,<br>              seq       |-&gt; newSeq,<br>              committed |-&gt; instCom]&#125;<br>        /\ ...<br><br>Phase2Reply(replica) ==<br>  \E msg \in sentMsg:<br>    /\ msg.type = &quot;accept&quot;<br>    /\ msg.dst = replica<br>    /\ LET oldRec == &#123;rec \in cmdLog[replica]: rec.inst = msg.inst&#125; IN<br>      \* The condition guarantees that an acceptor will refrain from<br>      \* accepting ballots if it has already prepared, pre-accepted,<br>      \* or accepted other ballots possessing a larger ID.<br>      /\ (\A rec \in oldRec :<br>          (rec.ballot = msg.ballot \/ rec.ballot[1] &lt; msg.ballot[1]))<br>      /\ cmdLog&#x27; = [cmdLog EXCEPT ![replica] = (@ \ oldRec) \cup<br>          &#123;[inst  |-&gt; msg.inst,<br>           status |-&gt; &quot;accepted&quot;,<br>           ballot |-&gt; msg.ballot,<br>           cmd    |-&gt; msg.cmd,<br>           deps   |-&gt; msg.deps,<br>           seq    |-&gt; msg.seq]&#125;]<br>      /\ sentMsg&#x27; = (sentMsg \ &#123;msg&#125;) \cup<br>          &#123;[type   |-&gt; &quot;accept-reply&quot;,<br>            src    |-&gt; replica,<br>            dst    |-&gt; msg.src,<br>            inst   |-&gt; msg.inst,<br>            ballot |-&gt; msg.ballot]&#125;<br>      /\ ...<br></code></pre></td></tr></table></figure><p>An acceptor should abstain from initially accepting a value and then subsequently pre-accepting a different value with the same ballot ID. This behavior deviates from the Fast Paxos protocol and could potentially jeopardize the accuracy of the recovery process. EPaxos addresses this issue in a subtle manner: after receiving and processing a pre-accept message, the acceptor removes it from <code>sentMsg</code> to avoid processing it repeatedly. Furthermore, the coordinator is designed to not send pre-accept and accept messages with the same ballot ID in an unexpected order. This mechanism ensures that an acceptor will not initially accept a value and then subsequently pre-accept a different value with an identical ballot ID.</p><p>While the strategy of removing processed messages from sentMsg serves its purpose, it might be deemed as excessively complex or counter-intuitive. A more straightforward and potentially intuitive approach to achieving the same result might involve ensuring that the acceptor's status is not set to "accepted".</p><h4 id="selecting-values-based-on-observation-4">Selecting Values Based on Observation 4</h4><p>In EPaxos, it is assumed that every fast quorum includes <span class="math inline">\(2F = N - 1\)</span> replicas and every slow quorum contains <span class="math inline">\(F + 1 = \lfloor N / 2\rfloor + 1\)</span> replicas. This quorum configuration satisfies <strong>the Quorum Requirement</strong>: If <span class="math inline">\(j\)</span> is a fast round number, then any <span class="math inline">\(i\)</span>-quorum intersects with any two <span class="math inline">\(j\)</span>-quorums, as evidenced by the equation <span class="math inline">\((2F + 2F - (2F + 1)) + (F + 1) - (2F + 1) = F - 1\)</span>.</p><p>Assuming a fast quorum with <span class="math inline">\(2F\)</span> acceptors and a slow quorum with <span class="math inline">\(F + 1 = \lfloor N / 2\rfloor + 1\)</span> acceptors, the fast quorum is required to intersect with the slow quorum, containing at least <span class="math inline">\(2F + (F + 1) - (2F + 1) = F = \lfloor N / 2\rfloor\)</span> acceptors. This can also be expressed as: if there are <span class="math inline">\(2F + (F + 1) - (2F + 1) = F = \lfloor N / 2\rfloor\)</span> acceptors' replies, each containing identical values in response to <span class="math inline">\(Prepare\)</span> messages and accepted by the coordinator, then there must be at least one fast quorum and one slow quorum, the intersection of which exactly comprises these acceptors. The statements on Lines 32 and 33 of Figure 3, which describes the EPaxos simplified recovery procedure, mirrors a basic and unoptimized approach for Coordinated Collision Recovery in Fast Paxos.</p><p>The statement in Line 32, which involves value selection, mirrors Observation 4 in Fast Paxos: With <span class="math inline">\(Q\)</span>, <span class="math inline">\(vr\)</span>, <span class="math inline">\(vv\)</span>, and <span class="math inline">\(k\)</span> as in Figure 1, a value <span class="math inline">\(v\)</span> has been or might yet be chosen in round <span class="math inline">\(k\)</span> iff there <strong>exists</strong> a <span class="math inline">\(k\)</span>-quorum <span class="math inline">\(R\)</span> such that <span class="math inline">\(\operatorname{vr}(a) = k\)</span> and <span class="math inline">\(\operatorname{vv}(a) = v\)</span> for all acceptors <span class="math inline">\(a\)</span> in <span class="math inline">\(R \cap Q\)</span>.</p><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-fast-paxos/figure-1-the-coordinator-s-rule-for-picking-value-v-in-phase-2a-of-round-i.png" alt="" /><figcaption>Figure 1: The coordinator's rule for picking value in phase 2a of round <span class="math inline">\(i\)</span>.</figcaption></figure><p>The statement in Line 33, which initiates the Paxos-Accept phase, closely reflects Phase 2 in Fast Paxos. Consider a new ballot ID that includes the phase name, such as <span class="math inline">\(epoch.b.Q.prepare\)</span> and <span class="math inline">\(epoch.b.Q.accept\)</span>, with <span class="math inline">\(epoch.b.Q.accept &gt; epoch.b.Q.prepare\)</span>. Under this consideration, the EPaxos simplified recovery procedure can be viewed as corresponding to Phase 1 and Phase 2 of Fast Paxos.</p><h5 id="why-does-line-32-specifically-emphasize-the-condition-concerning-replies-for-the-default-ballot">Why does Line 32 specifically emphasize the condition concerning "replies for the default ballot"?</h5><p>Let <span class="math inline">\(\mathcal{R}\)</span> represent the set of replies associated with the highest ballot number <span class="math inline">\(i\)</span>. Firstly, I believe the authors highlight Lines 32 and 33 to address situations where the prior round <span class="math inline">\(i\)</span> is a fast round. If the previous round <span class="math inline">\(i\)</span> is a slow round, Lines 28, 30, or 34 are intended to handle it. Secondly, if Lines 35 and 37 were to send a different type of messages (such as <span class="math inline">\(TryPreaccept\)</span> messages), and reserve <span class="math inline">\(PreAccept\)</span> messages and their replies exclusively for the fast round, it appears that removing this condition would not jeopardize the correctness of EPaxos.</p><h5 id="why-does-line-32-specifically-emphasize-the-condition-concerning-none-of-those-replies-is-from-l">Why does Line 32 specifically emphasize the condition concerning "none of those replies is from <span class="math inline">\(L\)</span>"?</h5><p><a href="https://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-111.pdf">A Proof of Correctness for Egalitarian Paxos</a> provides an answer:</p><blockquote><p>Since <span class="math inline">\(b_1\)</span> is successful after Phase 1 , then a fast quorum (<span class="math inline">\(N - 1\)</span> replicas) have recorded the same tuple <span class="math inline">\(\left(\gamma, \text{seq}_\gamma, \text{deps}_\gamma\right)\)</span> for instance <span class="math inline">\(Q.i\)</span>. For <span class="math inline">\(b_2\)</span> to start, its leader must receive replies to Prepare messages from at least <span class="math inline">\(\lfloor N / 2\rfloor + 1\)</span> replicas. Therefore, at least <span class="math inline">\(\lfloor N / 2\rfloor\)</span> replicas will see a Prepare for <span class="math inline">\(b_2\)</span> after they have recorded <span class="math inline">\(\left(\gamma, \text{seq}_\gamma, \text{deps}_\gamma\right)\)</span> for ballot <span class="math inline">\(b_1\)</span> (if they had seen the larger ballot <span class="math inline">\(b_2\)</span> first, they would not have acknowledged any message for ballot <span class="math inline">\(b_1\)</span>). <span class="math inline">\(b_2\)</span>'s leader will therefore receive at least <span class="math inline">\(\lfloor N / 2\rfloor\)</span> <span class="math inline">\(PrepareReply\)</span>'s with tuple <span class="math inline">\(\left(\gamma, \text{seq}_\gamma, \text{deps}_\gamma\right)\)</span> marked as pre-accepted.</p><p>If the leader of <span class="math inline">\(b_1\)</span> is among the replicas that reply to the Prepare of ballot <span class="math inline">\(b_2\)</span>, then it <strong>must</strong> have replied after the end of Phase 1 (otherwise it couldn't have completed the smaller ballot <span class="math inline">\(b_1\)</span>), so it will have committed tuple <span class="math inline">\(\left(\gamma, \text{seq}_\gamma, \text{deps}_\gamma\right)\)</span> by then. The leader of <span class="math inline">\(b_2\)</span> will then know it is safe to commit the same tuple.</p><p>Below, we assume that the leader of <span class="math inline">\(b_1\)</span> is not among the replicas that reply to the Prepare of ballot <span class="math inline">\(b_2\)</span>.</p></blockquote><p>Pay attention to the use of <strong>must</strong>. The author clarifies that under EPaxos protocol, the leader <strong>should refrain from</strong> replying to <span class="math inline">\(Prepare\)</span> messages <strong>until</strong> the commitment in the fast round is finalized. Thus, if the leader in <span class="math inline">\(b_2\)</span> receives a response to the <span class="math inline">\(Prepare\)</span> message, the response must contain the committed state. This situation will be addressed by lines 28 and 29. Therefore, eliminating the condition related to "none of those replies is from <span class="math inline">\(L\)</span>" will not jeopardize the correctness of the EPaxos protocol.</p><h4 id="selecting-values-based-on-the-presence-of-an-accepted-reply-message">Selecting Values Based on the Presence of an "Accepted" Reply Message</h4><p>Let <span class="math inline">\(\mathcal{R}\)</span> represent the set of replies associated with the highest ballot number <span class="math inline">\(i\)</span>. Suppose <span class="math inline">\(\mathcal{R}\)</span> contains a reply from an acceptor indicating that it has accepted the value <span class="math inline">\(v\)</span> during Phase 2 (Paxos-Accept). Given that the ballot with the highest number <span class="math inline">\(i\)</span> corresponds to a slow round (analogous to the slow path in EPaxos), we can infer that the coordinator proposed the specific value <span class="math inline">\(v\)</span> by sending phase2a messages. Consequently, the acceptors selected <span class="math inline">\(v\)</span> in response to these phase2a messages during the slow round <span class="math inline">\(i\)</span>. We can then conclude that all acceptors either accepted nothing or accepted <span class="math inline">\(v\)</span> only. Therefore, either no value was committed during that slow round, or the specific value <span class="math inline">\(v\)</span> was committed. As a result, <span class="math inline">\(v\)</span> can be selected as the value for a new round with a ballot ID higher than <span class="math inline">\(i\)</span>.</p><p>In fact, I believe that enabling the coordinator to propose the value <span class="math inline">\(v\)</span> directly, upon learning that it has been accepted in a slow round with a lower ballot ID, could be a viable optimization for Fast Paxos. I plan to modify the TLA+ specification of Fast Paxos to incorporate this change and then verify it.</p><p>The key part of this optimization is enabling the acceptor to distinguish whether it has accepted the value <span class="math inline">\(v\)</span> in a fast round or a slow round. EPaxos effectively illustrates this approach by differentiating these cases using a "status" field (pre-accepted", "accepted").</p><h4 id="selecting-values-based-on-the-presence-of-an-committed-reply-message">Selecting Values Based on the Presence of an "Committed" Reply Message</h4><p>In <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>, Theorem 1 establishes that any two successful ballots are for the same decree. Upon encountering a "Committed" reply message, we can deduce that the value <span class="math inline">\(v\)</span> is committed. Given the assurance of Theorem 1, no other value has been, or will be, committed. Thus, it's safe to commit the value <span class="math inline">\(v\)</span> once more.</p><h3 id="optimized-coordinated-collision-recovery">Optimized Coordinated Collision Recovery</h3><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-there-is-more-consensus-in-egalitarian-parliaments/the-basic-egalitarian-paxos-protocol-for-choosing-commands.png" alt="" /><figcaption>Figure 2: The basic Egalitarian Paxos protocol for choosing commands.</figcaption></figure><p>In Fast Paxos, the author introduces an observation: In other words, <span class="math inline">\(a\)</span>'s round <span class="math inline">\(i\)</span> phase 2b message <strong>carries exactly the same information as</strong> its round <span class="math inline">\(i + 1\)</span> phase 1b message. Specifically, both messages accomplish two key tasks: they report the current values of <span class="math inline">\(\operatorname{vrnd}(a)\)</span> and <span class="math inline">\(\operatorname{vval}(a)\)</span>, and they <strong>transmit <span class="math inline">\(a\)</span>'s promise not to cast any further vote in any round numbered less than <span class="math inline">\(i + 1\)</span></strong>. This observation leads to the optimized coordinated collision recovery. EPaxos also employs the same optimized coordinated collision recovery approach, which corresponds to the segment between the two yellow-highlighted sections in the above figure, labeled as "Figure 2: The Basic Egalitarian Paxos Protocol for Choosing Commands".</p><p>It's important to note that in the Paxos-Accept phase, the command leader <span class="math inline">\(L\)</span> always sends an <span class="math inline">\(\operatorname{AcceptOK}(\gamma, L.i)\)</span> "reply" to itself, as demonstrated in line 16. Consequently, the command leader <span class="math inline">\(L\)</span> can proceed to the commit phase after receiving only <span class="math inline">\(\lfloor N / 2\rfloor\)</span> <span class="math inline">\(\operatorname{AcceptOK}\)</span> messages, rather than needing to wait for <span class="math inline">\(\lfloor N / 2\rfloor + 1\)</span>.</p><h3 id="overlooked-details">Overlooked Details</h3><h4 id="a-closer-look-at-ballot-numbers-and-instance-numbers">A Closer Look at Ballot Numbers and Instance Numbers</h4><p>For correctness, ballot numbers used by different replicas must be distinct, so they include a replica ID. Actually, the uniqueness of ballot numbers originates from the <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span> condition in <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>. Furthermore, a newer configuration of the replica set must have strict precedence over an older one, so we also prepend an epoch number. The resulting ballot number format is <span class="math inline">\(epoch.b.R\)</span>, where a replica <span class="math inline">\(R\)</span> increments only the natural number <span class="math inline">\(b\)</span> when trying to initiate a new ballot in Explicit Prepare. Each replica is the default (i.e., initial) leader of its own instances, so the ballot <span class="math inline">\(epoch.0.R\)</span> is implicit at the beginning of every instance <span class="math inline">\(R.i\)</span>.</p><p>For every replica <span class="math inline">\(R\)</span> there is an unbounded sequence of numbered instances <span class="math inline">\(R.1\)</span>, <span class="math inline">\(R.2\)</span>, <span class="math inline">\(R.3\)</span>, ... that that replica is said to <strong>own</strong>.</p><h4 id="understanding-the-lack-of-transitivity-in-interference-relations">Understanding the Lack of Transitivity in Interference Relations</h4><p>Two commands <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\delta\)</span> interfere if there exists a sequence of commands <span class="math inline">\(\Sigma\)</span> such that the serial execution <span class="math inline">\(\Sigma, \gamma, \delta\)</span> is not compatible (i.e., it produces different results than) the serial execution <span class="math inline">\(\Sigma, \delta, \gamma\)</span>.</p><p>EPaxos guarantees that any two interfering commands will be executed in the same order with respect to each other on every replica. This is enough to guarantee that the executions on all replicas are compatible: the serial ordering of commands on a replica can be obtained from that on any other replica by commuting <strong>commutative</strong> commands.</p><p>Note that the interference relation is symmetric, but <strong>not necessarily transitive</strong>.</p><p>While the authors of EPaxos propose that the interference relation need not be transitive, I argue that this assumption lacks practical utility in real-world systems and is, in fact, counter-intuitive. It appears the authors intended to simplify the process of demonstrating execution consistency, defined as the principle where two interfering commands, <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\delta\)</span>, when successfully committed (not necessarily by the same replica), are executed in the same order by every replica. The partial proof for execution consistency, specifically within the realm of the commit protocol, is laid out as follows:</p><ul><li>The attributes with which a command <span class="math inline">\(c\)</span> is committed are the union of at least <span class="math inline">\(\lfloor N / 2\rfloor + 1\)</span> sets of attributes computed by as many replicas. This ensures that there is at least one replica <span class="math inline">\(R\)</span> that contributes to both the final attributes of <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\delta\)</span>.</li><li>Because <span class="math inline">\(R\)</span> records every command that it sees in its command log, and because <span class="math inline">\(\gamma \sim \delta\)</span>, <span class="math inline">\(R\)</span> will include the command it sees first in the dependency list of the command it sees second. In other words, if <span class="math inline">\(\gamma\)</span> and <span class="math inline">\(\delta\)</span> are successfully committed and <span class="math inline">\(\gamma \sim \delta\)</span>, then either <span class="math inline">\(\gamma\)</span> has <span class="math inline">\(\delta\)</span> in its dependency list when <span class="math inline">\(\gamma\)</span> is committed, or <span class="math inline">\(\delta\)</span> has <span class="math inline">\(\gamma\)</span> in its dependency list when <span class="math inline">\(\delta\)</span> is committed.</li></ul><h4 id="calculation-of-fast-quorum-and-slow-quorum-sizes">Calculation of Fast Quorum and Slow Quorum Sizes</h4><p>Let's denote the fast quorum size as <span class="math inline">\(F\)</span>, the slow quorum size as <span class="math inline">\(S\)</span>, and the replicas size as <span class="math inline">\(N\)</span>. In accordance with the Quorum Requirement, we must ensure that <span class="math inline">\(((F + F) - N) + S - N \ge 1\)</span>. Additionally, the <span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span> condition dictates that <span class="math inline">\(S + S - N \ge 1\)</span>. From these conditions, we can easily compute the minimum value for <span class="math inline">\(S\)</span> as <span class="math inline">\(S = \lfloor N / 2\rfloor + 1\)</span>. Similarly, the minimum value for <span class="math inline">\(F\)</span> can be determined as <span class="math inline">\(F = \lceil 3 N / 4\rceil\)</span>.</p><h2 id="the-execution-algorithm">The Execution Algorithm</h2><p>To execute command <span class="math inline">\(\gamma\)</span> committed in instance <span class="math inline">\(R.i\)</span>, a replica will follow these steps:</p><ul><li>Wait for <span class="math inline">\(R.i\)</span> to be committed (or run Explicit Prepare to force it);</li><li>Build <span class="math inline">\(\gamma\)</span>'s dependency graph by adding <span class="math inline">\(\gamma\)</span> and all commands in instances from <span class="math inline">\(\gamma\)</span>'s dependency list as nodes, with directed edges from <span class="math inline">\(\gamma\)</span> to these nodes, repeating this process recursively for all of <span class="math inline">\(\gamma\)</span>'s dependencies (starting with step 1);</li><li>Find the strongly connected components, sort them topologically;</li><li>In inverse topological order, for each strongly connected component, do:<ul><li>Sort all commands in the strongly connected component by their sequence number;</li><li>Execute every un-executed command in increasing sequence number order, marking them executed.</li></ul></li></ul><h2 id="reference">Reference</h2><ul><li><a href="https://www.cs.cmu.edu/~dga/papers/epaxos-sosp2013.pdf">There Is More Consensus in Egalitarian Parliaments</a></li><li><a href="https://www.pdl.cmu.edu/PDL-FTP/associated/CMU-PDL-13-111.pdf">A Proof of Correctness for Egalitarian Paxos</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li><li><a href="http://drmingdrmer.github.io/">drdr.xp</a></li><li><a href="https://zhuanlan.zhihu.com/p/387468959">EPaxos Trilogy II: EPaxos Core Protocol Process</a></li><li><a href="https://github.com/alexis51151/epaxos-fix/tree/master">GitHub: alexis51151/epaxos-fix</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Consensus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - Fast Paxos</title>
    <link href="/2023/07/30/computer-science/consensus/paper-interpretation-fast-paxos/"/>
    <url>/2023/07/30/computer-science/consensus/paper-interpretation-fast-paxos/</url>
    
    <content type="html"><![CDATA[<h2 id="the-classic-paxos-algorithm">The Classic Paxos Algorithm</h2><p>I have gained an understanding of the classic Paxos algorithm through <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a>. However, the terminology used in this paper differs from that of the current document. To simplify the transition and ensure clarity, I have created a table that aligns the terminologies from both resources.</p><table><thead><tr class="header"><th style="text-align: left;">The Part-Time Parliament</th><th style="text-align: left;">Fast Paxos</th><th style="text-align: left;">Explanation of Terminology in Fast Paxos</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">ballot</td><td style="text-align: left;">round</td><td style="text-align: left;">Different values are not chosen in different rounds.</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{nextBal}(p)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{rnd}(a)\)</span></td><td style="text-align: left;">The highest-numbered round in which acceptor <span class="math inline">\(a\)</span> has participated.</td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\({\operatorname{prevVote}(p)}_{bal}\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{vrnd}(a)\)</span></td><td style="text-align: left;">The highest-numbered round in which acceptor <span class="math inline">\(a\)</span> has cast a vote.</td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\({\operatorname{prevVote}(p)}_{dec}\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{vval}(a)\)</span></td><td style="text-align: left;">The value acceptor <span class="math inline">\(a\)</span> voted to accept in round <span class="math inline">\(\operatorname{vrnd}(a)\)</span>.</td></tr><tr class="odd"><td style="text-align: left;"><span class="math inline">\(\operatorname{lastTried}(p)\)</span></td><td style="text-align: left;"><span class="math inline">\(\operatorname{crnd}(c)\)</span></td><td style="text-align: left;">The highest-numbered round that coordinator <span class="math inline">\(c\)</span> has begun.</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"><span class="math inline">\(\operatorname{cval}(c)\)</span></td><td style="text-align: left;">The value that coordinator <span class="math inline">\(c\)</span> has picked for round <span class="math inline">\(\operatorname{crnd}(c)\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">Step 1 of the Basic Protocol</td><td style="text-align: left;">phase 1a</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{NextBallot}(b)\)</span></td><td style="text-align: left;"></td><td style="text-align: left;">Sends a message to each acceptor <span class="math inline">\(a\)</span> requesting that <span class="math inline">\(a\)</span> participate in round i.</td></tr><tr class="odd"><td style="text-align: left;">Step 2 of the Basic Protocol</td><td style="text-align: left;">phase 1b</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{LastVote}(b, v)\)</span></td><td style="text-align: left;">phase 1b message</td><td style="text-align: left;">Sends coordinator <span class="math inline">\(c\)</span> a message containing the round number <span class="math inline">\(i\)</span> and the current values of <span class="math inline">\(\operatorname{vrnd}(a)\)</span> and <span class="math inline">\(\operatorname{vval}(a)\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">Step 3 of the Basic Protocol</td><td style="text-align: left;">phase 2a</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span></td><td style="text-align: left;">phase 2a message</td><td style="text-align: left;">Sends a message to the acceptors requesting that they vote in round <span class="math inline">\(i\)</span> to accept <span class="math inline">\(v\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">Step 4 of the Basic Protocol</td><td style="text-align: left;">phase 2b</td><td style="text-align: left;"></td></tr><tr class="even"><td style="text-align: left;"><span class="math inline">\(\operatorname{Voted}(b, q)\)</span></td><td style="text-align: left;">phase 2b message</td><td style="text-align: left;">Sends a message to all learners announcing its round <span class="math inline">\(i\)</span> vote.</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">CP</td><td style="text-align: left;">For any rounds <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> with <span class="math inline">\(j &lt; i\)</span>,if a value <span class="math inline">\(v\)</span> has been chosen or might yet be chosen in round <span class="math inline">\(j\)</span>, then no acceptor can vote for any value except <span class="math inline">\(v\)</span> in round <span class="math inline">\(i\)</span>.</td></tr><tr class="even"><td style="text-align: left;">Theorem 1 in the "A Formal Statement of Three Conditions" section</td><td style="text-align: left;"></td><td style="text-align: left;">CP implies that if <span class="math inline">\(j &lt; i\)</span>, then no value other than <span class="math inline">\(v\)</span> can ever be chosen in round <span class="math inline">\(i\)</span> if <span class="math inline">\(v\)</span> is chosen in round <span class="math inline">\(j\)</span>.</td></tr></tbody></table><p>This paper divides the role of priests, as described in "The Part-Time Parliament," into three distinct roles: coordinators, acceptors, and learners. In this restructured model, a learner is said to learn a value <span class="math inline">\(v\)</span> if, for some round <span class="math inline">\(i\)</span>, it receives phase 2b messages from a majority of acceptors announcing that they have all voted for <span class="math inline">\(v\)</span> in round <span class="math inline">\(i\)</span>. The paper also maintains the role of the president, now referred to as the leader, who is essentially a special coordinator.</p><p>This paper also introduces the role of proposers. Proposers send their proposals to the coordinators. The coordinator for round <span class="math inline">\(i\)</span> picks a value that it tries to get chosen in that round.</p><p>A single process can play multiple roles. For example, in a client/server system, a client might play the roles of proposer and learner, and a server might play the roles of acceptor and learner.</p><h2 id="picking-a-value-in-phase-2a">Picking a Value in Phase 2a</h2><p>"The Part-Time Parliament" establishes the safety of the Synod protocol given conditions <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span>, <span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span>, and <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span>. However, this doesn't fully elucidate the safety of Fast Paxos, particularly when dealing with the complexities arising from the protocol's variations. "Fast Paxos" employs a different approach: it starts with the safety requirements and the scenario where phase 2a messages, requesting acceptance of different values, can be sent in different rounds. From this, it deduces the method to select a value in phase 2a. Through this perspective, we can comprehend how to respond to the variations involved in fast rounds. Additionally, I've found that the proof process is much more comprehensible than the one outlined in "The Part-Time Parliament".</p><p>We define a value <span class="math inline">\(v\)</span> as chosen in round <span class="math inline">\(j\)</span> if a majority of acceptors accept it in round <span class="math inline">\(j\)</span>. Our goal is to validate Theorem 1 from "The Part-Time Parliament," which states that any two chosen values must be the same. Given that any accepted values must have previously been proposed, we can prove Theorem 1 by demonstrating a more stringent property, CP: For any rounds <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> with <span class="math inline">\(j &lt; i\)</span>, if a value <span class="math inline">\(v\)</span> has been chosen or might yet be chosen in round <span class="math inline">\(j\)</span>, then no acceptor can vote for any value except <span class="math inline">\(v\)</span> in round <span class="math inline">\(i\)</span>.</p><p>A useful equivalent to CP that further facilitates the deduction is: For any rounds <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span> with <span class="math inline">\(j &lt; i\)</span>, if an acceptor has voted for <span class="math inline">\(v\)</span> in round <span class="math inline">\(i\)</span>, then no value other than <span class="math inline">\(v\)</span> has been or might yet be chosen in round <span class="math inline">\(j\)</span>.</p><p>For a specific round <span class="math inline">\(i\)</span> and its corresponding value <span class="math inline">\(v\)</span>, <span class="math inline">\(v\)</span> should fulfill a particular CP property, denoted as <span class="math inline">\(\operatorname{CP}(v, i)\)</span>: For any round <span class="math inline">\(j &lt; i\)</span>, no value other than <span class="math inline">\(v\)</span> has been or might yet be chosen in round <span class="math inline">\(j\)</span>.</p><p>A useful insight, termed Observation 3, assists in fulfilling <span class="math inline">\(\operatorname{CP}(v, i)\)</span>: If there is a majority set <span class="math inline">\(Q\)</span> and a value <span class="math inline">\(v\)</span> such that every acceptor <span class="math inline">\(a\)</span> in <span class="math inline">\(Q\)</span> has <span class="math inline">\(\operatorname{rnd}(a) &gt; j\)</span> and has either voted for <span class="math inline">\(v\)</span> in round <span class="math inline">\(j\)</span> or has not voted in round <span class="math inline">\(j\)</span>, then no value other than <span class="math inline">\(v\)</span> has been or ever might be chosen in round <span class="math inline">\(j\)</span>. This is quite intuitive. Let's assume there is a different value <span class="math inline">\(v&#39;\)</span> (<span class="math inline">\(v&#39; \neq v\)</span>), and some coordinators attempt to have a majority of acceptors accept it in round <span class="math inline">\(j\)</span>. However, each acceptor in <span class="math inline">\(Q\)</span> won't accept it either because <span class="math inline">\(\operatorname{rnd}(a) &gt; j\)</span>, or because <span class="math inline">\(a\)</span> has already accepted <span class="math inline">\(v\)</span> (the enabling condition for the phase 2a action and the unique assignment of rounds to coordinators ensure that phase 2a messages with different values cannot be sent for the same round). Hence, there doesn't exist a majority set <span class="math inline">\(Q&#39;\)</span> in which every acceptor <span class="math inline">\(a&#39;\)</span> has accepted or might accept <span class="math inline">\(v&#39;\)</span> in round <span class="math inline">\(j\)</span> (It is not possible to find two majority subsets that do not intersect).</p><p>Suppose the coordinator has received round <span class="math inline">\(i\)</span> phase 1b messages from a majority <span class="math inline">\(Q\)</span> of acceptors. Since an acceptor <span class="math inline">\(a\)</span> sets <span class="math inline">\(\operatorname{rnd}(a)\)</span> to <span class="math inline">\(i\)</span> upon sending <span class="math inline">\(a\)</span> round <span class="math inline">\(i\)</span> phase 1b message and it never decreases <span class="math inline">\(\operatorname{rnd}(a)\)</span>, the current value of <span class="math inline">\(\operatorname{rnd}(a)\)</span> satisfies <span class="math inline">\(\operatorname{rnd}(a) \ge i\)</span> for all <span class="math inline">\(a\)</span> in <span class="math inline">\(Q\)</span>. Let <span class="math inline">\(\operatorname{vr}(a)\)</span> and <span class="math inline">\(\operatorname{vv}(a)\)</span> be the values of <span class="math inline">\(\operatorname{vrnd}(a)\)</span> and <span class="math inline">\(\operatorname{vval}(a)\)</span>, respectively, reported by acceptor <span class="math inline">\(a\)</span>'s round <span class="math inline">\(i\)</span> phase 1b message, for <span class="math inline">\(a\)</span> in <span class="math inline">\(Q\)</span>. Let <span class="math inline">\(k\)</span> be the largest value of <span class="math inline">\(\operatorname{vr}(a)\)</span> for all acceptors <span class="math inline">\(a\)</span> in <span class="math inline">\(Q\)</span>. We now consider separately the two possible cases:</p><ul><li>K1. <span class="math inline">\(k = 0\)</span>. <span class="math inline">\(\operatorname{CP}(v, i)\)</span> is satisfied regardless of what value <span class="math inline">\(v\)</span> the coordinator picks.</li><li>K2. <span class="math inline">\(k &gt; 0\)</span>. Because <span class="math inline">\(\operatorname{vrnd}(a) \le \operatorname{rnd}(a)\)</span> and acceptor <span class="math inline">\(a\)</span> responds to a round <span class="math inline">\(i\)</span> message only if <span class="math inline">\(i &gt; \operatorname{rnd}(a)\)</span>, we must have <span class="math inline">\(k &lt; i\)</span>. Then we aim to prove <span class="math inline">\(\operatorname{CP}(v, i)\)</span> (for any round <span class="math inline">\(j &lt; i\)</span>, no value other than <span class="math inline">\(v\)</span> has been or can still be chosen in round <span class="math inline">\(j\)</span>) by employing a classification approach.<ul><li><span class="math inline">\(j &lt; k\)</span>: We can assume, through <strong>induction</strong>, that property CP holds. Consequently, no value other than the one proposed in round <span class="math inline">\(k\)</span> has been or can be chosen in round <span class="math inline">\(j\)</span>. Therefore, if we establish that <span class="math inline">\(\operatorname{CP}(v, i)\)</span> holds for round <span class="math inline">\(k\)</span>, it will also hold for round <span class="math inline">\(j\)</span>.</li><li><span class="math inline">\(j = k\)</span>: By Observation 3.</li><li><span class="math inline">\(j &gt; k \land j &lt; i\)</span>: Let <span class="math inline">\(a\)</span> be any acceptor in <span class="math inline">\(Q\)</span>. Because <span class="math inline">\(\operatorname{vr}(a)\)</span> is the largest round number in which <span class="math inline">\(a\)</span> had cast a vote when it sent that message and <span class="math inline">\(\operatorname{vr}(a) \le k \lt j\)</span>, acceptor <span class="math inline">\(a\)</span> had at that time not voted in round <span class="math inline">\(j\)</span>. Thus no value has been or might yet be chosen in round <span class="math inline">\(j\)</span> (It is not possible to find two majority subsets that do not intersect).</li></ul></li></ul><h2 id="making-paxos-fast">Making Paxos Fast</h2><p>The normal-case communication pattern in the classic Paxos consensus algorithm is: proposer -&gt; leader -&gt; acceptors -&gt; learners. In Fast Paxos, the proposer sends its proposal directly to the acceptors, bypassing the leader. This can save one message delay (and one message).</p><p>In Fast Paxos, round numbers are partitioned into fast and classic round numbers. A round is said to be either fast or classic, depending on its number. Rounds proceed in two phases, just as before, except with two differences:</p><ul><li>The rule by which the coordinator picks a value in phase 2a is modified as explained below.</li><li>In a fast round <span class="math inline">\(i\)</span>, if the coordinator can pick any proposed value in phase 2a, then instead of picking a single value, it may instead send a special phase 2a message called an <strong>any</strong> message to the acceptors. When an acceptor receives a phase 2a <strong>any</strong> message, it may treat <strong>any proposer's message</strong> proposing a value as if it were an ordinary round <span class="math inline">\(i\)</span> phase 2a message with that value. (However, it may execute its round <span class="math inline">\(i\)</span> phase 2b action <strong>only once</strong>, for a <strong>single</strong> value.)</li></ul><h3 id="maintaining-cp-after-involving-fast-rounds">Maintaining CP after Involving Fast Rounds</h3><p>In a fast round, proposers send their proposals directly to the acceptors, bypassing the leader. Each acceptor independently decides what proposal message to take as a phase 2a message. Different acceptors can therefore vote to accept different values within the same round.</p><p>Consequently, Observation 3 no longer holds true. It's plausible for different phase 2a messages in the same round <span class="math inline">\(i\)</span> to contain the same <span class="math inline">\(\operatorname{vr}(a)\)</span>, which is <span class="math inline">\(k\)</span> (where <span class="math inline">\(k\)</span> is the highest value of <span class="math inline">\(\operatorname{vr}(a)\)</span> for all acceptors <span class="math inline">\(a\)</span> in <span class="math inline">\(Q\)</span>), but have different values for <span class="math inline">\(\operatorname{vv}(a_1) = v_1\)</span> and <span class="math inline">\(\operatorname{vv}(a_2) = v_2\)</span>. In this scenario, we would still want property <span class="math inline">\(\operatorname{CP}(v, i)\)</span> to hold true.</p><p>The coordinator's rule for picking a value in phase 2a no longer guarantees consistency, even for a classic round. Consider a situation where a classic round (with a higher id) occurs "after" a fast round (with a lower id). The leader can propose value <span class="math inline">\(v\)</span> in round <span class="math inline">\(i\)</span> while maintaining property <span class="math inline">\(\operatorname{CP}(v, i)\)</span> if and only if one of the following conditions is met:</p><ul><li>The leader knows that a majority of acceptors voted for value <span class="math inline">\(v\)</span> in round <span class="math inline">\(k\)</span>.</li><li>Even if all other acceptors with unknown states vote for a value different from <span class="math inline">\(v\)</span> (for instance, the second majority value <span class="math inline">\(v&#39;\)</span> voted by <span class="math inline">\(\operatorname{vr}(a)\)</span> for <span class="math inline">\(a\)</span> in <span class="math inline">\(Q\)</span>), value <span class="math inline">\(v&#39;\)</span> cannot be chosen.</li></ul><h3 id="employing-quorum-based-approach-in-place-of-majority-sets">Employing Quorum-Based Approach in Place of Majority Sets</h3><p>In a system with <span class="math inline">\(2 * n + 1\)</span> acceptors, suppose <span class="math inline">\(n\)</span> acceptors reply with the phase 2a message with <span class="math inline">\(\operatorname{vv}(a) = k\)</span> and <span class="math inline">\(\operatorname{vr}(a) = v_1\)</span>, and <span class="math inline">\(n\)</span> acceptors reply with the phase 2a message with <span class="math inline">\(\operatorname{vv}(a) = k\)</span> and <span class="math inline">\(\operatorname{vr}(a) = v_2\)</span> where <span class="math inline">\(v_2 \neq v_1\)</span>. In this case, round <span class="math inline">\(i\)</span> must stall and propose nothing. Otherwise, it is highly likely that property <span class="math inline">\(\operatorname{CP}(v, i)\)</span> would be violated: if the leader proposes <span class="math inline">\(v_1\)</span> and the unknown acceptor actually accepts <span class="math inline">\(v_2\)</span>, or vice versa.</p><p>The example above illustrates that in the worst case, if even a single acceptor out of <span class="math inline">\(2 * n + 1\)</span> is down, a classic round cannot propose anything. This indicates that Paxos loses fault tolerance under certain circumstances, which is unacceptable. Therefore, it is necessary to generalize the algorithm as follows and continue our discussion based on this generalization: The Paxos algorithm is stated above in terms of majority sets, where a majority set comprises a majority of the acceptors. The only property required of majority sets is that any two majority sets have non-empty intersection. The algorithm trivially generalizes by assuming an arbitrary collection of sets called quorums such that any two quorums have non-empty intersection, and simply replacing "majority set" by "quorum".</p><h3 id="observation-4">Observation 4</h3><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-fast-paxos/figure-1-the-coordinator-s-rule-for-picking-value-v-in-phase-2a-of-round-i.png" alt="" /><figcaption>Figure 1: The coordinator's rule for picking value <span class="math inline">\(v\)</span> in phase 2a of round <span class="math inline">\(i\)</span>.</figcaption></figure><p>With <span class="math inline">\(Q\)</span>, <span class="math inline">\(vr\)</span>, <span class="math inline">\(vv\)</span>, and <span class="math inline">\(k\)</span> as in Figure 1, a value <span class="math inline">\(v\)</span> has been or might yet be chosen in round <span class="math inline">\(k\)</span> iff there <strong>exists</strong> a <span class="math inline">\(k\)</span>-quorum <span class="math inline">\(R\)</span> such that <span class="math inline">\(\operatorname{vr}(a) = k\)</span> and <span class="math inline">\(\operatorname{vv}(a) = v\)</span> for all acceptors <span class="math inline">\(a\)</span> in <span class="math inline">\(R \cap Q\)</span>.</p><p>I seem to have a misunderstanding about Observation 4. To clarify, let's consider a specific example. Consider a scenario where there's only one <span class="math inline">\(k\)</span>-quorum, <span class="math inline">\(R = \{a_0, a_1, a_2\}\)</span>, and <span class="math inline">\(Q = \{a_0, a_1, a_2\}\)</span> represents any quorum of acceptors that have sent round <span class="math inline">\(i\)</span> phase 1b messages. If <span class="math inline">\(a_0\)</span> has voted for <span class="math inline">\(x\)</span> and <span class="math inline">\(a_1\)</span> has voted for <span class="math inline">\(y\)</span> (where <span class="math inline">\(x \neq y\)</span>) in round <span class="math inline">\(k\)</span>, then not all acceptors <span class="math inline">\(a\)</span> in <span class="math inline">\(R \cap Q\)</span> have voted for either <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span>. Given this, and considering that <span class="math inline">\(R\)</span> is the only <span class="math inline">\(k\)</span>-quorum in round <span class="math inline">\(k\)</span>, there doesn't appear to be a value <span class="math inline">\(v\)</span> in <span class="math inline">\(V\)</span> that satisfies <span class="math inline">\(\operatorname{O4}(v)\)</span>.</p><p>Observation 4 asserts that <span class="math inline">\(v\)</span> has been or might be chosen in round <span class="math inline">\(k\)</span> only if <span class="math inline">\(\operatorname{O4}(v)\)</span> is true. There are three cases to consider:</p><ul><li>If no <span class="math inline">\(v\)</span> in <span class="math inline">\(V\)</span> satisfying <span class="math inline">\(\operatorname{O4}(v)\)</span>.<ul><li>It implies that for every <span class="math inline">\(k\)</span>-quorum, namely <span class="math inline">\(R_0\)</span>, <span class="math inline">\(R_1\)</span>, ..., <span class="math inline">\(R_n\)</span>, one of the following cases must hold:<ul><li>At least one acceptor in <span class="math inline">\(Q \cap R_m\)</span> has neither voted nor will vote for any values in the future.</li><li>The acceptors in <span class="math inline">\(Q \cap R_m\)</span> have already voted for more than one value.</li></ul></li><li>From this, it's straightforward to infer, <span class="math inline">\(R_0\)</span>, <span class="math inline">\(R_1\)</span>, ..., <span class="math inline">\(R_n\)</span> have not chosen or will not choose any value in round <span class="math inline">\(k\)</span>.</li></ul></li><li>There is a single <span class="math inline">\(v\)</span> in <span class="math inline">\(V\)</span> satisfying <span class="math inline">\(\operatorname{O4}(v)\)</span>.<ul><li>This scenario suggests that for every <span class="math inline">\(k\)</span>-quorum, such as <span class="math inline">\(R_0\)</span>, <span class="math inline">\(R_1\)</span>, ..., <span class="math inline">\(R_n\)</span>, one of the following cases must hold:<ul><li>At least one acceptor in <span class="math inline">\(Q \cap R_m\)</span> has not voted and will not vote for any value in the future.</li><li>The acceptors in <span class="math inline">\(Q \cap R_m\)</span> have voted for more than one value.</li><li>All the acceptors in <span class="math inline">\(Q \cap R_m\)</span> have voted for the value <span class="math inline">\(v\)</span>.</li></ul></li><li>Then for each <span class="math inline">\(k\)</span>-quorum, such as <span class="math inline">\(R_0\)</span>, <span class="math inline">\(R_1\)</span>, ..., <span class="math inline">\(R_n\)</span>, one of the following cases must hold:<ul><li>At least one acceptor in <span class="math inline">\(R_m\)</span> has not voted and will not vote for any value in the future.</li><li>The acceptors in <span class="math inline">\(R_m\)</span> have voted for more than one value.</li><li>All the acceptors in <span class="math inline">\(R_m\)</span> have voted for the value <span class="math inline">\(v\)</span>.</li><li>The acceptors in <span class="math inline">\(R_m\)</span> have voted for more than one value, one of which is <span class="math inline">\(v\)</span>.</li></ul></li><li>Therefore, it's reasonable to deduce that <span class="math inline">\(R_0\)</span>, <span class="math inline">\(R_1\)</span>, ..., <span class="math inline">\(R_n\)</span> have chosen or might choose nothing other than <span class="math inline">\(v\)</span>.</li></ul></li><li>There is more than one <span class="math inline">\(v\)</span> in <span class="math inline">\(V\)</span> satisfying <span class="math inline">\(\operatorname{O4}(v)\)</span>. In this case we are stuck.</li></ul><p>The solution to the dilemma of case 3 is to make that case impossible. We make case 3 impossible by the <strong>Quorum Requirement</strong>. For any round numbers <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>:</p><ul><li>Any <span class="math inline">\(i\)</span>-quorum and any <span class="math inline">\(j\)</span>-quorum have non-empty intersection.</li><li>If <span class="math inline">\(j\)</span> is a fast round number, then any <span class="math inline">\(i\)</span>-quorum and any two <span class="math inline">\(j\)</span>-quorums have non-empty intersection.</li></ul><p>Understanding why the Quorum Requirement prevents case 3 can be somewhat complex. Let's simplify it with an easy-to-grasp example. Consider five acceptors, <span class="math inline">\(a_1\)</span>, ..., <span class="math inline">\(a_5\)</span>. Let's set <span class="math inline">\(Q = {a_1, a_2, a_3}\)</span>, <span class="math inline">\(R_1 = {a_1, a_2, a_4}\)</span>, and <span class="math inline">\(R_2 = {a_3, a_4, a_5}\)</span>. In the fast round 1, acceptors <span class="math inline">\(a_1\)</span> and <span class="math inline">\(a_2\)</span> voted for <span class="math inline">\(x\)</span>, while acceptors <span class="math inline">\(a_3\)</span>, <span class="math inline">\(a_4\)</span>, and <span class="math inline">\(a_5\)</span> voted for <span class="math inline">\(y\)</span> (where <span class="math inline">\(x \neq y\)</span>). Following this, in the classic round 2, after receiving phase 1b messages from all acceptors in <span class="math inline">\(Q\)</span>, the coordinator <span class="math inline">\(c\)</span> identifies two values (<span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>), both satisfying Observation 4. Here's the twist: If coordinator <span class="math inline">\(c\)</span> selects <span class="math inline">\(R_1\)</span> as the 1-quorum, then <span class="math inline">\(\operatorname{O4}(x)\)</span> is fulfilled (<span class="math inline">\((R_1 \cap Q = {a_1, a_2}) \land (\operatorname{vv}(a_1) = x) \land (\operatorname{vv}(a_2) = x)\)</span>). Alternatively, if coordinator <span class="math inline">\(c\)</span> selects <span class="math inline">\(R_2\)</span> as the 1-quorum, then <span class="math inline">\(\operatorname{O4}(y)\)</span> is satisfied (<span class="math inline">\((R_2 \cap Q = {a_3}) \land (\operatorname{vv}(a_3) = y)\)</span>). However, the catch is that <span class="math inline">\(Q \cap R_1 \cap R_2 = \emptyset\)</span>. This condition contradicts the Quorum Requirement, thereby illustrating how the Quorum Requirement can prevent such scenarios.</p><p>Let's demonstrate in a more generalized manner how the Quorum Requirement prevents case 3. Assume the existence of a <span class="math inline">\(k\)</span>-quorum <span class="math inline">\(R_0\)</span> where all acceptors in <span class="math inline">\(Q \cap R_0\)</span> have voted for a value <span class="math inline">\(v_0\)</span>. We can prove that <span class="math inline">\(v_0\)</span> is the only value satisfying Observation 4, and we do this via a proof by contradiction. Suppose there is another distinct value <span class="math inline">\(v_m\)</span> that satisfies Observation 4 when we choose <span class="math inline">\(R_m\)</span> as another <span class="math inline">\(k\)</span>-quorum. By the Quorum Requirement, <span class="math inline">\(Q \cap R_0 \cap R_m \neq \emptyset\)</span>, which means there is at least one acceptor in <span class="math inline">\(Q \cap R_0 \cap R_m\)</span>. Without loss of generality, let's assume this acceptor is <span class="math inline">\(a_0\)</span>. We know that <span class="math inline">\(a_0\)</span> has already voted for <span class="math inline">\(v_0\)</span> (since all acceptors in <span class="math inline">\(Q \cap R_0\)</span> voted for <span class="math inline">\(v_0\)</span>), and that <span class="math inline">\(a_0\)</span> is in <span class="math inline">\(R_m\)</span> (because <span class="math inline">\(a_0 \in R_0 \cap R_m\)</span>). Consequently, the acceptors in <span class="math inline">\(Q \cap R_m\)</span> have voted for at least two different values: <span class="math inline">\(v_0\)</span> and <span class="math inline">\(v_m\)</span>. This is a contradiction.</p><h3 id="choosing-quorums">Choosing Quorums</h3><p>Let <span class="math inline">\(N\)</span> be the number of acceptors, and let us choose <span class="math inline">\(F\)</span> and <span class="math inline">\(E\)</span> such that any set of at least <span class="math inline">\(N − F\)</span> acceptors is a classic quorum and any set of at least <span class="math inline">\(N − E\)</span> acceptors is a fast quorum.</p><p>In any given round, any two fast quorums, <span class="math inline">\(R_1\)</span> and <span class="math inline">\(R_2\)</span>, will intersect at least <span class="math inline">\(2 * (N - E) - N\)</span> acceptors, represented by <span class="math inline">\(R_1 \cap R_2\)</span>. If we consider <span class="math inline">\(Q\)</span> to be any classic quorum, there will be at least <span class="math inline">\((2 * (N - E) - N) + (N - F) - N\)</span> acceptors in the intersection <span class="math inline">\(Q \cap R_1 \cap R_2\)</span>. Therefore, if we ensure that <span class="math inline">\(N &gt; 2E + F\)</span>, it guarantees that the intersection <span class="math inline">\(Q \cap R_1 \cap R_2\)</span> is not empty.</p><p>Given any two classic quorums, they will intersect at a minimum of <span class="math inline">\(2 * (N - F) - N\)</span> acceptors. Therefore, by ensuring that <span class="math inline">\(N &gt; 2F\)</span>, we can guarantee an intersection between any two classic quorums.</p><p>Since the requirements for fast quorums are more stringent than for classic quorums, we can always <strong>assume</strong> <span class="math inline">\(E \le F\)</span>. For a fixed <span class="math inline">\(N\)</span>, the two natural ways to choose <span class="math inline">\(E\)</span> and <span class="math inline">\(F\)</span> are to maximize one or the other. Maximizing <span class="math inline">\(E\)</span> yields <span class="math inline">\(E = F = \lceil N / 3\rceil - 1\)</span>; maximizing <span class="math inline">\(F\)</span> yields <span class="math inline">\(F = \lceil N / 2\rceil - 1\)</span> and <span class="math inline">\(E = \lfloor N / 4\rfloor\)</span>.</p><h3 id="collision-recovery">Collision Recovery</h3><p>The round can fail if <strong>two or more</strong> different proposers send proposals at about the same time, and those proposals are received by the acceptors in different orders. I now consider what the algorithm does to recover from such a collision of competing proposals.</p><p>The obvious way to recover from a collision is for <span class="math inline">\(c\)</span> to begin a new round, sending phase 1a messages to all acceptors, if it learns that round <span class="math inline">\(i\)</span> may not have chosen a value. Suppose the coordinator <span class="math inline">\(c\)</span> of round <span class="math inline">\(i\)</span> is also coordinator of round <span class="math inline">\(i + 1\)</span>, and that round <span class="math inline">\(i + 1\)</span> is the new one it starts. The phase 1b message that an acceptor a sends in response to <span class="math inline">\(c\)</span>'s round <span class="math inline">\(i + 1\)</span> phase 1a message does two things: it reports the current values of <span class="math inline">\(\operatorname{vrnd}(a)\)</span> and <span class="math inline">\(\operatorname{vval}(a)\)</span>, and it <strong>transmits <span class="math inline">\(a\)</span>'s promise not to cast any further vote in any round numbered less than <span class="math inline">\(i + 1\)</span></strong>. (This promise is implicit in <span class="math inline">\(a\)</span>'s setting <span class="math inline">\(\operatorname{rnd}(a)\)</span> to <span class="math inline">\(i + 1\)</span>.)</p><p>Suppose a voted in round <span class="math inline">\(i\)</span>. In that case, <span class="math inline">\(a\)</span>'s phase 1b message reports that <span class="math inline">\(\operatorname{vrnd}(a) = i\)</span> and that <span class="math inline">\(\operatorname{vval}(a)\)</span> equals the value <span class="math inline">\(a\)</span> sent in its round <span class="math inline">\(i\)</span> phase 2b message. Moreover, that phase 2b message also implies that a can cast <strong>no further vote in any round numbered less than <span class="math inline">\(i + 1\)</span></strong>. In other words, <strong><span class="math inline">\(a\)</span>'s round <span class="math inline">\(i\)</span> phase 2b message carries exactly the same information as its round i + 1 phase 1b message</strong>. If coordinator <span class="math inline">\(c\)</span> has received the phase 2b message, it has no need of the phase 1b message. This observation leads to the following two methods for recovery from collision.</p><h4 id="coordinated-recovery">Coordinated Recovery</h4><p>Suppose <span class="math inline">\(i\)</span> is a fast round number and <span class="math inline">\(c\)</span> is coordinator of rounds <span class="math inline">\(i\)</span> and <span class="math inline">\(i + 1\)</span>. In coordinated recovery, acceptors send their round <span class="math inline">\(i\)</span> phase 2b messages to the coordinator <span class="math inline">\(c\)</span> (as well as to the learners). If <span class="math inline">\(c\)</span> receives those messages from an <span class="math inline">\((i + 1)\)</span>-quorum of acceptors and sees that a collision may have occurred, then it treats those <strong>round <span class="math inline">\(i\)</span> phase 2b messages</strong> as if they were the corresponding <strong>round <span class="math inline">\(i + 1\)</span> phase 1b messages</strong> and executes phase 2a of round <span class="math inline">\(i + 1\)</span>, using the rule of Figure 2 to choose the value <span class="math inline">\(v\)</span> in its phase 2a messages.</p><p>Note that an acceptor can perform its phase 2b action even if it never received a phase 1a message for the round.</p><h4 id="uncoordinated-recovery">Uncoordinated Recovery</h4><p>Suppose <span class="math inline">\(i\)</span> and <span class="math inline">\(i + 1\)</span> are both fast round numbers. In uncoordinated recovery, acceptors send their round <span class="math inline">\(i\)</span> phase 2b messages to all other acceptors. Each acceptor uses <strong>the same procedure</strong> as in coordinated recovery to pick a value <span class="math inline">\(v\)</span> that the coordinator could send in a round <span class="math inline">\(i + 1\)</span> phase 2a message. It then executes phase 2b for round <span class="math inline">\(i + 1\)</span> <strong>as if it had received such a phase 2a message</strong>.</p><p>An acceptor picks a value to vote for in round <span class="math inline">\(i + 1\)</span> <strong>based on the round <span class="math inline">\(i\)</span> phase 2b messages it receives</strong>. The nondeterminism in that rule could lead different acceptors to pick different values, which could prevent round <span class="math inline">\(i + 1\)</span> from choosing a value. This can be prevented by having the round's coordinator indicate in its round <span class="math inline">\(i\)</span> phase 2a any message what <span class="math inline">\((i + 1)\)</span>-quorum Q should be used for uncoordinated recovery in case of collision.</p><h3 id="when-is-the-right-time-to-start-a-fast-round">When is the Right Time to Start a Fast Round?</h3><p>If <span class="math inline">\(E &lt; F\)</span>, so fast quorums are larger than classic quorums, the leader will probably choose a fast round number iff it believes that a fast quorum of acceptors is nonfaulty. If <span class="math inline">\(E = F\)</span>, in most applications it will always select a fast round number.</p><h2 id="reference">Reference</h2><ul><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf">Fast Paxos</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Consensus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - Flexible Paxos: Quorum intersection revisited</title>
    <link href="/2023/07/29/computer-science/consensus/paper-interpretation-flexible-paxos-quorum-intersection-revisited/"/>
    <url>/2023/07/29/computer-science/consensus/paper-interpretation-flexible-paxos-quorum-intersection-revisited/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>The steps outlined in the "The Basic Protocol" section of <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a> are as follows:</p><ol type="1"><li>Priest <span class="math inline">\(p\)</span> chooses a new ballot number <span class="math inline">\(b\)</span> greater than <span class="math inline">\(\operatorname{lastTried}(p)\)</span>,sets <span class="math inline">\(\operatorname{lastTried}(p)\)</span> to <span class="math inline">\(b\)</span>, and sends a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message to some set of priests. Please notice that the quorum <span class="math inline">\(Q\)</span> has not yet been determined.</li><li>Upon receipt of a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message from <span class="math inline">\(p\)</span> with <span class="math inline">\(b &gt; \operatorname{nextBal}(q)\)</span>, priest <span class="math inline">\(q\)</span> sets <span class="math inline">\(\operatorname{nextBal}(q)\)</span> to <span class="math inline">\(b\)</span> and sends a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message to <span class="math inline">\(p\)</span>, where <span class="math inline">\(v\)</span> equals <span class="math inline">\(\operatorname{prevVote}(q)\)</span>. A <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message is ignored if <span class="math inline">\(b \le \operatorname{nextBal}(q)\)</span>.</li><li>After receiving a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message from every priest in <strong>some majority set</strong> <span class="math inline">\(Q\)</span>, where <span class="math inline">\(b = \operatorname{lastTried}(p)\)</span>, priest <span class="math inline">\(p\)</span> initiates a new ballot with number <span class="math inline">\(b\)</span>, quorum <span class="math inline">\(Q\)</span>, and decree <span class="math inline">\(d\)</span>, where <span class="math inline">\(d\)</span> is chosen to satisfy <span class="math inline">\(\operatorname{B3}\)</span>. He then sends a <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message to <strong>every</strong> priest in <span class="math inline">\(Q\)</span>. (If <span class="math inline">\(b \neq \operatorname{lastTried}(p)\)</span>, the <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message is a response to a <strong>previous</strong> <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> conducted by priest <span class="math inline">\(p\)</span>; so, priest <span class="math inline">\(p\)</span> just ignores it.)</li><li>Upon receipt of a <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message with <span class="math inline">\(b = \operatorname{nextBal}(q)\)</span>, priest <span class="math inline">\(q\)</span> casts his vote in ballot number <span class="math inline">\(b\)</span>, sets <span class="math inline">\(\operatorname{prevVote}(q)\)</span> to this vote, and sends a <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message to <span class="math inline">\(p\)</span>. (A <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message is ignored if <span class="math inline">\(b \neq \operatorname{nextBal}(q)\)</span>.)</li><li>If <span class="math inline">\(p\)</span> has received a <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message from <strong>every</strong> priest <span class="math inline">\(q\)</span> in <span class="math inline">\(Q\)</span> (the quorum for ballot number <span class="math inline">\(b\)</span>), where <span class="math inline">\(b = \operatorname{lastTried}(p)\)</span>, then he writes <span class="math inline">\(d\)</span> (the decree of that ballot) in his ledger and sends a <span class="math inline">\(\operatorname{Success}(d)\)</span> message to <strong>every</strong> priest.</li><li>Upon receiving a <span class="math inline">\(\operatorname{Success}(d)\)</span> message, a priest enters decree <span class="math inline">\(d\)</span> in his ledger.</li></ol><p>The steps outlined in the "Paxos" section of <a href="https://arxiv.org/pdf/1608.06696v1.pdf">Flexible Paxos: Quorum intersection revisited</a> are as follows:</p><ol type="1"><li>Phase 1 - Prepare &amp; Promise<ol type="1"><li>A proposer selects a unique proposal number <span class="math inline">\(p\)</span> and sends <span class="math inline">\(\operatorname{prepare}(p)\)</span> to the acceptors.</li><li>Each acceptor receives <span class="math inline">\(\operatorname{prepare}(p)\)</span>. If <span class="math inline">\(p\)</span> is the highest proposal number promised, then <span class="math inline">\(p\)</span> is written to persistent storage and the acceptor replies with <span class="math inline">\(\operatorname{promise}(p&#39;, v&#39;)\)</span>. <span class="math inline">\((p&#39;, v&#39;)\)</span> is the last accepted proposal (if present) where <span class="math inline">\(p&#39;\)</span> is the proposal number and <span class="math inline">\(v&#39;\)</span> is the corresponding proposed value.</li><li>Once the proposer receives promise from the majority of acceptors, it proceeds to phase two. Otherwise, it may try again with higher proposal number.</li></ol></li><li>Phase 2 - Propose &amp; Accept<ol type="1"><li>The proposer must now select a value <span class="math inline">\(v\)</span>. If more than one proposal was returned in phase 1 then it must choose the value associated with the highest proposal number. If no proposals were returned, then the proposer can choose its own value for <span class="math inline">\(v\)</span>. The proposer then sends <span class="math inline">\(\operatorname{propose}(p, v)\)</span> to the acceptors.</li><li>Each acceptor receives a <span class="math inline">\(\operatorname{propose}(p, v)\)</span>. If <span class="math inline">\(p\)</span> is equal to or greater than the highest promised proposal number, then the promised proposal number and accepted proposal is written to persistent storage and the acceptor replies with <span class="math inline">\(\operatorname{accept}(p)\)</span>.</li><li>Once the proposer receives <span class="math inline">\(\operatorname{accept}(p)\)</span> from the majority of acceptors, it learns that the value <span class="math inline">\(v\)</span> is decided. Otherwise, it may try phase 1 again with a higher proposal number.</li></ol></li></ol><p>When comparing the steps outlined in the "The Basic Protocol" section of "The Part-Time Parliament" with those detailed in the "Paxos" section of "Flexible Paxos: Quorum intersection revisited", we observe that Flexible Paxos introduces a significant modification to the classical Paxos.</p><ul><li>Flexible Paxos does not stress that the majority of acceptors who responded with <span class="math inline">\(\operatorname{accept}(p)\)</span> to the proposer must be the exact same majority of acceptors who sent <span class="math inline">\(\operatorname{promise}(p&#39;, v&#39;)\)</span> to the proposer.</li><li>Flexible Paxos permits acceptors to respond to <span class="math inline">\(\operatorname{propose}(p, v)\)</span> when <span class="math inline">\(p\)</span> is greater than the highest promised proposal number.</li><li>Flexible Paxos divides the third step of the Classical Paxos into two distinct components, and integrates them into the first and second phases respectively.</li></ul><p>As outlined in "Flexible Paxos: Quorum Intersection Revisited", there are two quorums in the specified version of Classical Paxos, existing respectively in phase one and phase two. This context clarifies Heidi Howard's assertion: "In this paper, we weaken the requirement in the original protocol that all quorums intersect to require only that quorums from different phases intersect. Within each of the phases of Paxos, it is safe to use disjoint quorums and majority quorums are not necessary."</p><h2 id="fpaxos">FPaxos</h2><p>We will differentiate between the quorum used by the first phase of Paxos, which we will refer to as <span class="math inline">\(Q1\)</span> and the quorum for second phase, referred to as <span class="math inline">\(Q2\)</span>. We observe that it is only necessary for phase 1 quorums (<span class="math inline">\(Q1\)</span>) and phase 2 quorums (<span class="math inline">\(Q2\)</span>) to intersect. There is no need to require that <span class="math inline">\(Q1\)</span>'s intersect with each other nor <span class="math inline">\(Q2\)</span>'s intersect with each other.</p><p>Using this observation, we can make use of many non-intersecting quorum systems. In its most straight-forward application, we can simply decrease the size of <span class="math inline">\(Q2\)</span> at the cost of increasing the size of <span class="math inline">\(Q1\)</span> quorums. Notice that the second phase of Paxos (replication) is far more frequent than the first phase (leader election) in Multi-Paxos. Therefore, reducing the size of <span class="math inline">\(Q2\)</span> decreases latency in the common case by reducing the number of acceptors required to participate in replication, improves system tolerance to slow acceptors and allows us to use disjoint sets of acceptors for higher throughput. The price we pay for this is requiring more acceptors to participate when we need to establish a new leader. Whilst electing a new leader is a rare event in a stable system, if sufficient failures occur that we cannot form a <span class="math inline">\(Q1\)</span> quorum, then we cannot make progress until some of the acceptors recover.</p><h2 id="implications">Implications</h2><h3 id="majority-quorums">Majority quorums</h3><p>Currently, Paxos requires us to use quorums of size <span class="math inline">\(n / 2 + 1\)</span> when the number of acceptors <span class="math inline">\(n\)</span> is even. Using our observation, we can safely reduce the size of <span class="math inline">\(Q2\)</span> by one from <span class="math inline">\(n / 2 + 1\)</span> to <span class="math inline">\(n / 2\)</span> and keep <span class="math inline">\(Q1\)</span> the same.</p><h3 id="simple-quorums">Simple quorums</h3><p>We will use the term simple quorums to refer to a quorum systems where any acceptor is able to participate in a quorum and each acceptor's participation is counted equally. Simple quorums are a straightforward generalization of majority quorums.</p><p>Therefore, FPaxos with simple quorums must require that <span class="math inline">\(|Q1| + |Q2| &gt; N\)</span>. We know that in practice the second phase is much more common than the first phase so we allow <span class="math inline">\(|Q2| &lt; N / 2\)</span> and increase the size of <span class="math inline">\(Q1\)</span> accordingly. For a given size of <span class="math inline">\(Q2\)</span> and number of acceptors <span class="math inline">\(N\)</span>, then minimum size of our first phase quorum is <span class="math inline">\(|Q1| = N - |Q2| + 1\)</span>. FPaxos will always be able to handle up to <span class="math inline">\(|Q2| - 1\)</span> failures. However, if between <span class="math inline">\(|Q2|\)</span> to <span class="math inline">\(N - |Q2|\)</span> failures occur, we can continue replication <strong>until a new leader is required</strong>.</p><h3 id="grid-quorums">Grid quorums</h3><p>The key limitation of simple quorums is that reducing the size of the <span class="math inline">\(Q2\)</span> requires a corresponding increase in the size of <span class="math inline">\(Q1\)</span> to continue to ensure intersection. Grid quorums are an example of an alternative quorum system. Grid quorums can reduce the size of <span class="math inline">\(Q1\)</span> by offering a different trade off between quorum sizes, flexibility when choosing quorums and failure tolerance.</p><p>Grid quorum schemes arrange the <span class="math inline">\(N\)</span> nodes into a matrix of <span class="math inline">\(N1\)</span> columns by <span class="math inline">\(N2\)</span> rows, where <span class="math inline">\(N1 × N2 = N\)</span> and quorums are composed of rows and columns. As with many other quorum systems, grid quorums restrict which combinations of acceptors can form valid quorums. This restriction allows us to reduce the size of quorums whilst still ensuring that they intersect.</p><ul><li>Paxos requires that all quorums intersect thus one suitable grid scheme would require one row and one column to form a quorum. Figure 3a shows an example <span class="math inline">\(Q1\)</span> quorum and <span class="math inline">\(Q2\)</span> quorum using this scheme.</li><li>In FPaxos, we can safely reduce our quorums to one row of size <span class="math inline">\(N1\)</span> for <span class="math inline">\(Q1\)</span> and one column of size <span class="math inline">\(N2\)</span> for <span class="math inline">\(Q2\)</span>, examples are shown in Figure 3b.</li></ul><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-flexible-paxos-quorum-intersection-revisited/grid-quorums.png" alt="" /><figcaption>Figure 3: Example of using a 5 by 4 grid to form quorums for a system of 20 acceptors</figcaption></figure><h2 id="safety">Safety</h2><p>Heidi Howard demonstrates the safety of Flexible Paxos through proof by contradiction and classification discussion. This approach is notably easier to comprehend and retain compared to the proof of the single-decree Synod protocol.</p><p><strong>Theorem 2.</strong> If value <span class="math inline">\(v\)</span> is decided with proposal number <span class="math inline">\(p\)</span> then for any message <span class="math inline">\(\operatorname{propose}(p&#39;, v&#39;)\)</span> where <span class="math inline">\(p&#39; &gt; p\)</span> then <span class="math inline">\(v = v&#39;\)</span>.</p><p>Proof is by contradiction, that is, assume <span class="math inline">\(v \neq v&#39;\)</span>. We will consider the <strong>smallest</strong> proposal number <span class="math inline">\(p&#39; &gt; p\)</span> for which such a message is sent.</p><p>Let <span class="math inline">\(Q_{p, 2}\)</span> be the phase 2 quorum used by proposal number <span class="math inline">\(p\)</span> and <span class="math inline">\(Q_{p&#39;, 1}\)</span> be the phase 1 quorum used by proposal number <span class="math inline">\(p&#39;\)</span>. Let <span class="math inline">\(\bar{A}\)</span> be the set of acceptors which participated both in the phase 2 quorum used by proposal number <span class="math inline">\(p\)</span> and phase 1 quorum used by proposal number <span class="math inline">\(p&#39;\)</span>, thus <span class="math inline">\(\bar{A} = Q_{p, 2} \cap Q_{p&#39;, 1}\)</span>. We can infer that at least one acceptor must participate in both quorums, <span class="math inline">\(\bar{A} \neq \emptyset\)</span>.</p><p>Let us consider the ordering of events from the perspective of one acceptor <span class="math inline">\(acc\)</span> where <span class="math inline">\(acc \in \bar{A}\)</span>. It is either the case that they receive <span class="math inline">\(\operatorname{prepare}(p&#39;)\)</span> first or <span class="math inline">\(\operatorname{propose}(p, v)\)</span> first. We will consider each of these cases separately:</p><ul><li>CASE 1: Acceptor <span class="math inline">\(acc\)</span> receives <span class="math inline">\(\operatorname{prepare}(p&#39;)\)</span> before it receives <span class="math inline">\(\operatorname{propose}(p, v)\)</span>. When <span class="math inline">\(acc\)</span> receives <span class="math inline">\(\operatorname{propose}(p, v)\)</span>, its last promised proposal will be <span class="math inline">\(p&#39;\)</span> or higher. As <span class="math inline">\(p&#39; &gt; p\)</span> then it will not accept the proposal from <span class="math inline">\(p\)</span>, however as <span class="math inline">\(acc \in Q_{p, 2}\)</span> it must accept <span class="math inline">\(\operatorname{propose}(p, v)\)</span> (given the value <span class="math inline">\(v\)</span> is decided). This is a contradiction thus it cannot be the case.</li><li>CASE 2: Acceptor <span class="math inline">\(acc\)</span> receives <span class="math inline">\(\operatorname{propose}(p, v)\)</span> before it receives <span class="math inline">\(\operatorname{prepare}(p&#39;)\)</span>. When acc receives <span class="math inline">\(\operatorname{prepare}(p&#39;)\)</span>, there are two cases. Either:<ul><li>CASE 2a: The last promised proposal by acceptor <span class="math inline">\(acc\)</span> is already higher than <span class="math inline">\(p&#39;\)</span>. Then it will not accept the prepare from <span class="math inline">\(p&#39;\)</span>, however as <span class="math inline">\(acc \in Q_{p&#39;, 1}\)</span> it must accept <span class="math inline">\(\operatorname{prepare}(p&#39;)\)</span>. This is a contradiction thus it cannot be the case.</li><li>CASE 2b: The last promised proposal by acceptor <span class="math inline">\(acc\)</span> is less than <span class="math inline">\(p&#39;\)</span> then it will reply with <span class="math inline">\(\operatorname{promise}(q, v)\)</span> where <span class="math inline">\(p \le q \lt p&#39;\)</span>. The value <span class="math inline">\(v\)</span> will be the same the one <span class="math inline">\(acc\)</span> accepted with <span class="math inline">\(p\)</span>, under the minimility hypothesis on <span class="math inline">\(p&#39;\)</span> (<span class="math inline">\(p&#39;\)</span> is the <strong>smallest</strong> proposal number for which such a message is sent).<ul><li><span class="math inline">\(acc \in Q_{p&#39;, 1}\)</span> therefore <span class="math inline">\(\operatorname{promise}(q, v)\)</span> will be at least one of the responses received by the proposer of <span class="math inline">\(p&#39;\)</span>. If this is the only accepted value returned, then its value <span class="math inline">\(v\)</span> will be chosen.</li><li>Other proposals may also be received for members of <span class="math inline">\(Q_{p&#39;, 1}\)</span>. Recall that <span class="math inline">\(p &lt; p&#39;\)</span>. For each other <span class="math inline">\(\operatorname{proposal}(q&#39;, v&#39;&#39;)\)</span> received, either:<ul><li>CASE (i) <span class="math inline">\(q&#39; &lt; q\)</span>: These proposal will be ignored as the proposer must choose the value associated with the highest proposal.</li><li>CASE (ii) <span class="math inline">\((q&#39; &gt; q) \land (q&#39; &gt; p&#39;)\)</span>: This case cannot occur as an acceptor will only reply to <span class="math inline">\(\operatorname{prepare}(p&#39;)\)</span> when last promised is <span class="math inline">\(&lt; p&#39;\)</span>.</li><li>CASE (iii) <span class="math inline">\((q&#39; &gt; q) \land (q&#39; &lt; p&#39;)\)</span>: <span class="math inline">\(p &lt; q &lt; q&#39; &lt; p&#39;\)</span>. For an acceptor to have accepted <span class="math inline">\((q&#39;, v&#39;&#39;)\)</span> then it must have first been proposed. This is impossible by the minimality assumption on <span class="math inline">\(p&#39;\)</span> (<span class="math inline">\(p&#39;\)</span> is the <strong>smallest</strong> proposal number for which such a message is sent).</li></ul></li></ul></li></ul></li></ul><p>Thus the value <span class="math inline">\(v\)</span> will be chosen, in contradiction to the assumption that <span class="math inline">\(\operatorname{propose}(p&#39;, v&#39;)\)</span> was sent.</p><p>For a given value <span class="math inline">\(v\)</span> to be decided, it must first have been be proposed. Thus:</p><p><strong>Theorem 1.</strong> If value <span class="math inline">\(v\)</span> is decided with proposal number <span class="math inline">\(p\)</span> and <span class="math inline">\(v&#39;\)</span> is decided with proposal number <span class="math inline">\(p&#39;\)</span> then <span class="math inline">\(v = v&#39;\)</span>.</p><h2 id="reference">Reference</h2><ul><li><a href="https://fpaxos.github.io/">Flexible Paxos: Quorum intersection revisited</a></li><li><a href="https://arxiv.org/pdf/1608.06696v1.pdf">Flexible Paxos: Quorum intersection revisited</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Consensus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Implementing Multi-Decree Parliament In TLA+</title>
    <link href="/2023/07/24/computer-science/programming-language/tla+/implementing-multi-decree-parliament-in-tla/"/>
    <url>/2023/07/24/computer-science/programming-language/tla+/implementing-multi-decree-parliament-in-tla/</url>
    
    <content type="html"><![CDATA[<h1 id="spec">Spec</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br></pre></td><td class="code"><pre><code class="hljs tla">--------------------------- MODULE MultiDecreeParliament -------------------<br>\* MultiDecreeParliament.tla<br>EXTENDS Integers, FiniteSets, TLC<br>CONSTANTS PRIESTS, DECREES, INSTANCE_IDS, BALLOT_IDS<br>VARIABLES priestStatus, ledgers, minUnusedInstanceIds, usedBallotIds, msgs<br><br>\* Declaring symmetry during liveness checking is dangerous.<br>\* It might cause TLC to miss violations of the stated liveness properties.<br>\* Please check liveness without symmetry defined.<br>\* SYMM ==<br>\*          Permutations(PRIESTS)<br>\*   \union Permutations(DECREES)<br><br>InvalidInstanceId == -1<br>BlankBallotId == -1<br>BlankDecree == &quot;BLANK&quot;<br>OliveDayDecree == &quot;The ides of February is national olive day&quot;<br><br>NextBallotMsgType == &quot;NextBallot&quot;<br>LastVoteMsgType == &quot;LastVote&quot;<br>BeginBallotMsgType == &quot;BeginBallot&quot;<br>VotedMsgType == &quot;Voted&quot;<br>SuccessMsgType == &quot;Success&quot;<br><br>ASSUME<br>  /\ IsFiniteSet(PRIESTS)<br>  /\ IsFiniteSet(DECREES)<br>  /\ BlankDecree \notin DECREES<br>  /\ OliveDayDecree \notin DECREES<br>  /\ INSTANCE_IDS \subseteq Nat<br>  /\ IsFiniteSet(INSTANCE_IDS)<br>  /\ \A i \in INSTANCE_IDS: InvalidInstanceId &lt; i<br>  /\ BALLOT_IDS \subseteq Nat<br>  /\ IsFiniteSet(BALLOT_IDS)<br>  /\ BlankBallotId \notin BALLOT_IDS<br><br>GetQuorum(ballotId, instanceId) ==<br>  &#123;<br>    m.to:<br>      m \in<br>        &#123;<br>          m \in msgs:<br>            /\ m.type = BeginBallotMsgType<br>            /\ m.ballotId = ballotId<br>            /\ m.decrees[instanceId] # BlankDecree<br>        &#125;<br>  &#125;<br><br>Init ==<br>  /\ priestStatus =<br>    [<br>      p \in PRIESTS |-&gt;<br>      [<br>        \* While priests can employ differing ballot IDs<br>        \* across various Synod instances,<br>        \* for the sake of simplicity, this discussion assumes that<br>        \* they utilize the same ballot ID<br>        \* each time they&#x27;re selected as president.<br>        lastTriedBallotId |-&gt; -1,<br>        prevVote          |-&gt;<br>          [i \in INSTANCE_IDS |-&gt; [ballotId |-&gt; -1, decree |-&gt; BlankDecree]],<br>        nextBallotId      |-&gt; -1<br>      ]<br>    ]<br>  /\ ledgers = [p \in PRIESTS |-&gt; [i \in INSTANCE_IDS |-&gt; BlankDecree]]<br>  /\ minUnusedInstanceIds = [p \in PRIESTS |-&gt; InvalidInstanceId]<br>  /\ usedBallotIds = &#123;&#125;<br>  /\ msgs = &#123;&#125;<br><br>\* Step (1)<br>\* Logically, the parliamentary protocol used a separate instance of<br>\* the complete Synod protocol for each decree number.<br>\* However, a single president was selected for all these instances,<br>\* and he performed the first two steps of the protocol just once.<br>\* A newly elected president $p$ can send to some set of legislators<br>\* a single message that serves as the $\operatorname&#123;NextBallot&#125;(b)$ message<br>\* for all instances of the Synod protocol.<br>\* (There are an infinite number of instances - one for each decree number.)<br>SendNextBallotMsg(p) ==<br>  \E b \in BALLOT_IDS \ usedBallotIds:<br>    /\ b &gt; priestStatus[p].lastTriedBallotId<br>    /\ priestStatus&#x27; = [priestStatus EXCEPT ![p].lastTriedBallotId = b]<br>    /\ usedBallotIds&#x27; = usedBallotIds \union &#123;b&#125;<br>    /\ msgs&#x27; = msgs \union<br>      &#123;[<br>        type     |-&gt; NextBallotMsgType,<br>        ballotId |-&gt; b<br>      ]&#125;<br>    /\ UNCHANGED &lt;&lt;ledgers, minUnusedInstanceIds&gt;&gt;<br><br>\* Step (2)<br>\* A legislator $q$ can reply with a single message that<br>\* serves as the LastVote messages for step 2 of<br>\* all instances of the Synod protocol.<br>\* This message contains only a finite amount of information,<br>\* since $q$ can have voted in only a finite number of instances.<br>ReceiveNextBallotMsg(q) ==<br>  \E b \in BALLOT_IDS:<br>    /\ [type |-&gt; NextBallotMsgType, ballotId |-&gt; b] \in msgs<br>    /\ b &gt; priestStatus[q].nextBallotId<br>    /\ priestStatus&#x27; = [priestStatus EXCEPT ![q].nextBallotId = b]<br>    /\ msgs&#x27; = msgs \union &#123;[<br>        type     |-&gt; LastVoteMsgType,<br>        ballotId |-&gt; b,<br>        vote     |-&gt; priestStatus[q].prevVote,<br>        from     |-&gt; q<br>      ]&#125;<br>    /\ UNCHANGED &lt;&lt;ledgers, minUnusedInstanceIds, usedBallotIds&gt;&gt;<br><br>\* Step (3.1)<br>\* After receiving a $\operatorname&#123;LastVote&#125;(b, v)$ message<br>\* from every priest in some majority set $Q$,<br>\* where $b = \operatorname&#123;lastTried&#125;(p)$,<br>\* priest $p$ initiates a new ballot<br>\* with number $b$, quorum $Q$, and decree $d$,<br>\* where $d$ is chosen to satisfy $\operatorname&#123;B3&#125;$.<br>\* He then sends a $\operatorname&#123;BeginBallot&#125;(b, d)$ message<br>\* to every priest in $Q$.<br>ReceiveLastVoteMsg(p) ==<br>  \E majority \in SUBSET PRIESTS:<br>    LET<br>      b == priestStatus[p].lastTriedBallotId<br>      lastVoteMsgs ==<br>        &#123;<br>          m \in msgs:<br>            /\ m.type = LastVoteMsgType<br>            /\ m.ballotId = b<br>            /\ m.from \in majority<br>        &#125;<br>      maxLastVotes ==<br>        [<br>          i \in INSTANCE_IDS |-&gt;<br>            (CHOOSE m \in lastVoteMsgs:<br>              \A n \in lastVoteMsgs:<br>                m.vote[i].ballotId &gt;= n.vote[i].ballotId).vote[i]<br>        ]<br>      notBlankDecreeInstanceIds ==<br>        &#123;<br>          i \in DOMAIN maxLastVotes:<br>            /\ maxLastVotes[i].ballotId # BlankBallotId<br>            /\ maxLastVotes[i].decree # BlankDecree<br>        &#125;<br>      maxNotBlankDecreeInstanceId ==<br>        IF notBlankDecreeInstanceIds = &#123;&#125;<br>          THEN InvalidInstanceId<br>          ELSE<br>            CHOOSE mid \in notBlankDecreeInstanceIds:<br>              \A id \in notBlankDecreeInstanceIds:<br>                mid &gt;= id<br>      decrees ==<br>        [<br>          i \in INSTANCE_IDS |-&gt;<br>            IF i &gt; maxNotBlankDecreeInstanceId<br>              THEN BlankDecree<br>              ELSE<br>                IF /\ maxLastVotes[i].ballotId = BlankBallotId<br>                   /\ maxLastVotes[i].decree = BlankDecree<br>                  \* Passing decrees out of order in this way might cause confusion.<br>                  \* In general, a new president would fill any gaps in his ledger<br>                  \* by passing the &quot;olive-day&quot; decree.<br>                  THEN OliveDayDecree<br>                  ELSE maxLastVotes[i].decree<br>        ]<br>    IN<br>      /\ &#123;m \in msgs: m.type = BeginBallotMsgType /\ m.ballotId = b&#125; = &#123;&#125;<br>      /\ &#123;m.from: m \in lastVoteMsgs&#125; = majority<br>      /\ Cardinality(majority) * 2 &gt; Cardinality(PRIESTS)<br>      /\ minUnusedInstanceIds&#x27; =<br>        [minUnusedInstanceIds EXCEPT ![p] = maxNotBlankDecreeInstanceId + 1]<br>      /\ msgs&#x27; = msgs \union<br>        [<br>          type     : &#123;BeginBallotMsgType&#125;,<br>          ballotId : &#123;b&#125;,<br>          decrees  : &#123;decrees&#125;,<br>          to       : majority<br>        ]<br>      /\ UNCHANGED &lt;&lt;priestStatus, ledgers, usedBallotIds&gt;&gt;<br><br>\* Step (3.2)<br>\* Then, whenever he receives a request to pass a decree,<br>\* he chooses the lowest-numbered decree that he is still free to choose,<br>\* and he performs step 3 for that decree number<br>\* (instance of the Synod protocol) to try to pass the decree.<br>SendBeginBallotMsg(p) ==<br>  \E d \in DECREES:<br>    LET<br>      b == priestStatus[p].lastTriedBallotId<br>      instanceIds == &#123;i \in INSTANCE_IDS: i &gt;= minUnusedInstanceIds[p]&#125;<br>      instanceId ==<br>        IF instanceIds # &#123;&#125;<br>          THEN CHOOSE mid \in instanceIds: \A id \in instanceIds: mid &lt;= id<br>          ELSE InvalidInstanceId<br>      decrees ==<br>        [i \in INSTANCE_IDS |-&gt; IF i = instanceId THEN d ELSE BlankDecree]<br>    IN<br>      \* Ensure that Step (3.1) has been successfully completed<br>      \* before proceeding further.<br>      /\ minUnusedInstanceIds[p] # InvalidInstanceId<br>      \* Ensure that available instance IDs remain.<br>      /\ instanceId # InvalidInstanceId<br>      /\ minUnusedInstanceIds&#x27; =<br>        [minUnusedInstanceIds EXCEPT ![p] = instanceId + 1]<br>      /\ msgs&#x27; = msgs \union<br>        [<br>          type     : &#123;BeginBallotMsgType&#125;,<br>          ballotId : &#123;b&#125;,<br>          decrees  : &#123;decrees&#125;,<br>          to       :<br>            &#123;<br>              m.to :<br>                m \in<br>                  &#123;<br>                    m \in msgs:<br>                      /\ m.type = BeginBallotMsgType<br>                      /\ m.ballotId = b<br>                  &#125;<br>            &#125;<br>        ]<br>      /\ UNCHANGED &lt;&lt;priestStatus, ledgers, usedBallotIds&gt;&gt;<br><br>\* Step (4)<br>ReceiveBeginBallotMsg(q) ==<br>  LET<br>    b == priestStatus[q].nextBallotId<br>    beginBallotMsgs ==<br>      &#123;<br>        m \in msgs:<br>          /\ m.type = BeginBallotMsgType<br>          /\ m.ballotId = b<br>          /\ m.to = q<br>      &#125;<br>  IN<br>    \E m \in beginBallotMsgs:<br>      /\ priestStatus&#x27; =<br>        [<br>          priestStatus EXCEPT ![q].prevVote =<br>            [<br>              i \in INSTANCE_IDS |-&gt;<br>                IF m.decrees[i] # BlankDecree<br>                  THEN [ballotId |-&gt; b, decree |-&gt; m.decrees[i]]<br>                  ELSE priestStatus[q].prevVote[i]<br>            ]<br>        ]<br>      /\ msgs&#x27; = msgs \union<br>        &#123;[<br>          type     |-&gt; VotedMsgType,<br>          ballotId |-&gt; b,<br>          decrees  |-&gt; m.decrees,<br>          from     |-&gt; q<br>        ]&#125;<br>      /\ UNCHANGED &lt;&lt;ledgers, minUnusedInstanceIds, usedBallotIds&gt;&gt;<br><br>\* Step (5)<br>ReceiveVotedMsg(p) ==<br>  \E i \in INSTANCE_IDS:<br>    LET<br>      b == priestStatus[p].lastTriedBallotId<br>      votedMsgs ==<br>        &#123;<br>          m \in msgs:<br>            /\ m.type = VotedMsgType<br>            /\ m.ballotId = b<br>            /\ m.decrees[i] # BlankDecree<br>        &#125;<br>      decrees ==<br>        IF votedMsgs # &#123;&#125;<br>          THEN (CHOOSE m \in votedMsgs: TRUE).decrees<br>          ELSE [j \in INSTANCE_IDS |-&gt; BlankDecree]<br>    IN<br>      /\ GetQuorum(b, i) # &#123;&#125;<br>      /\ &#123;m.from: m \in votedMsgs&#125; = GetQuorum(b, i)<br>      /\ ledgers&#x27; = [ledgers EXCEPT ![p][i] = decrees[i]]<br>      /\ msgs&#x27; = msgs \union<br>        &#123;[<br>          type     |-&gt; SuccessMsgType,<br>          ballotId |-&gt; b,<br>          decrees  |-&gt; decrees<br>        ]&#125;<br>      /\ UNCHANGED &lt;&lt;priestStatus, minUnusedInstanceIds, usedBallotIds&gt;&gt;<br><br>\* Step (6)<br>ReceiveSuccessMsg(q) ==<br>  \E successMsg \in &#123;m \in msgs: m.type = SuccessMsgType&#125;:<br>    /\ ledgers&#x27; =<br>      [<br>        ledgers EXCEPT ![q] =<br>          [<br>            i \in INSTANCE_IDS |-&gt;<br>              IF successMsg.decrees[i] # BlankDecree<br>                THEN successMsg.decrees[i]<br>                ELSE ledgers[q][i]<br>          ]<br>      ]<br>    /\ UNCHANGED &lt;&lt;priestStatus, minUnusedInstanceIds, usedBallotIds, msgs&gt;&gt;<br><br>Next == \E p \in PRIESTS:<br>  \/ SendNextBallotMsg(p)<br>  \/ ReceiveNextBallotMsg(p)<br>  \/ ReceiveLastVoteMsg(p)<br>  \/ SendBeginBallotMsg(p)<br>  \/ ReceiveBeginBallotMsg(p)<br>  \/ ReceiveVotedMsg(p)<br>  \/ ReceiveSuccessMsg(p)<br><br>Spec ==<br>  /\ Init<br>  /\ [][Next]_&lt;&lt;priestStatus, ledgers, minUnusedInstanceIds, usedBallotIds, msgs&gt;&gt;<br>  /\ SF_&lt;&lt;priestStatus, ledgers, minUnusedInstanceIds, usedBallotIds, msgs&gt;&gt;(Next)<br><br>ValidMinUnusedInstanceIds ==<br>         &#123;InvalidInstanceId&#125;<br>  \union 0..((CHOOSE mid \in INSTANCE_IDS: \A id \in INSTANCE_IDS: mid &gt;= id) + 1)<br>ValidBallotIds == &#123;BlankBallotId&#125; \union BALLOT_IDS<br>ValidDecrees == &#123;BlankDecree, OliveDayDecree&#125; \union DECREES<br>PriestStatusTypeOK ==<br>  /\ DOMAIN priestStatus = PRIESTS<br>  /\ \A p \in PRIESTS:<br>    /\ DOMAIN priestStatus[p] =<br>      &#123;&quot;lastTriedBallotId&quot;, &quot;prevVote&quot;, &quot;nextBallotId&quot;&#125;<br>    /\ priestStatus[p].lastTriedBallotId \in ValidBallotIds<br>    /\ DOMAIN priestStatus[p].prevVote = INSTANCE_IDS<br>    /\ \A i \in INSTANCE_IDS:<br>      /\ DOMAIN priestStatus[p].prevVote[i] = &#123;&quot;ballotId&quot;, &quot;decree&quot;&#125;<br>      /\ priestStatus[p].prevVote[i].ballotId \in ValidBallotIds<br>      /\ priestStatus[p].prevVote[i].decree \in ValidDecrees<br>    /\ priestStatus[p].nextBallotId \in ValidBallotIds<br>  /\ priestStatus \in<br>    [<br>      PRIESTS -&gt;<br>        [<br>          lastTriedBallotId : ValidBallotIds,<br>          prevVote          :<br>            [<br>              INSTANCE_IDS -&gt;<br>                [<br>                  ballotId  : ValidBallotIds,<br>                  decree    : ValidDecrees<br>                ]<br>            ],<br>          nextBallotId      : ValidBallotIds<br>        ]<br>    ]<br>LedgersTypeOK ==<br>  /\ DOMAIN ledgers = PRIESTS<br>  /\ \A p \in PRIESTS:<br>    /\ DOMAIN ledgers[p] = INSTANCE_IDS<br>    /\ \A i \in INSTANCE_IDS:<br>      /\ ledgers[p][i] \in ValidDecrees<br>  /\ ledgers \in [PRIESTS -&gt; [INSTANCE_IDS -&gt; ValidDecrees]]<br>MinUnusedInstanceIdsTypeOK ==<br>  /\ DOMAIN minUnusedInstanceIds = PRIESTS<br>  /\ \A p \in PRIESTS:<br>    /\ minUnusedInstanceIds[p] \in ValidMinUnusedInstanceIds<br>  /\ minUnusedInstanceIds \in [PRIESTS -&gt; ValidMinUnusedInstanceIds]<br>UsedBallotIdsTypeOK == usedBallotIds \subseteq BALLOT_IDS<br>MsgsTypeOK ==<br>  /\ \A m \in msgs:<br>    \/ /\ m.type = NextBallotMsgType<br>       /\ m.ballotId \in BALLOT_IDS<br>    \/ /\ m.type = LastVoteMsgType<br>       /\ m.ballotId \in BALLOT_IDS<br>       /\ DOMAIN m.vote = INSTANCE_IDS<br>       /\ \A i \in INSTANCE_IDS:<br>         /\ DOMAIN m.vote[i] = &#123;&quot;ballotId&quot;, &quot;decree&quot;&#125;<br>         /\ m.vote[i].ballotId \in ValidBallotIds<br>         /\ m.vote[i].decree \in ValidDecrees<br>       /\ m.from \in PRIESTS<br>    \/ /\ m.type = BeginBallotMsgType<br>       /\ m.ballotId \in BALLOT_IDS<br>       /\ DOMAIN m.decrees = INSTANCE_IDS<br>       /\ \A i \in DOMAIN m.decrees: m.decrees[i] \in ValidDecrees<br>       /\ m.to \in PRIESTS<br>    \/ /\ m.type = VotedMsgType<br>       /\ m.ballotId \in BALLOT_IDS<br>       /\ DOMAIN m.decrees = INSTANCE_IDS<br>       /\ \A i \in DOMAIN m.decrees: m.decrees[i] \in ValidDecrees<br>       /\ m.from \in PRIESTS<br>    \/ /\ m.type = SuccessMsgType<br>       /\ m.ballotId \in BALLOT_IDS<br>       /\ DOMAIN m.decrees = INSTANCE_IDS<br>       /\ \A i \in DOMAIN m.decrees: m.decrees[i] \in ValidDecrees<br>  /\ msgs \subseteq<br>           [type : &#123;NextBallotMsgType&#125;, ballotId : BALLOT_IDS]<br>    \union [type     : &#123;LastVoteMsgType&#125;,<br>            ballotId : BALLOT_IDS,<br>            vote     : [INSTANCE_IDS -&gt;<br>                         [ballotId : ValidBallotIds, decree : ValidDecrees]],<br>            from     : PRIESTS]<br>    \union [type     : &#123;BeginBallotMsgType&#125;,<br>            ballotId : BALLOT_IDS,<br>            decrees  : [INSTANCE_IDS -&gt; ValidDecrees],<br>            to       : PRIESTS]<br>    \union [type     : &#123;VotedMsgType&#125;,<br>            ballotId : BALLOT_IDS,<br>            decrees  : [INSTANCE_IDS -&gt; ValidDecrees],<br>            from     : PRIESTS]<br>    \union [type     : &#123;SuccessMsgType&#125;,<br>            ballotId : BALLOT_IDS,<br>            decrees  : [INSTANCE_IDS -&gt; ValidDecrees]]<br>TypeOK ==<br>  /\ PriestStatusTypeOK<br>  /\ LedgersTypeOK<br>  /\ MinUnusedInstanceIdsTypeOK<br>  /\ UsedBallotIdsTypeOK<br>  /\ MsgsTypeOK<br><br>B1Consistent ==<br>  /\ \A p1, p2 \in &#123;p \in PRIESTS: priestStatus[p].lastTriedBallotId # BlankBallotId&#125;:<br>    \/ p1 = p2<br>    \/ priestStatus[p1].lastTriedBallotId # priestStatus[p2].lastTriedBallotId<br>  /\ \A m1, m2 \in &#123;m \in msgs: m.type = BeginBallotMsgType&#125;:<br>    \/ \A i \in INSTANCE_IDS:<br>      \/ m1.decrees[i] = BlankDecree<br>      \/ m2.decrees[i] = BlankDecree<br>      \/ m1.decrees[i] = m2.decrees[i]<br>    \/ m1.ballotId # m2.ballotId<br><br>B2Consistent ==<br>  \A i \in INSTANCE_IDS:<br>    \A m1, m2 \in<br>      &#123;m \in msgs: m.type = BeginBallotMsgType /\ m.decrees[i] # BlankDecree&#125;:<br>        GetQuorum(m1.ballotId, i) \intersect GetQuorum(m2.ballotId, i) # &#123;&#125;<br><br>B3Consistent ==<br>  \A beginBallotMsg \in &#123;m \in msgs: m.type = BeginBallotMsgType&#125;:<br>    \A i \in INSTANCE_IDS:<br>      LET<br>        quorum == GetQuorum(beginBallotMsg.ballotId, i)<br>        votedMsgs ==<br>          &#123;<br>            m \in msgs:<br>              /\ m.type = VotedMsgType<br>              /\ m.ballotId &lt; beginBallotMsg.ballotId<br>              /\ m.decrees[i] # BlankDecree<br>              /\ m.from \in quorum<br>          &#125;<br>        latestEarlierBallotId ==<br>          IF votedMsgs # &#123;&#125;<br>            THEN<br>              (CHOOSE latestMsg \in votedMsgs:<br>                \A m \in votedMsgs:<br>                  latestMsg.ballotId &gt;= m.ballotId).ballotId<br>            ELSE BlankBallotId<br>        latestEarlierDecree ==<br>          IF latestEarlierBallotId # BlankBallotId<br>            THEN (CHOOSE m \in votedMsgs:<br>              m.ballotId = latestEarlierBallotId).decrees[i]<br>            ELSE BlankDecree<br>      IN<br>        \/ beginBallotMsg.decrees[i] = BlankDecree<br>        \/ latestEarlierDecree = BlankDecree<br>        \/ beginBallotMsg.decrees[i] = latestEarlierDecree<br><br>LemmaConsistent ==<br>  \A m1 \in &#123;m \in msgs: m.type = SuccessMsgType&#125;:<br>    \A m2 \in &#123;m \in msgs: m.type = BeginBallotMsgType /\ m.ballotId &gt; m1.ballotId&#125;:<br>      \A i \in INSTANCE_IDS:<br>        \/ m1.decrees[i] = BlankDecree<br>        \/ m2.decrees[i] = BlankDecree<br>        \/ m2.decrees[i] = m1.decrees[i]<br><br>Theorem1Consistent ==<br>  \A m1, m2 \in &#123;m \in msgs: m.type = SuccessMsgType&#125;:<br>    \A i \in INSTANCE_IDS:<br>      \/ m1.decrees[i] = BlankDecree<br>      \/ m2.decrees[i] = BlankDecree<br>      \/ m1.decrees[i] = m2.decrees[i]<br><br>LedgerConsistent ==<br>  \A p1, p2 \in PRIESTS:<br>    \A i \in INSTANCE_IDS:<br>      \/ ledgers[p1][i] = BlankDecree<br>      \/ ledgers[p2][i] = BlankDecree<br>      \/ ledgers[p1][i] = ledgers[p2][i]<br><br>Consistent ==<br>  /\ B1Consistent<br>  /\ B2Consistent<br>  /\ B3Consistent<br>  /\ LemmaConsistent<br>  /\ Theorem1Consistent<br>  /\ LedgerConsistent<br><br>Invariant ==<br>  /\ TypeOK<br>  /\ Consistent<br><br>\* If decrees A and B are important and<br>\* decree A was passed before decree B was proposed,<br>\* then A has a lower decree number than B.<br>DecreeOrderingProperty ==<br>  [][<br>    LET<br>      GetInstanceIds(messages, messageType, excludedDecrees) ==<br>        &#123;<br>          i \in INSTANCE_IDS:<br>            \E m \in messages:<br>              /\ m.type = messageType<br>              /\ m.decrees[i] \notin excludedDecrees<br>        &#125;<br>      instanceIdsOfSuccessMsgs ==<br>        GetInstanceIds(msgs, SuccessMsgType, &#123;BlankDecree&#125;)<br>      importantInstanceIdsOfSuccessMsgs ==<br>        GetInstanceIds(msgs, SuccessMsgType, &#123;BlankDecree, OliveDayDecree&#125;)<br>      importantInstanceIdsOfBeginBallotMsgs ==<br>          GetInstanceIds(msgs&#x27;, BeginBallotMsgType, &#123;BlankDecree, OliveDayDecree&#125;)<br>        \ GetInstanceIds(msgs, BeginBallotMsgType, &#123;BlankDecree, OliveDayDecree&#125;)<br>    IN<br>      \A instanceIdOfSuccessMsg \in importantInstanceIdsOfSuccessMsgs:<br>        \A instanceIdOfBeginBallotMsg \in importantInstanceIdsOfBeginBallotMsgs:<br>          instanceIdOfBeginBallotMsg &gt; instanceIdOfSuccessMsg<br>  ]_&lt;&lt;<br>    priestStatus,<br>    ledgers,<br>    minUnusedInstanceIds,<br>    usedBallotIds,<br>    msgs&gt;&gt;<br><br>LivenessProperty ==<br>  &lt;&gt;(ledgers \in [PRIESTS -&gt; [INSTANCE_IDS -&gt; &#123;OliveDayDecree&#125; \union DECREES]])<br><br>Property ==<br>  /\ DecreeOrderingProperty<br>  /\ LivenessProperty<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* MultiDecreeParliament.cfg<br>CONSTANT<br>PRIESTS = &#123;p1, p2, p3&#125;<br>DECREES = &#123;d1, d2&#125;<br>INSTANCE_IDS = &#123;0, 1&#125;<br>BALLOT_IDS = &#123;0, 1&#125;<br><br>SPECIFICATION<br>Spec<br><br>INVARIANT<br>Invariant<br><br>PROPERTY<br>Property<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -Xms120g -XX:+UseParallelGC -XX:MaxDirectMemorySize=120g -Dtlc2.tool.fp.FPSet.impl=tlc2.tool.fp.OffHeapDiskFPSet -<span class="hljs-built_in">cp</span> /usr/local/lib/tla2tools.jar tlc2.TLC MultiDecreeParliament -workers auto -checkpoint 0<br><span class="hljs-comment"># TLC2 Version 2.18 of Day Month 20?? (rev: 5b3286b)</span><br><span class="hljs-comment"># Running breadth-first search Model-Checking with fp 2 and seed 183920139505302825 with 128 workers on 128 cores with 117760MB heap and 122880MB offheap memory [pid: 3237] (Linux 3.10.0-1160.90.1.el7.x86_64 amd64, Red Hat, Inc. 11.0.19 x86_64, OffHeapDiskFPSet, DiskStateQueue).</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># Starting... (2023-07-23 23:20:11)</span><br><span class="hljs-comment"># Implied-temporal checking--satisfiability problem has 1 branches.</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># Checking temporal properties for the current state space with 61839191 total distinct states at (2023-07-24 01:43:52)</span><br><span class="hljs-comment"># Finished checking temporal properties in 16min 08s at 2023-07-24 02:00:01</span><br><span class="hljs-comment"># ...</span><br><span class="hljs-comment"># Checking temporal properties for the complete state space with 65659825 total distinct states at (2023-07-24 02:12:19)</span><br><span class="hljs-comment"># Finished checking temporal properties in 18min 19s at 2023-07-24 02:30:38</span><br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = .0025</span><br><span class="hljs-comment">#   based on the actual fingerprints:  val = .0019</span><br><span class="hljs-comment"># 763561969 states generated, 65659825 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 33.</span><br><span class="hljs-comment"># The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 13 and the 95th percentile is 3).</span><br><span class="hljs-comment"># Finished in 03h 10min at (2023-07-24 02:30:44)</span><br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><ul><li><a href="https://clcanny.github.io/2023/06/26/computer-science/programming-language/tla+/the-beginner-s-guide-to-tla+-specifying-and-verifying-distributed-systems/">The Beginner's Guide to TLA+: Specifying and Verifying Distributed Systems</a></li><li><a href="https://github.com/tlaplus/tlaplus/issues/636">tlaplus/tlaplus: When checking liveness, TLC can stall with 0s/min when behavior graph gets huge</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>TLA+</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The Beginner&#39;s Guide to TLA+: Specifying and Verifying Distributed Systems</title>
    <link href="/2023/06/26/computer-science/programming-language/tla+/the-beginner-s-guide-to-tla+-specifying-and-verifying-distributed-systems/"/>
    <url>/2023/06/26/computer-science/programming-language/tla+/the-beginner-s-guide-to-tla+-specifying-and-verifying-distributed-systems/</url>
    
    <content type="html"><![CDATA[<p><a href="https://lamport.azurewebsites.net/video/videos.html">The TLA+ Video Course</a> is excellent material for learning TLA+. However, the most effective way to learn something new is to try it out, fail, and try again. This post is a record of what I've learned from trying out some of the TLA+ examples from that course.</p><h2 id="running-tla-from-the-command-line-on-linux">Running TLA+ from the Command Line on Linux</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> amazoncorretto:11 bash<br>yum install -y git<br>git <span class="hljs-built_in">clone</span> https://github.com/pmer/tla-bin.git<br><span class="hljs-built_in">cd</span> tla-bin<br>./download_or_update_tla.sh --nightly<br>./install.sh<br>tlc -<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h2 id="simpleprogram">SimpleProgram</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  i = <span class="hljs-built_in">someNumber</span>();<br>  i = i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs tla+">--------------------------- MODULE SimpleProgram ---------------------------<br>\* SimpleProgram.tla<br>EXTENDS Integers<br>VARIABLES i, pc<br><br>Init ==<br>  /\ pc = &quot;start&quot;<br>  /\ i = 0<br><br>PhaseMiddle ==<br>  /\ pc = &quot;start&quot;<br>  /\ pc&#x27; = &quot;middle&quot;<br>  /\ i&#x27; \in 1..1000<br><br>PhaseDone ==<br>  /\ pc = &quot;middle&quot;<br>  /\ pc&#x27; = &quot;done&quot;<br>  /\ i&#x27; = i + 1<br><br>Next ==<br>  \/ PhaseMiddle<br>  \/ PhaseDone<br>  \* The simplest formula that does not equal true<br>  \* for any values of pc, i, pc&#x27;, i&#x27;.<br>  \* This formula essentially means &quot;there are no possible next states&quot;.<br>  \/ FALSE<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* SimpleProgram.cfg<br>INIT<br>Init<br><br>NEXT<br>Next<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlc SimpleProgram.tla -config SimpleProgram.cfg -deadlock<br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = 0.0</span><br><span class="hljs-comment"># 2001 states generated, 2001 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 3.</span><br></code></pre></td></tr></table></figure><h2 id="die-hard">Die Hard</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs tla+">--------------------------- MODULE DieHard ---------------------------------<br>\* DieHard.tla<br>EXTENDS Integers<br>VARIABLES three_gallon_jug, five_gallon_jug<br><br>Init ==<br>  /\ three_gallon_jug = 0<br>  /\ five_gallon_jug = 0<br><br>MakeThreeGallonJugFull ==<br>  /\ three_gallon_jug&#x27; = 3<br>  /\ five_gallon_jug&#x27; = five_gallon_jug<br><br>MakeFiveGallonJugFull ==<br>  /\ three_gallon_jug&#x27; = three_gallon_jug<br>  /\ five_gallon_jug&#x27; = 5<br><br>MakeThreeGallonJugEmpty ==<br>  /\ three_gallon_jug&#x27; = 0<br>  /\ five_gallon_jug&#x27; = five_gallon_jug<br><br>MakeFiveGallonJugEmpty ==<br>  /\ three_gallon_jug&#x27; = three_gallon_jug<br>  /\ five_gallon_jug&#x27; = 0<br><br>PourFromFiveGallonJugToThreeGallonJug ==<br>  /\ three_gallon_jug&#x27; =<br>    IF three_gallon_jug + five_gallon_jug &lt; 3<br>      THEN three_gallon_jug + five_gallon_jug<br>      ELSE 3<br>  /\ five_gallon_jug&#x27; =<br>    IF three_gallon_jug + five_gallon_jug &lt; 3<br>      THEN 0<br>      ELSE five_gallon_jug - (3 - three_gallon_jug)<br><br>PourFromThreeGallonJugToFiveGallonJug ==<br>  /\ three_gallon_jug&#x27; =<br>    IF five_gallon_jug + three_gallon_jug &lt; 5<br>      THEN 0<br>      ELSE three_gallon_jug - (5 - five_gallon_jug)<br>  /\ five_gallon_jug&#x27; =<br>    IF five_gallon_jug + three_gallon_jug &lt; 5<br>      THEN five_gallon_jug + three_gallon_jug<br>      ELSE 5<br><br>Next ==<br>  \/ MakeThreeGallonJugFull<br>  \/ MakeFiveGallonJugFull<br>  \/ MakeThreeGallonJugEmpty<br>  \/ MakeFiveGallonJugEmpty<br>  \/ PourFromFiveGallonJugToThreeGallonJug<br>  \/ PourFromThreeGallonJugToFiveGallonJug<br><br>TypeOK ==<br>  /\ three_gallon_jug \in 0..3<br>  /\ five_gallon_jug \in 0..5<br><br>FiveGallonJugIsFour ==<br>  five_gallon_jug /= 4<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* DieHard.cfg<br>INIT<br>Init<br><br>NEXT<br>Next<br><br>INVARIANT<br>TypeOK<br>FiveGallonJugIsFour<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlc DieHard.tla -config DieHard.cfg<br><span class="hljs-comment"># Error: Invariant FiveGallonJugIsFour is violated.</span><br><span class="hljs-comment"># Error: The behavior up to this point is:</span><br><span class="hljs-comment"># State 1: &lt;Initial predicate&gt;</span><br><span class="hljs-comment"># /\ three_gallon_jug = 0</span><br><span class="hljs-comment"># /\ five_gallon_jug = 0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># State 2: &lt;MakeFiveGallonJugFull line 15, col 3 to line 16, col 25 of module DieHard&gt;</span><br><span class="hljs-comment"># /\ three_gallon_jug = 0</span><br><span class="hljs-comment"># /\ five_gallon_jug = 5</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># State 3: &lt;PourFromFiveGallonJugToThreeGallonJug line 27, col 3 to line 34, col 51 of module DieHard&gt;</span><br><span class="hljs-comment"># /\ three_gallon_jug = 3</span><br><span class="hljs-comment"># /\ five_gallon_jug = 2</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># State 4: &lt;MakeThreeGallonJugEmpty line 19, col 3 to line 20, col 39 of module DieHard&gt;</span><br><span class="hljs-comment"># /\ three_gallon_jug = 0</span><br><span class="hljs-comment"># /\ five_gallon_jug = 2</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># State 5: &lt;PourFromFiveGallonJugToThreeGallonJug line 27, col 3 to line 34, col 51 of module DieHard&gt;</span><br><span class="hljs-comment"># /\ three_gallon_jug = 2</span><br><span class="hljs-comment"># /\ five_gallon_jug = 0</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># State 6: &lt;MakeFiveGallonJugFull line 15, col 3 to line 16, col 25 of module DieHard&gt;</span><br><span class="hljs-comment"># /\ three_gallon_jug = 2</span><br><span class="hljs-comment"># /\ five_gallon_jug = 5</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># State 7: &lt;PourFromFiveGallonJugToThreeGallonJug line 27, col 3 to line 34, col 51 of module DieHard&gt;</span><br><span class="hljs-comment"># /\ three_gallon_jug = 3</span><br><span class="hljs-comment"># /\ five_gallon_jug = 4</span><br></code></pre></td></tr></table></figure><h2 id="transaction-commit">Transaction Commit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs tla+">--------------------------- MODULE TransactionCommit -----------------------<br>\* TransactionCommit.tla<br>EXTENDS Integers<br>CONSTANTS RM<br>VARIABLES rmState<br><br>\* The TLA+ syntax for an array expression:<br>\* [variable \in set |-&gt; expression]<br>\*<br>\* https://www.learntla.com/core/functions.html#function<br>\* First of all, throw away the programming definition of &quot;function&quot;.<br>\* The closest thing TLA+ has to a programmatic function are operators.<br>\* A function follows the mathematical definition,<br>\* a mapping of values in one set to another set.<br>\* e.g., F == [x \in S |-&gt; expr]<br>\* The set we&#x27;re mapping from, S, is the domain of the function,<br>\* and can be retrieved by writing DOMAIN F.<br>\*<br>\* https://www.learntla.com/core/functions.html#using-functions<br>\* Why functions over operators?<br>\* We rarely use functions for computations -<br>\* operators are far superior for that.<br>\* Functions are important as values.<br>\* We can assign them to variables and manipulate them like any other value.<br>Init == rmState = [rm \in RM |-&gt; &quot;working&quot;]<br><br>Prepare(r) ==<br>  /\ rmState[r] = &quot;working&quot;<br>  \* rmState&#x27;[r] = &quot;prepared&quot; is wrong.<br>  \* This formula says the value of rmState[r] in the new state is &quot;prepared&quot;.<br>  \* It says nothing about the value of rmState[s] in the new state<br>  \* for an RM s with s != r.<br>  \*<br>  \* rmState&#x27; = [s \in RM |-&gt; IF s = r THEN &quot;prepared&quot; ELSE rmState[s]]<br>  \* This is correct, but it&#x27;s too long-winded.<br>  \* We need a shorter way to write this expression.<br>  \* TLA+ provides this EXCEPT construct. Everyone hates it.<br>  \* What does the exclamation point (usually read as bang) mean?<br>  \* It means nothing. It&#x27;s just syntax. But you&#x27;ll get used to it.<br>  /\ rmState&#x27; = [rmState EXCEPT ![r] = &quot;prepared&quot;]<br>DecideToCommit(r) ==<br>  /\ rmState[r] = &quot;prepared&quot;<br>  \* We have to change the bound variable r to some other variable like s<br>  \* to avoid a name conflict with this r.<br>  \*<br>  \* The scope of \A and \E extends as far as possible.<br>  \* The expression \A x \in S: ... extends<br>  \* to the end of its enclosing expression unless explicitly ended<br>  \* - by parentheses, (\A x \in S: ...)<br>  \* - or by similar brackets or braces<br>  \* - or by the end of a list item (which adds implicit parentheses),<br>  \*   /\<br>  \*   /\ \A x \in S: ...<br>  \*   /\<br>  \* - e.g., This expression<br>  \*      \A x \in S: ...<br>  \*   /\ \A x \in T: ...<br>  \*   is parsed like this \A x \in S: (... \A x \in T: ...).<br>  /\ (\A s \in RM: rmState[s] \in &#123;&quot;prepared&quot;, &quot;committed&quot;&#125;)<br>  /\ rmState&#x27; = [rmState EXCEPT ![r] = &quot;committed&quot;]<br>DecideToAbort(r) ==<br>  /\ rmState[r] \in &#123;&quot;working&quot;, &quot;prepared&quot;&#125;<br>  \* DecideToAbort(r) depends on the states of all the resource managers.<br>  \* How can this be implemented?<br>  \* What programming language allows a single step<br>  \* to examine the states of a whole set of processes?<br>  \* We don&#x27;t care.<br>  \* We&#x27;re writing a spec of what transaction commit should do,<br>  \* not how it’s implemented.<br>  /\ (\A s \in RM: rmState[s] /= &quot;committed&quot;)<br>  /\ rmState&#x27; = [rmState EXCEPT ![r] = &quot;aborted&quot;]<br>Next ==<br>  \E r \in RM:<br>    \/ Prepare(r)<br>    \/ DecideToCommit(r)<br>    \/ DecideToAbort(r)<br><br>TypeOK ==<br>  \* https://www.learntla.com/core/functions.html#using-functions<br>  \* In a spec I once wrote, I had to assign tasks to CPUs.<br>  \* Some tasks needed to be assigned to many CPUs,<br>  \* but each CPU should only have one task.<br>  \* In that spec, the best solution was to store assignments as functions,<br>  \* where each task mapped to a set of CPUs.<br>  \* variables<br>  \*   assignments = [t \in Tasks |-&gt; &#123;&#125;]<br>  \* Then I could write assignment[t] := assignment[t] \union &#123;cpu&#125;<br>  \* to assign cpu to task t.<br>  \* For my invariant, I said no two tasks shared a CPU assignment.<br>  \* OnlyOneTaskPerCpu ==<br>  \*   \A t1, t2 \in Tasks, c \in CPU:<br>  \*     /\ (t1 # t2)<br>  \*     /\ c \in assignments[t1]<br>  \*     =&gt; c \notin assignments[t2]<br>  \*<br>  \* https://www.learntla.com/core/functions.html#function-sets<br>  \* The syntax for function sets is [S -&gt; T]<br>  \* (T is sometimes referred to as the &quot;codomain&quot;) and<br>  \* is &quot;every function where the domain is S and all of the values are in T.&quot;<br>  \* In the prior task example, assignments was always a function<br>  \* in the function set [Tasks -&gt; SUBSET CPUs].<br>  \* A function set of form [A -&gt; B] will have B^A elements in it.<br>  \* If there were two tasks and three CPUs,<br>  \* that would be (2^3)^2 = 64 (B = 8, A = 2) possible functions.<br>  \* A good way to remember this: [1..n -&gt; BOOLEAN] is<br>  \* the set of all binary strings of length n,<br>  \* and we know there are 2^n such strings.<br>  \*<br>  \* The set of all arrays indexed by elements of RM<br>  \* with values in &#123;&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;&#125;.<br>  rmState \in [RM -&gt; &#123;&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;&#125;]<br><br>Consistent ==<br>  \* An abbreviation for \A r1 \in RM: \A r2 \in RM:<br>  \A r1, r2 \in RM:<br>    ~ /\ rmState[r1] = &quot;aborted&quot;<br>      /\ rmState[r2] = &quot;committed&quot;<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* TransactionCommit.cfg<br>CONSTANT<br>RM = &#123;&quot;rm1&quot;, &quot;rm2&quot;, &quot;rm3&quot;&#125;<br><br>INIT<br>Init<br><br>NEXT<br>Next<br><br>INVARIANT<br>TypeOK<br>Consistent<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlc TransactionCommit.tla -config TransactionCommit.cfg -deadlock<br><span class="hljs-comment"># # Always be suspicious of success.</span><br><span class="hljs-comment"># # Check the statistics of the TLC run.</span><br><span class="hljs-comment"># # Did TLC find a reasonable number of states</span><br><span class="hljs-comment"># # that can be reached by behaviors?</span><br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = 1.1E-16</span><br><span class="hljs-comment"># 94 states generated, 34 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 7.</span><br></code></pre></td></tr></table></figure><h2 id="two-phase">Two Phase</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs tla">--------------------------- MODULE TwoPhase --------------------------------<br>\* TwoPhase.tla<br>EXTENDS Integers<br>CONSTANTS RM<br>VARIABLES rmState, tmState, tmPrepared, msgs<br><br>\* https://www.learntla.com/core/functions.html#structures<br>\* In TLA+, this is the struct:<br>\* st == [a |-&gt; 1, b |-&gt; &#123;&#125;]<br>\* You index structs the same way you do sequences so st[&quot;a&quot;] = 1.<br>\* You can also write it in a more &quot;object&quot; like with a dot instead: st.a = 1.<br>\* We want some way to generate sets of structs,<br>\* so we can stick them in our type invariants. Here’s how:<br>\* BankTransactionType == [acct: Accounts,<br>\*                         amnt: 1..10,<br>\*                         type: &#123;&quot;deposit&quot;, &quot;withdraw&quot;&#125;]<br>\* This is the set of all structures<br>\* where s.acct \in Accounts, s.amnt \in 1..10, etc.<br>\*<br>\* https://www.learntla.com/core/functions.html#getting-a-struct-s-keys<br>\* Both sequences and structures are just syntactic sugar.<br>\* TLA+ has only two &quot;real&quot; collections: sets and functions.<br>\* Sequences and structures are both particular classes of functions.<br>\*<br>\* https://www.learntla.com/core/functions.html#function<br>\* F == [x \in S |-&gt; expr]<br>\* The set we&#x27;re mapping from, S, is the domain of the function,<br>\* and can be retrieved by writing DOMAIN F.<br>\* That&#x27;s why we could also use DOMAIN with sequences and structures:<br>\* 1. A sequence is just a function where the domain is 1..n.<br>\* 2. A struct is just a function where the domain is a set of strings.<br>\*<br>\* https://lamport.azurewebsites.net/video/video6-script.pdf<br>\* A record corresponds roughly to a Struct in C.<br>\* The definition r == [prof |-&gt; &quot;Fred&quot;, num |-&gt; 42]<br>\* defines r to be a record with two fields prof and num.<br>\* This record is actually a function, let&#x27;s call it f,<br>\* whose domain is the set containing the two strings prof and num,<br>\* such that f of the string prof equals the string &quot;Fred&quot; and<br>\* f of the string num equals the number 42.<br>\*<br>\* [f EXCEPT ![&quot;prof&quot;] = &quot;Red&quot;]<br>\* This EXCEPT expression equals the record that&#x27;s the same as f<br>\* except its prof field equals the string Red.<br>\* It can be abbreviated as [f EXCEPT !.prof = &quot;Red&quot;]<br>Messages ==<br>         [type: &#123;&quot;Prepared&quot;&#125;, rm: RM]<br>  \* &#123;[type |-&gt; &quot;Commit&quot;], [type |-&gt; &quot;Abort&quot;]&#125;<br>  \* Each record represents a message sent by the TM to all RMs.<br>  \union [type: &#123;&quot;Commit&quot;, &quot;Abort&quot;&#125;]<br><br>Init ==<br>  /\ rmState = [rm \in RM |-&gt; &quot;working&quot;]<br>  /\ tmState = &quot;init&quot;<br>  /\ tmPrepared = &#123;&#125;<br>  /\ msgs = &#123;&#125;<br><br>TMRcvPreparedMsg(r) ==<br>  \* These two conjunctions have no primes.<br>  \* They&#x27;re conditions on the first state of a step.<br>  \* They&#x27;re called enabling conditions of the formula.<br>  \* Enabling conditions should almost always go at the beginning of<br>  \* an action formula – a formula that contains primed variables.<br>  \* That makes the formula easier to understand,<br>  \* and TLC often can&#x27;t handle the action formula if you don&#x27;t.<br>  /\ tmState = &quot;init&quot;<br>  /\ [type |-&gt; &quot;Prepared&quot;, rm |-&gt; r] \in msgs<br>  \* An action formula.<br>  /\ tmPrepared&#x27; = tmPrepared \union &#123;r&#125;<br>  \* It asserts rmState, tmState, and msgs are left unchanged,<br>  \* which is equivalent to<br>  \* /\ rmState&#x27; = rmState<br>  \* /\ tmState&#x27; = tmState<br>  \* /\ msgs&#x27; = msgs<br>  \* The step doesn&#x27;t remove the message from msgs.<br>  /\ UNCHANGED &lt;&lt;rmState, tmState, msgs&gt;&gt;<br><br>TMDecideToCommit ==<br>  /\ tmState = &quot;init&quot;<br>  /\ RM \subseteq tmPrepared<br>  /\ tmState&#x27; = &quot;done&quot;<br>  \* Since two-phase commit requires no assumptions about the order in which<br>  \* different messages are received, the simplest natural representation<br>  \* is to let msgs be a single set containing all messages in transit.<br>  \* Receiving a message removes it from the set msgs.<br>  \* There&#x27;s a simpler method that&#x27;s not obvious to most people.<br>  \* It&#x27;s to let msgs be the set of all messages that have ever been sent.<br>  \* So the action of receiving a message<br>  \* doesn&#x27;t remove the message from the set.<br>  \* 1. One advantage is that a single message in msgs<br>  \*    can be received by several processes.<br>  \* 2. It also means that a process can<br>  \*    received the same message multiple times.<br>  \*    This can happen with real message passing, and it’s useful to know that<br>  \*    the two-phase commit protocol still works even if it does happen.<br>  /\ msgs&#x27; = msgs \union [type: &#123;&quot;Commit&quot;&#125;]<br>  /\ UNCHANGED &lt;&lt;rmState, tmPrepared&gt;&gt;<br><br>TMDecideToAbort ==<br>  /\ tmState = &quot;init&quot;<br>  /\ tmState&#x27; = &quot;done&quot;<br>  /\ msgs&#x27; = msgs \union [type: &#123;&quot;Abort&quot;&#125;]<br>  /\ UNCHANGED &lt;&lt;rmState, tmPrepared&gt;&gt;<br><br>RMPrepare(r) ==<br>  /\ rmState[r] = &quot;working&quot;<br>  /\ rmState&#x27; = [rmState EXCEPT ![r] = &quot;prepared&quot;]<br>  /\ msgs&#x27; = msgs \union [type: &#123;&quot;Prepared&quot;&#125;, rm: &#123;r&#125;]<br>  /\ UNCHANGED &lt;&lt;tmState, tmPrepared&gt;&gt;<br><br>RMDecideToAbort(r) ==<br>  /\ rmState[r] = &quot;working&quot;<br>  /\ rmState&#x27; = [rmState EXCEPT ![r] = &quot;aborted&quot;]<br>  /\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;<br><br>RMRcvCommitMsg(r) ==<br>  /\ rmState[r] = &quot;prepared&quot;<br>  /\ [type |-&gt; &quot;Commit&quot;] \in msgs<br>  /\ rmState&#x27; = [rmState EXCEPT ![r] = &quot;committed&quot;]<br>  /\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;<br><br>RMRcvAbortMsg(r) ==<br>  /\ rmState[r] \in &#123;&quot;working&quot;, &quot;prepared&quot;&#125;<br>  /\ [type |-&gt; &quot;Abort&quot;] \in msgs<br>  /\ rmState&#x27; = [rmState EXCEPT ![r] = &quot;aborted&quot;]<br>  /\ UNCHANGED &lt;&lt;tmState, tmPrepared, msgs&gt;&gt;<br><br>Next ==<br>  \/ TMDecideToCommit<br>  \/ TMDecideToAbort<br>  \/ (\E r \in RM:<br>        \/ TMRcvPreparedMsg(r)<br>        \/ RMPrepare(r)<br>        \/ RMDecideToAbort(r)<br>        \/ RMRcvCommitMsg(r)<br>        \/ RMRcvAbortMsg(r))<br><br>TypeOK ==<br>  /\ rmState \in [RM -&gt; &#123;&quot;working&quot;, &quot;prepared&quot;, &quot;committed&quot;, &quot;aborted&quot;&#125;]<br>  /\ tmState \in &#123;&quot;init&quot;, &quot;done&quot;&#125;<br>  /\ tmPrepared \subseteq RM<br>  /\ msgs \subseteq Messages<br><br>Consistent == \A r1, r2 \in RM:<br>  ~ (/\ rmState[r1] = &quot;committed&quot;<br>     /\ rmState[r2] = &quot;aborted&quot;)<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* TwoPhase.cfg<br>CONSTANT<br>RM = &#123;&quot;rm1&quot;, &quot;rm2&quot;, &quot;rm3&quot;&#125;<br><br>INIT<br>Init<br><br>NEXT<br>Next<br><br>INVARIANT<br>TypeOK<br>Consistent<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlc TwoPhase.tla -config TwoPhase.cfg -deadlock<br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = 8.1E-15</span><br><span class="hljs-comment"># 810 states generated, 288 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 11.</span><br></code></pre></td></tr></table></figure><h2 id="synod-basic-protocol">Synod Basic Protocol</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br></pre></td><td class="code"><pre><code class="hljs tla">--------------------------- MODULE SynodBasicProtocol ----------------------<br>\* SynodBasicProtocol.tla<br>EXTENDS Integers, FiniteSets, TLC<br>CONSTANTS PRIESTS, DECREES, BALLOT_IDS<br>VARIABLES priestStatus, ledgers, usedBallotIds, msgs<br><br>\* https://github.com/tlaplus/tlaplus/issues/404<br>SYMM == Permutations(PRIESTS) \union Permutations(DECREES)<br>\* I am uncertain whether or not BALLOT_IDS qualifies as a symmetry set.<br>\* \union Permutations(BALLOT_IDS)<br><br>\* This ASSUME statement asserts assumptions being made about the constants.<br>ASSUME<br>  /\ BALLOT_IDS \subseteq Nat<br>  /\ IsFiniteSet(BALLOT_IDS)<br><br>BlankDecree == &quot;BLANK&quot;<br><br>GetQuorum(ballotId) ==<br>  &#123;m.to: m \in &#123;m \in msgs: m.type = &quot;BeginBallot&quot; /\ m.ballotId = ballotId&#125;&#125;<br><br>GetDecree(ballotId) ==<br>  (CHOOSE m \in msgs: m.type = &quot;BeginBallot&quot; /\ m.ballotId = ballotId).decree<br><br>Init ==<br>  /\ priestStatus =<br>    [<br>      p \in PRIESTS |-&gt;<br>      [<br>        lastTriedBallotId |-&gt; -1,<br>        prevVote          |-&gt;<br>          [priest |-&gt; p, ballotId |-&gt; -1, decree |-&gt; BlankDecree],<br>        nextBallotId      |-&gt; -1<br>      ]<br>    ]<br>  /\ ledgers = [p \in PRIESTS |-&gt; [decree |-&gt; BlankDecree]]<br>  /\ usedBallotIds = &#123;&#125;<br>  /\ msgs = &#123;&#125;<br><br>\* Step (1)<br>\* Priest $p$ chooses a new ballot number $b$<br>\* greater than $\operatorname&#123;lastTried&#125;(p)$,<br>\* sets $\operatorname&#123;lastTried&#125;(p)$ to $b$,<br>\* and sends a $\operatorname&#123;NextBallot&#125;(b)$ message<br>\* to some set of priests.<br>SendNextBallotMsg(p) ==<br>  \* This set minus operator is defined as follows.<br>  \* For any sets S and T,<br>  \* S set minus T is the set of all elements in S that are not in T.<br>  \E b \in BALLOT_IDS \ usedBallotIds:<br>    /\ ledgers[p].decree = BlankDecree<br>    \* The following use of CHOOSE is incorrect:<br>    \* b == CHOOSE n \in availBallotIds: n &gt; priestStatus[p].lastTriedBallotId<br>    \* Because there may be multiple values in availBallotIds that<br>    \* satisfy n &gt; priestStatus[p].lastTriedBallotId.<br>    \* Instead, EXISTS should be used here.<br>    \* The difference between CHOOSE and EXISTS will be explained later.<br>    /\ b &gt; priestStatus[p].lastTriedBallotId<br>    /\ priestStatus&#x27; =<br>      [priestStatus EXCEPT ![p].lastTriedBallotId = b]<br>      \* The expression above is a shorter way to say<br>      \* the same thing as the next expression.<br>      \* [<br>      \*   priestStatus EXCEPT ![p] =<br>      \*     [priestStatus[p] EXCEPT !.lastTriedBallotId = b]<br>      \* ]<br>    /\ usedBallotIds&#x27; = usedBallotIds \union &#123;b&#125;<br>    /\ msgs&#x27; = msgs \union<br>      &#123;[<br>        type     |-&gt; &quot;NextBallot&quot;,<br>        ballotId |-&gt; b<br>      ]&#125;<br>    /\ UNCHANGED &lt;&lt;ledgers&gt;&gt;<br><br>\* Step (2)<br>\* Upon receipt of a $\operatorname&#123;NextBallot&#125;(b)$ message from $p$<br>\* with $b &gt; \operatorname&#123;nextBal&#125;(q)$,<br>\* priest $q$ sets $\operatorname&#123;nextBal&#125;(q)$ to $b$ and<br>\* sends a $\operatorname&#123;LastVote&#125;(b, v)$ message to $p$,<br>\* where $v$ equals $\operatorname&#123;prevVote&#125;(q)$.<br>ReceiveNextBallotMsg(q) ==<br>  \E b \in BALLOT_IDS:<br>    /\ [type |-&gt; &quot;NextBallot&quot;, ballotId |-&gt; b] \in msgs<br>    /\ b &gt; priestStatus[q].nextBallotId<br>    /\ priestStatus&#x27; =<br>      [priestStatus EXCEPT ![q].nextBallotId = b]<br>      \* The expression above is a shorter way to say<br>      \* the same thing as the next expression.<br>      \* [priestStatus EXCEPT ![q] = [priestStatus[q] EXCEPT !.nextBallotId = b]]<br>    /\ msgs&#x27; = msgs \union &#123;[<br>        type     |-&gt; &quot;LastVote&quot;,<br>        ballotId |-&gt; b,<br>        vote     |-&gt; priestStatus[q].prevVote<br>      ]&#125;<br>    /\ UNCHANGED &lt;&lt;ledgers, usedBallotIds&gt;&gt;<br><br>\* Step (3)<br>\* After receiving a $\operatorname&#123;LastVote&#125;(b, v)$ message<br>\* from every priest in some majority set $Q$,<br>\* where $b = \operatorname&#123;lastTried&#125;(p)$,<br>\* priest $p$ initiates a new ballot<br>\* with number $b$, quorum $Q$, and decree $d$,<br>\* where $d$ is chosen to satisfy $\operatorname&#123;B3&#125;$.<br>\* He then sends a $\operatorname&#123;BeginBallot&#125;(b, d)$ message<br>\* to every priest in $Q$.<br>ReceiveLastVoteMsg(p) ==<br>  \* SUBSET PRIESTS is the set of all subsets of the set PRIESTS.<br>  \* Mathematicians call it the powerset of PRIESTS and<br>  \* write it \mathcal&#123;P&#125;(Acceptor).<br>  \E majority \in SUBSET PRIESTS, dec \in DECREES:<br>    \* The LET clause makes these definitions local to the let-in expression.<br>    \* The defined identifiers can be used only in the expression.<br>    LET<br>      b == priestStatus[p].lastTriedBallotId<br>      \* https://www.learntla.com/core/operators.html#map-and-filter<br>      lastVoteMsgs ==<br>        &#123;<br>          m \in msgs:<br>            /\ m.type = &quot;LastVote&quot;<br>            /\ m.ballotId = b<br>            /\ m.vote.priest \in majority<br>        &#125;<br>      v ==<br>        (CHOOSE m \in lastVoteMsgs:<br>          \A n \in lastVoteMsgs:<br>            m.vote.ballotId &gt;= n.vote.ballotId).vote<br>      d ==<br>        IF v.ballotId = -1 /\ v.decree = BlankDecree<br>          THEN dec<br>          ELSE v.decree<br>    IN<br>      /\ &#123;m \in msgs: m.type = &quot;BeginBallot&quot; /\ m.ballotId = b&#125; = &#123;&#125;<br>      \* https://www.learntla.com/core/operators.html#map-and-filter<br>      /\ &#123;m.vote.priest: m \in lastVoteMsgs&#125; = majority<br>      /\ Cardinality(majority) * 2 &gt; Cardinality(PRIESTS)<br>      /\ msgs&#x27; = msgs \union<br>        [<br>          type     : &#123;&quot;BeginBallot&quot;&#125;,<br>          ballotId : &#123;b&#125;,<br>          decree   : &#123;d&#125;,<br>          to       : majority<br>        ]<br>      /\ UNCHANGED &lt;&lt;priestStatus, ledgers, usedBallotIds&gt;&gt;<br><br>\* Step (4)<br>\* Upon receipt of a $\operatorname&#123;BeginBallot&#125;(b, d)$ message<br>\* with $b = \operatorname&#123;nextBal&#125;(q)$,<br>\* priest $q$ casts his vote in ballot number $b$,<br>\* sets $\operatorname&#123;prevVote&#125;(q)$ to this vote,<br>\* and sends a $\operatorname&#123;Voted&#125;(b, q)$ message to $p$.<br>ReceiveBeginBallotMsg(q) ==<br>  \E d \in DECREES:<br>    LET<br>      b == priestStatus[q].nextBallotId<br>    IN<br>      /\<br>        [<br>          type     |-&gt; &quot;BeginBallot&quot;,<br>          ballotId |-&gt; b,<br>          decree   |-&gt; d,<br>          to       |-&gt; q<br>        ] \in msgs<br>      /\ priestStatus&#x27; =<br>        [<br>          priestStatus EXCEPT ![q].prevVote.priest = q,<br>                              ![q].prevVote.ballotId = b,<br>                              ![q].prevVote.decree = d<br>        ]<br>        \* The expression above is a shorter way to say<br>        \* the same thing as the next expression.<br>        \* [<br>        \*   priestStatus EXCEPT ![q] =<br>        \*     [<br>        \*       priestStatus[q] EXCEPT !.prevVote =<br>        \*         [priest |-&gt; q, ballotId |-&gt; b, decree |-&gt; d]<br>        \*     ]<br>        \* ]<br>      /\ msgs&#x27; = msgs \union<br>        &#123;[<br>          type     |-&gt; &quot;Voted&quot;,<br>          ballotId |-&gt; b,<br>          from     |-&gt; q<br>        ]&#125;<br>      /\ UNCHANGED &lt;&lt;ledgers, usedBallotIds&gt;&gt;<br><br>\* Step (5)<br>\* If $p$ has received a $\operatorname&#123;Voted&#125;(b, q)$ message<br>\* from every priest $q$ in $Q$ (the quorum for ballot number $b$),<br>\* where $b = \operatorname&#123;lastTried&#125;(p)$,<br>\* then he writes $d$ (the decree of that ballot) in his ledger and<br>\* sends a $\operatorname&#123;Success&#125;(d)$ message to every priest.<br>ReceiveVotedMsg(p) ==<br>  LET<br>    b == priestStatus[p].lastTriedBallotId<br>    votedMsgs ==<br>      &#123;m \in msgs: m.type = &quot;Voted&quot; /\ m.ballotId = b&#125;<br>  IN<br>    /\ GetQuorum(b) # &#123;&#125;<br>    /\ &#123;m.from: m \in votedMsgs&#125; = GetQuorum(b)<br>    /\ ledgers[p].decree = BlankDecree<br>    /\ ledgers&#x27; = [ledgers EXCEPT ![p] = [decree |-&gt; GetDecree(b)]]<br>    /\ msgs&#x27; = msgs \union<br>      &#123;[<br>        type     |-&gt; &quot;Success&quot;,<br>        ballotId |-&gt; b,<br>        decree   |-&gt; GetDecree(b)<br>      ]&#125;<br>    /\ UNCHANGED &lt;&lt;priestStatus, usedBallotIds&gt;&gt;<br><br>\* Step (6)<br>\* Upon receiving a $\operatorname&#123;Success&#125;(d)$ message,<br>\* a priest enters decree $d$ in his ledger.<br>ReceiveSuccessMsg(q) ==<br>  LET<br>    successMsgs == &#123;m \in msgs: m.type = &quot;Success&quot;&#125;<br>    decrees == &#123;m.decree: m \in successMsgs&#125;<br>  IN<br>    /\ decrees # &#123;&#125;<br>    /\ ledgers[q].decree = BlankDecree<br>    /\ ledgers&#x27; =<br>        \* The Difference Between CHOOSE and EXISTS, and When to Use CHOOSE<br>        \* https://lamport.azurewebsites.net/video/video7-script.pdf<br>        \*<br>        \* x&#x27; \in 1..99<br>        \* The formula x&#x27; in the set 1..99 allows the value of x in the next<br>        \* state to be any of the 99 numbers from 1 to 99.<br>        \*<br>        \* CHOOSE i \in 1..99: TRUE<br>        \* The above expression equals an unspecified integer<br>        \* between 1 and 99. We don&#x27;t know which one.<br>        \* It might or might not equal 37; the semantics of TLA+ don&#x27;t say.<br>        \*<br>        \* However, there is no nondeterminism in a mathematical expression.<br>        \* Any expression always equals itself, including a CHOOSE expression.<br>        \* So this CHOOSE expression always equals itself:<br>        \* (CHOOSE i \in 1..99: TRUE) = (CHOOSE i \in 1..99: TRUE)<br>        \* If this CHOOSE expression equals 37 today,<br>        \* it will still equal 37 next week.<br>        \* TLC will always get the same number<br>        \* when it evaluates this expression.<br>        \* But you shouldn&#x27;t care what number.<br>        \*<br>        \* x&#x27; = CHOOSE i \in 1..99: TRUE<br>        \* The formula x&#x27; equals this CHOOSE expression allows<br>        \* the value of x in the next state to be some particular number<br>        \* between 1 and 99 — perhaps 37.<br>        \* There&#x27;s no reason why you&#x27;d ever want to write something like this.<br>        \* You should write this CHOOSE v \in S: P expression only when<br>        \* there&#x27;s exactly one value v in S satisfying formula P.<br>        \* Or when it&#x27;s part of a larger expression whose value<br>        \* doesn&#x27;t depend on which possible value of v is chosen.<br>        \* e.g., (CHOOSE m \in mset: m.bal = maxbal).val<br>        \* This CHOOSE expression can allow<br>        \* more than one possible choice for m.<br>        \* However, in any reachable state of the algorithm,<br>        \* all possible choices of m have the same value of m.val.<br>        [ledgers EXCEPT ![q] = [decree |-&gt; CHOOSE d \in decrees: TRUE]]<br>    /\ UNCHANGED &lt;&lt;priestStatus, usedBallotIds, msgs&gt;&gt;<br><br>Next == \E p \in PRIESTS:<br>  \/ SendNextBallotMsg(p)<br>  \/ ReceiveNextBallotMsg(p)<br>  \/ ReceiveLastVoteMsg(p)<br>  \/ ReceiveBeginBallotMsg(p)<br>  \/ ReceiveVotedMsg(p)<br>  \/ ReceiveSuccessMsg(p)<br><br>TypeOK ==<br>  LET<br>    validBallotIds == &#123;-1&#125; \union BALLOT_IDS<br>    validDecrees == &#123;BlankDecree&#125; \union DECREES<br>  IN<br>    /\ DOMAIN priestStatus = PRIESTS<br>    /\ \A p \in PRIESTS:<br>      priestStatus[p] \in<br>        [<br>          lastTriedBallotId : validBallotIds,<br>          prevVote          :<br>            [<br>              priest   : PRIESTS,<br>              ballotId : validBallotIds,<br>              decree   : validDecrees<br>            ],<br>          nextBallotId      : validBallotIds<br>        ]<br>    /\ ledgers \in [PRIESTS -&gt; [decree: validDecrees]]<br>    /\ usedBallotIds \subseteq BALLOT_IDS<br>    /\ msgs \subseteq<br>             [type: &#123;&quot;NextBallot&quot;&#125;, ballotId: BALLOT_IDS]<br>      \union [type     : &#123;&quot;LastVote&quot;&#125;,<br>              ballotId : BALLOT_IDS,<br>              vote     : [priest   : PRIESTS,<br>                          ballotId : validBallotIds,<br>                          decree   : validDecrees]]<br>      \union [type     : &#123;&quot;BeginBallot&quot;&#125;,<br>              ballotId : BALLOT_IDS,<br>              decree   : DECREES,<br>              to       : PRIESTS]<br>      \union [type     : &#123;&quot;Voted&quot;&#125;,<br>              ballotId : BALLOT_IDS,<br>              from     : PRIESTS]<br>      \union [type     : &#123;&quot;Success&quot;&#125;,<br>              ballotId : BALLOT_IDS,<br>              decree   : DECREES]<br><br>B1Consistent ==<br>  \* $\operatorname&#123;B1&#125;(\mathcal&#123;B&#125;)$<br>  \* Each ballot in $\mathcal&#123;B&#125;$ has a unique ballot number.<br>  /\ \A p1, p2 \in &#123;p \in PRIESTS: priestStatus[p].lastTriedBallotId # -1&#125;:<br>    \/ p1 = p2<br>    \/ priestStatus[p1].lastTriedBallotId # priestStatus[p2].lastTriedBallotId<br>  /\ \A m1, m2 \in &#123;m \in msgs: m.type = &quot;BeginBallot&quot;&#125;:<br>    \/ m1.decree = m2.decree<br>    \/ m1.ballotId # m2.ballotId<br><br>B2Consistent ==<br>  \* $\operatorname&#123;B2&#125;(\mathcal&#123;B&#125;)$<br>  \* The quorums of any two ballots in $\mathcal&#123;B&#125;$<br>  \* have at least one priest in common.<br>  \A m1, m2 \in &#123;m \in msgs: m.type = &quot;BeginBallot&quot;&#125;:<br>    GetQuorum(m1.ballotId) \intersect GetQuorum(m2.ballotId) # &#123;&#125;<br><br>B3Consistent ==<br>  \* $\operatorname&#123;B3&#125;(\mathcal&#123;B&#125;)$<br>  \* For every ballot $B$ in $\mathcal&#123;B&#125;$,<br>  \* if any priest in $B$&#x27;s quorum voted in an earlier ballot in $\mathcal&#123;B&#125;$,<br>  \* then the decree of $B$ equals<br>  \* the decree of the latest of those earlier ballots.<br>  \A beginBallotMsg \in &#123;m \in msgs: m.type = &quot;BeginBallot&quot;&#125;:<br>    LET<br>      quorum == GetQuorum(beginBallotMsg.ballotId)<br>      votedMsgs ==<br>        &#123;<br>          m \in msgs:<br>            /\ m.type = &quot;Voted&quot;<br>            /\ m.ballotId &lt; beginBallotMsg.ballotId<br>            /\ m.from \in quorum<br>        &#125;<br>    IN<br>      \/ votedMsgs = &#123;&#125;<br>      \/<br>        LET<br>          latestEarlierBallotId ==<br>            (CHOOSE latestMsg \in votedMsgs:<br>              \A m \in votedMsgs:<br>                latestMsg.ballotId &gt;= m.ballotId).ballotId<br>          latestEarlierDecree ==<br>            (CHOOSE m \in msgs:<br>              /\ m.type = &quot;BeginBallot&quot;<br>              /\ m.ballotId = latestEarlierBallotId).decree<br>        IN<br>          beginBallotMsg.decree = latestEarlierDecree<br><br>LemmaConsistent ==<br>  \* Lemma<br>  \* To show that these conditions imply consistency,<br>  \* the Paxons first showed that<br>  \* $\operatorname&#123;B1&#125;(\mathcal&#123;B&#125;)$ – $\operatorname&#123;B3&#125;(\mathcal&#123;B&#125;)$<br>  \* imply that, if a ballot $B$ in $\mathcal&#123;B&#125;$ is successful,<br>  \* then any later ballot in $\mathcal&#123;B&#125;$ is for the same decree as $B$.<br>  \A m1 \in &#123;m \in msgs: m.type = &quot;Success&quot;&#125;:<br>    \A m2 \in &#123;m \in msgs: m.type = &quot;BeginBallot&quot; /\ m.ballotId &gt; m1.ballodId&#125;:<br>      m2.decree = m1.decree<br><br>Theorem1Consistent ==<br>  \* Theorem 1<br>  \* Any two successful ballots are for the same decree.<br>  \A m1, m2 \in &#123;m \in msgs: m.type = &quot;Success&quot;&#125;: m1.decree = m2.decree<br><br>LedgerConsistent ==<br>  \A p1, p2 \in PRIESTS:<br>    \/ ledgers[p1].decree = BlankDecree<br>    \/ ledgers[p2].decree = BlankDecree<br>    \/ ledgers[p1] = ledgers[p2]<br><br>Consistent ==<br>  /\ B1Consistent<br>  /\ B2Consistent<br>  /\ B3Consistent<br>  /\ Theorem1Consistent<br>  /\ LedgerConsistent<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* SynodBasicProtocol-WithoutSymmetrySets.cfg<br>CONSTANT<br>PRIESTS = &#123;p1, p2, p3&#125;<br>DECREES = &#123;d1, d2, d3&#125;<br>\* Even a modest increase in the range of BALLOT_IDS,<br>\* from 0..2 to 0..10,<br>\* can significantly increase the number of possible distinct states.<br>BALLOT_IDS = &#123;0, 1, 2&#125;<br><br>INIT<br>Init<br><br>NEXT<br>Next<br><br>INVARIANT<br>TypeOK<br>Consistent<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_OPTS=<span class="hljs-string">&quot;-Xms80g -XX:+UseParallelGC&quot;</span><br>tlc SynodBasicProtocol.tla -config SynodBasicProtocol-WithoutSymmetrySets.cfg -deadlock -workers 40<br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = 6.2E-5</span><br><span class="hljs-comment">#   based on the actual fingerprints:  val = 9.9E-6</span><br><span class="hljs-comment"># 81223510 states generated, 18306583 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 28.</span><br><span class="hljs-comment"># The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 21 and the 95th percentile is 3).</span><br><span class="hljs-comment"># Finished in 07min 49s at (2023-07-08 21:12:20)</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* SynodBasicProtocol-WithSymmetrySets.cfg<br>CONSTANT<br>\* https://tla.msr-inria.inria.fr/tlatoolbox/doc/model/model-values.html<br>\* For example, the spec might have a constant Proc<br>\* whose value represents a set of processes.<br>\* You could just let a process be a number,<br>\* substituting an ordinary value like &#123;1, 2, 3&#125; for Proc.<br>\* However, a better way is to represent a process by a TLC model value.<br>\* A model value is an unspecified value that<br>\* TLC considers to be unequal to any value that you can express in TLA+.<br>\* You can substitute the set &#123;p1, p2, p3&#125; of three model values for Proc.<br>\* If by mistake you write an expression like p+1<br>\* where the value of p is a process,<br>\* TLC will report an error when it tries to evaluate that expression<br>\* because it knows that a process is a model value and thus not a number.<br>\* An important reason for substituting a set of model values for Proc is to<br>\* let TLC take advantage of symmetry.<br>PRIESTS = &#123;p1, p2, p3&#125;<br>DECREES = &#123;d1, d2, d3&#125;<br>BALLOT_IDS = &#123;0, 1, 2&#125;<br><br>SYMMETRY<br>SYMM<br><br>INIT<br>Init<br><br>NEXT<br>Next<br><br>INVARIANT<br>TypeOK<br>Consistent<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_OPTS=<span class="hljs-string">&quot;-Xms80g -XX:+UseParallelGC&quot;</span><br>tlc SynodBasicProtocol.tla -config SynodBasicProtocol-WithSymmetrySets.cfg -deadlock -workers 40<br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = 1.3E-7</span><br><span class="hljs-comment">#   based on the actual fingerprints:  val = 1.3E-7</span><br><span class="hljs-comment"># 3663798 states generated, 809615 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 28.</span><br><span class="hljs-comment"># The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 12 and the 95th percentile is 3).</span><br><span class="hljs-comment"># Finished in 31s at (2023-07-08 21:22:58)</span><br></code></pre></td></tr></table></figure><ul><li>According to the research paper <a href="https://www.researchgate.net/publication/304894406_The_Investigation_of_TLC_Model_Checker_Properties">ResearchGate: The Investigation of TLC Model Checker Properties</a>, there are two approaches for TLC method usage: the breadth-first search (BFS) of transition system states and the depth-first search (DFS). To optimize the search time, it is common to skip some states that have been searched before, such as:<ul><li>Equal states: If the TLC model checker has encountered the state <code>xs == &#123;x1, x2, x3&#125;</code> before, it does not need to search it again.</li><li>Symmetry states: For example, if the TLC model checker has searched the state <code>xs == [x1 |-&gt; 1, x2 |-&gt; 2, x3 |-&gt; 3]</code> and <strong>all</strong> subsequent expressions (e.g., <code>DOMAIN</code>) are symmetric for that state, then it does not need to search the symmetry state (e.g., <code>xs == [x3 |-&gt; 1, x2 |-&gt; 2, x1 |-&gt; 1]</code>, by interchanging <code>x1</code> and <code>x3</code>).<ul><li>Symmetry states are generated based on symmetry sets. However, the precise relationship between symmetry states and symmetry sets is unclear to me.</li></ul></li></ul></li><li>According to the guide <a href="https://tla.msr-inria.inria.fr/tlatoolbox/doc/model/model-values.html">The Microsoft Research-Inria Joint Center: Model Values and Symmetry</a>, a set <code>S</code> of model values should be declared as a symmetry set only if <strong>the specification and all properties</strong> being checked are symmetric for <code>S</code> after the substitutions for constants and defined operators specified by the model are made.<ul><li>An expression is symmetric for a set <code>S</code> if and only if interchanging any two values of <code>S</code> does not change the value of the expression. The expression <code>&#123;&#123;x1, x2&#125;, &#123;x1, x3&#125;, &#123;x2, x3&#125;&#125;</code> is symmetric for the set <code>&#123;x1, x2, x3&#125;</code> -- for example, interchanging <code>x1</code> and <code>x3</code> in this expression produces <code>&#123;&#123;x3, x2&#125;, &#123;x3, x1&#125;, &#123;x2, x1&#125;&#125;</code>, which is equal to the original expression.</li><li>According to <a href="https://lamport.azurewebsites.net/video/video7-script.pdf">TLA+ Video Course</a>, there are two criteria to determine if a set is a symmetry set:<ul><li>It's OK to use elements of a symmetry set in an expression assigned to another constant if the expression is symmetric in the elements of the symmetry set. There's one additional condition for symmetry sets.</li><li>Elements of a symmetry set, or a constant assigned elements of a symmetry set may not appear in a <code>CHOOSE</code> expression.</li></ul></li><li>I believe the reasons for these criteria are:<ul><li>A set itself exhibits symmetry. For example, <code>&#123;x1, x2, x3&#125;</code> = <code>&#123;x3, x2, x1&#125;</code>.</li><li>Declaring a constant that is constructed from the set and whose value depends on the ordering of elements in the set can break the symmetry. For example, the constant <code>&#123;&#123;x1, x2&#125;, &#123;x2, x3&#125;&#125;</code> makes the set <code>&#123;x1, x2, x3&#125;</code> not symmetric. This is because interchanging <code>x1</code> and <code>x2</code> yields <code>&#123;&#123;x2, x1&#125;, &#123;x1, x3&#125;&#125;</code>, which is not equal to the original constant <code>&#123;&#123;x1, x2&#125;, &#123;x2, x3&#125;&#125;</code>.</li><li>According to the guide <a href="https://tla.msr-inria.inria.fr/tlatoolbox/doc/model/model-values.html">The Microsoft Research-Inria Joint Center: Model Values and Symmetry</a>, the <strong>only</strong> TLA+ operator that can produce a non-symmetric expression when applied to a symmetric expression is <code>CHOOSE</code>. For example, the expression <code>CHOOSE x \in &#123;x1, x2, x3&#125;: TRUE</code> is not symmetric for <code>&#123;x1, x2, x3&#125;</code>.</li></ul></li></ul></li></ul><h2 id="ordinary-expressions">Ordinary Expressions</h2><p>The content of this section is derived from <a href="https://lamport.azurewebsites.net/video/video8a-script.pdf">the video script</a> for "The TLA+ Video Course, Lecture 8, Part 1" by Leslie Lamport.</p><p>A module-closed expression is a TLA+ expression that (after expanding definitions) contains only:</p><ul><li>built-in TLA+ operators and constructs,</li><li>numbers and strings, like 42 and "abc",</li><li>declared constants and variables,</li><li>identifiers declared locally within it.<ul><li>forall: <code>\A v \in S: ...</code></li><li>exists: <code>\E v \in S: ...</code></li><li>function constructor: <code>[v \in S |-&gt; ...]</code></li><li>set constructors: <code>&#123;v \in S: ...&#125;</code>, <code>&#123;...: v \in S&#125;</code></li></ul></li></ul><p><code>\E v \in Nat: x' = x + v</code> is module-complete if <code>x</code> is a declared variable. However, the subexpression <code>x' = x + v</code> is not module-complete because <code>v</code> is locally declared outside it.</p><p>A module-closed formula is a Boolean-valued module-closed expression. That is, one whose value is either <code>TRUE</code> or <code>FALSE</code>. For example, <code>(x \in 1..42) /\ (y' = x + 1)</code> - assuming x and y are declared variables.</p><ul><li>A constant expression is a (module-complete) expression that (after expanding all definitions) does not contain declared variables nor non-constant operators. The only non-constant operators that we've seen so far are <code>'</code> and <code>UNCHANGED</code>.<ul><li>The value of a constant expression depends only on the values of the declared constants it contains.</li></ul></li><li>A state expression is a (module-complete) expression that can contain anything a constant expression can contain as well as variables declared in a <code>VARIABLES</code> statement. For example, <code>x + y[foo]</code> is a state expression, if <code>foo</code> is a declared constant and <code>x</code> and <code>y</code> are declared variables.<ul><li>The value of a state expression depends on the values of declared constants and the values of declared variables. Let's ignore dependence on the values of declared constants.</li><li>Remember that a state assigns values to variables. Then, a state expression has a value on a state. For example, if state <code>s</code> assigns <code>v &lt;- Nat</code> and <code>w &lt;- -42</code>, then the state expression <code>v \union &#123;w&#125;</code> has the value <code>Nat \union &#123;-42&#125;</code>.</li><li>A constant expression is a state expression that has the same value on all states.</li></ul></li><li>An action expression can contain anything a state expression can as well as <code>'</code> and <code>UNCHANGED</code>.<ul><li>An action expression has a value on a step (pair of states). For example, if state <code>s</code> assigns <code>p &lt;- 42</code> and state <code>t</code> assigns <code>q &lt;- 24</code>, then the action expression <code>p - q'</code> has the value <code>42 - 24</code> on the step <code>s -&gt; t</code>.</li><li>A state expression is an action expression whose value on the step <code>s-&gt; t</code> depends only on the first state <code>s</code>.</li></ul></li></ul><h2 id="temporal-formulas">Temporal Formulas</h2><p>The content of this section is derived from <a href="https://lamport.azurewebsites.net/video/video8a-script.pdf">the video script</a> for "The TLA+ Video Course, Lecture 8, Part 1" by Leslie Lamport.</p><p>A temporal formula (TLA+ has only Boolean-valued temporal expressions – that is, temporal formulas) has a Boolean value on a behavior (A sequence of states is just what we've been calling a behavior) <code>s1 -&gt; s2 -&gt; s3 -&gt; ...</code>. We can write a specification as a temporal formula – a formula whose value is <code>TRUE</code> on the behaviors allowed by the spec.</p><p>In general, the specification with initial formula <code>Init</code>, next-state formula <code>Next</code>, declared variables <code>v1, ..., vn</code> is expressed by the temporal formula <code>Init /\ [][Next]_&lt;&lt;v1, ..., vn&gt;&gt;</code>.</p><ul><li>A state formula like <code>Init</code> is true on a behavior (<code>s1 -&gt; s2 -&gt; s3 -&gt; s4 -&gt; ...</code>) if and only if it's true on the first state (<code>s1</code>) of the behavior.</li><li>The temporal formula always <code>Next</code> (<code>[][Next]_&lt;&lt;v1, ..., vn&gt;&gt;</code>) is true on a behavior (<code>s1 -&gt; s2 -&gt; s3 -&gt; s4 -&gt; ...</code>) if and only if <code>Next</code> is true on every step of the behavior (<code>si -&gt; s(i+1)</code> for all <code>i</code>).</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tla">Spec ==<br>  /\ Init<br>  /\ [][Next]_&#123;&lt;&lt;priestStatus, ledgers, usedBallotIds, msgs&gt;&gt;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* SynodBasicProtocol.cfg<br>CONSTANT<br>PRIESTS = &#123;p1, p2, p3&#125;<br>DECREES = &#123;d1, d2, d3&#125;<br>\* Even a modest increase in the range of BALLOT_IDS,<br>\* from 0..2 to 0..10,<br>\* can significantly increase the number of possible distinct states.<br>BALLOT_IDS = &#123;0&#125;<br><br>SPECIFICATION<br>Spec<br><br>INVARIANT<br>TypeOK<br>Consistent<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlc SynodBasicProtocol.tla -config SynodBasicProtocol.cfg -deadlock<br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = 3.9E-14</span><br><span class="hljs-comment"># 1822 states generated, 565 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 12.</span><br><span class="hljs-comment"># The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 12 and the 95th percentile is 3).</span><br><span class="hljs-comment"># Finished in 02s at (2023-07-09 07:01:51)</span><br></code></pre></td></tr></table></figure><p>Let's now see what it means to apply the Always operator to a state formula.</p><ul><li>For the action <code>Next</code>, always <code>Next</code> is true on a behavior if and only if <code>Next</code> is true on every step of the behavior.</li><li>The state formula <code>TypeOK</code> is an action whose value on <code>si -&gt; s(i+1)</code> <strong>depends only on <code>si</code></strong> (a state formula is an action formula whose value on a step depends only on the first state of the step), so <code>[]TypeOK</code> is true on a behavior (<code>s1 -&gt; s2 -&gt; s3 -&gt; s4 -&gt; ...</code>) if and only if <code>TypeOK</code> is true on every <strong>state</strong> of the behavior (<code>si</code> for all <code>i</code>).</li><li>You can write <code>[]TypeOK</code>. You don't need the <code>[]_&lt;&lt;v1, ..., vn&gt;&gt;</code> for <code>[]StateFormula</code>.</li></ul><h2 id="stuttering-steps">Stuttering Steps</h2><p>The content of this section is derived from <a href="https://lamport.azurewebsites.net/video/video8b-script.pdf">the video script</a> for "The TLA+ Video Course, Lecture 8, Part 2" by Leslie Lamport.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tla+">--------------------------- MODULE SimpleProgram ---------------------------<br>\* SimpleProgram.tla<br>EXTENDS Integers<br>VARIABLES i, j<br><br>Init ==<br>  /\ i = 0<br>  /\ j = 0<br><br>IncrIJ ==<br>  \/ /\ i = 0<br>     /\ i&#x27; = 1<br>     /\ UNCHANGED &lt;&lt;j&gt;&gt;<br>  \/ /\ j = 0<br>     /\ j&#x27; = 1<br>     /\ UNCHANGED &lt;&lt;i&gt;&gt;<br><br>SimpleProgramSpec ==<br>  /\ Init<br>  /\ [][IncrIJ]_&lt;&lt;i, j&gt;&gt;<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs tla+">--------------------------- MODULE SimpleProgramImpl -----------------------<br>\* SimpleProgramImpl.tla<br>EXTENDS Integers<br>VARIABLES i, j, k<br><br>Init ==<br>  /\ i = 0<br>  /\ j = 0<br>  /\ k = 0<br><br>IncrIJ ==<br>  \/ /\ i = 0<br>     /\ i&#x27; = 1<br>     /\ UNCHANGED &lt;&lt;j, k&gt;&gt;<br>  \/ /\ j = 0<br>     /\ j&#x27; = 1<br>     /\ UNCHANGED &lt;&lt;i, k&gt;&gt;<br><br>IncrK ==<br>  /\ k = 0<br>  /\ k&#x27; = 1<br>  /\ UNCHANGED &lt;&lt;i, j&gt;&gt;<br><br>IncrIJK ==<br>  \/ IncrIJ<br>  \/ IncrK<br><br>SimpleProgramImplSpec ==<br>  /\ Init<br>  /\ [][IncrIJK]_&lt;&lt;i, j, k&gt;&gt;<br><br>SP == INSTANCE SimpleProgram<br>SimpleProgramSpec == SP!SimpleProgramSpec<br>\* https://lamport.azurewebsites.net/video/video8b-script.pdf<br>\* 1. Asserts that for every behavior:<br>\*    if it satisfies SimpleProgramImplSpec, then it satisfies SimpleProgramSpec.<br>\* 2. Every behavior satisfying SimpleProgramImplSpec satisfies SimpleProgramSpec.<br>\* 3. SimpleProgramImplSpec implements SimpleProgramSpec.<br>THEOREM SimpleProgramImplSpec =&gt; SimpleProgramSpec<br>============================================================================<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cfg">\* SimpleProgramImpl.cfg<br>SPECIFICATION<br>SimpleProgramImplSpec<br><br>PROPERTY<br>\* THEOREM SimpleProgramImplSpec =&gt; SimpleProgramSpec<br>\* Let TLC check this theorem by adding SimpleProgramSpec<br>\* as a property to check<br>\* in a model you constructed for module SimpleProgramImpl.<br>SimpleProgramSpec<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">tlc SimpleProgramImpl.tla -config SimpleProgramImpl.cfg -deadlock<br><span class="hljs-comment"># Model checking completed. No error has been found.</span><br><span class="hljs-comment">#   Estimates of the probability that TLC did not check all reachable states</span><br><span class="hljs-comment">#   because two distinct states had the same fingerprint:</span><br><span class="hljs-comment">#   calculated (optimistic):  val = 2.2E-18</span><br><span class="hljs-comment"># 13 states generated, 8 distinct states found, 0 states left on queue.</span><br><span class="hljs-comment"># The depth of the complete state graph search is 4.</span><br><span class="hljs-comment"># The average outdegree of the complete state graph is 1 (minimum is 0, the maximum 3 and the 95th percentile is 3).</span><br><span class="hljs-comment"># Finished in 01s at (2023-07-12 01:48:18)</span><br></code></pre></td></tr></table></figure><p>How can the theorem <code>SimpleProgramImplSpec =&gt; SimpleProgramSpec</code> make sense?</p><ul><li>The theorem <code>SimpleProgramImplSpec =&gt; SimpleProgramSpec</code> may not make sense because <code>SimpleProgramSpec</code> and <code>SimpleProgramImplSpec</code> refer to different state spaces constructed from different variables.<ul><li><code>SimpleProgramSpec</code> is an assertion about behaviors whose states assign a value to the two variable <code>i</code> and <code>j</code>.</li><li><code>SimpleProgramImplSpec</code> is an assertion about behaviors whose states assign values to the two variables <code>i</code>, <code>j</code> and <code>k</code>.</li></ul></li><li>Viewing states as implicitly containing infinitely many variables representing the entire universe is a key insight for understanding why theorems like <code>SimpleProgramImplSpec =&gt; SimpleProgramSpec</code> may hold. A formula denotes constraints on the values of variables in a state, but a state itself implicitly contains infinitely many variables that represent the entire universe. Two formulas may involve different variables yet still be assertions over this same implicit infinite state space.<ul><li>For instance, the formula <code>i = 0</code> constrains the value of <code>i</code> but says nothing about other variables like <code>k</code>, <code>Mozart</code>, or <code>numberOfCustomersInTimbuktuStarbucks</code> that <strong>also exist</strong> in the state.</li><li>Specifications are not programs; they're mathematical formulas. In math, when you write: <code>x + y = 7</code>, it doesn't mean that there's no variable <code>z</code> or <code>w</code>. The equations just say nothing about those other variables.</li></ul></li><li>It's useful to think about specifications as follows.<ul><li>A specification does not describe the correct behavior of a system.</li><li>Rather, it describes a universe in which the system <strong>and its environment</strong> are behaving correctly. The spec describes not only the system, but other parts of the universe that the system depends on.</li><li>The spec says nothing about irrelevant parts of the universe.</li></ul></li></ul><p>The theorem <code>SimpleProgramImplSpec =&gt; SimpleProgramSpec</code> makes sense because both formulas are assertions about the same kind of behavior. It asserts that every behavior satisfying <code>SimpleProgramImplSpec</code> satisfies <code>SimpleProgramSpec</code>. But how can it be true?</p><ul><li><code>SimpleProgramImplSpec</code> allows <code>IncrK</code> steps, which leave <code>i</code> and <code>j</code> unchanged. All <code>SimpleProgramSpec</code> steps change <code>i</code> or <code>j</code>. How can a behavior satisfying <code>SimpleProgramImplSpec</code> also satisfy <code>SimpleProgramSpec</code> if it has a <code>IncrK</code> step? How can the theorem be true?</li><li>It's the "magic" of <code>[]_&lt;&lt;i, j&gt;&gt;</code>. <code>[IncrIJ]_&lt;&lt;i, j&gt;&gt;</code> is true on a behavior iff <code>IncrIJ \/ UNCHANGED &lt;&lt;i, j&gt;&gt;</code> is true on every step of the behavior, which is the same as the assertion that every step satisfies <code>IncrIJ</code> or leaves <code>i</code> and <code>j</code> unchanged. If steps leaving <code>i</code> and <code>j</code> unchanged were not allowed by <code>SimpleProgramSpec</code>, then the theorem <code>SimpleProgramImplSpec =&gt; SimpleProgramSpec</code> would not be true.</li><li>Similarly, for the two-phase commit spec <code>TPSpec == TPInit /\ [][TPNext]_&lt;&lt;rmState, tmState, tmPrepared, msgs&gt;&gt;</code>, this always formula is true on a behavior if and only if every step of the behavior satisfies the next-state formula <code>TPNext</code> or else leaves <strong>all</strong> the specification variables unchanged.</li></ul><p>However, we cannot remove the stuttering steps allowed by <code>[]_&lt;&lt;i, j&gt;&gt;</code> in TLA+, because if we write <code>SimpleProgramSpec == Init /\ [][Next]_&lt;&lt;&gt;&gt;</code>, then this will allow stuttering steps, as explained by Stephan Merz in <a href="https://groups.google.com/g/tlaplus/c/Pg5Yx3k_VaE">Google Groups: About stuttering steps, deadlock and Implementation</a>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tla">  [Next]_&lt;&lt;&gt;&gt;<br>= Next \/ UNCHANGED &lt;&lt;&gt;&gt; \* By definition of [Next]_vars.<br>= Next \/ (&lt;&lt;&gt;&gt;&#x27; = &lt;&lt;&gt;&gt;) \* By definition of UNCHANGED.<br>= Next \/ (&lt;&lt;&gt;&gt; = &lt;&lt;&gt;&gt;)  \* Since &lt;&lt;&gt;&gt; is a constant expression.<br>= Next \/ TRUE<br></code></pre></td></tr></table></figure><p>Now, <code>TRUE</code> allows for any step, including stuttering transitions: there is <strong>no way</strong> you can write a TLA+ specification that <strong>disallows</strong> stuttering steps.</p><p>If we write <code>SimpleProgramSpec == Init /\ [][Next]_&lt;&lt;i&gt;&gt;</code>, then this will also allow stuttering steps:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tla">  [Next]_&lt;&lt;i&gt;&gt;<br>= Next \/ UNCHANGED &lt;&lt;i&gt;&gt;  \* By definition of [Next]_vars.<br>= Next \/ (&lt;&lt;i&gt;&gt;&#x27; = &lt;&lt;i&gt;&gt;) \* By definition of UNCHANGED.<br>= Next \/ (&lt;&lt;i&#x27;&gt;&gt; = &lt;&lt;i&gt;&gt;) \* Since &lt;&lt;&gt;&gt; is a constant expression.<br>= Next \/ (i&#x27; = i)<br></code></pre></td></tr></table></figure><p>Now, <code>i' = i</code> allows for any step that keep <code>i</code> unchanged, including stuttering transitions.</p><p>Steps that leave all the spec's variables unchanged are called stuttering steps. Every TLA+ spec allows them.</p><ul><li>If they didn't, TPSpec would allow the value of <code>numberOfCustomersInTimbuktuStarbucks</code> to change only when the protocol took a step. And that would be really weird.</li><li>If they didn't, the two-phase commit spec would allow the value of every variable in the universe to change only when the two-phase commit protocol took a step. And that would be really weird.</li><li>But the most important reason to allow stuttering steps is embodied in this theorem: <code>SimpleProgramImplSpec =&gt; SimpleProgramSpec</code>. Implementation becomes simple logical implication.<ul><li>Mathematical simplicity is not an end in itself.</li><li>It's a sign that we're doing things right.</li></ul></li></ul><p>We represent a terminating execution by a behavior ending in an infinite sequence of stuttering steps. This is natural, because a behavior represents a history of the universe, and the universe keeps going even if the system we're specifying terminates. It is important to note that termination and deadlock are distinct concepts, as Leslie Lamport explained in <a href="https://groups.google.com/g/tlaplus/c/EfE9YrfqmBU">Google Groups: Question about some concepts</a>: "Deadlock means reaching a state in which the only steps (state changes) allowed by the spec are stuttering steps (ones that change no declared variables of the spec)." Thus, a specification can reach a deadlock state even if stuttering steps are permitted.</p><h2 id="weak-fairness-strong-fairness">Weak Fairness &amp; Strong Fairness</h2><p>At this moment, I am finding it challenging to grasp the concepts of weak fairness and strong fairness, particularly as they relate to the formalization of fairness using the Linear Temporal Logic (LTL) operators <code>[]&lt;&gt;p</code> and <code>&lt;&gt;[]p</code>. These concepts require a deep understanding of LTL, which I am currently in the process of acquiring. Therefore, I have decided to temporarily skip this part of my studies. Once I have a more solid foundation in LTL, I will return to explore these topics in greater depth.</p><h2 id="reference">Reference</h2><ul><li><a href="https://lamport.azurewebsites.net/video/videos.html">The TLA+ Video Course</a></li><li><a href="https://medium.com/software-safety/introduction-to-tla-model-checking-in-the-command-line-c6871700a6a2">Medium: Introduction to TLA+ Model Checking in the Command Line</a></li><li><a href="https://www.learntla.com/index.html">Learn TLA+</a></li><li><a href="https://lamport.azurewebsites.net/pubs/auxiliary.pdf">Auxiliary Variables in TLA+</a></li><li><a href="https://emptysqua.re/blog/interactive-tla-plus/#is-the-spec-behaving-as-intended">A. Jesse Jiryu Davis: Current and Future Tools for Interactive TLA+</a></li><li><a href="https://www.tautvidas.com/blog/2019/01/debugging-tla-specifications-with-state-dumps/">Tautvidas Sipavičius: Debugging TLA+ specifications with state dumps</a></li><li><a href="https://github.com/tlaplus/tlaplus/issues/404">tlaplus/tlaplus Issues: Specifying symmetry set in cfg file manually</a></li><li><a href="https://tla.msr-inria.inria.fr/tlatoolbox/doc/model/model-values.html">The Microsoft Research-Inria Joint Center: Model Values and Symmetry</a></li><li><a href="https://www.researchgate.net/publication/304894406_The_Investigation_of_TLC_Model_Checker_Properties">ResearchGate: The Investigation of TLC Model Checker Properties</a></li><li><a href="https://groups.google.com/g/tlaplus/c/Pg5Yx3k_VaE">Google Groups: About stuttering steps, deadlock and Implementation</a></li><li><a href="https://groups.google.com/g/tlaplus/c/WhgEGDTziBM">Google Groups: About stuttering steps and deadlock in TLC</a></li><li><a href="https://groups.google.com/g/tlaplus/c/EfE9YrfqmBU">Google Groups: Question about some concepts</a></li><li><a href="https://www.hillelwayne.com/post/fairness/">HILLEL WAYNE: WEAK AND STRONG FAIRNESS</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>TLA+</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</title>
    <link href="/2023/03/06/computer-science/serializability/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/"/>
    <url>/2023/03/06/computer-science/serializability/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/</url>
    
    <content type="html"><![CDATA[<h2 id="proposed-specifications-for-existing-isolation-levels">Proposed Specifications for Existing Isolation Levels</h2><h3 id="system-model-and-terminology">System Model and Terminology</h3><h4 id="database-model">Database Model</h4><ul><li>When a transaction writes an object <span class="math inline">\(x\)</span>, it creates a new version of <span class="math inline">\(x\)</span>. A transaction <span class="math inline">\(T_i\)</span> can modify an object multiple times; its first update of object <span class="math inline">\(x\)</span> is denoted by <span class="math inline">\(x_{i.1}\)</span> , the second by <span class="math inline">\(x_{i.2}\)</span>, and so on. Version <span class="math inline">\(x_i\)</span> denotes the final modification of <span class="math inline">\(x\)</span> performed by <span class="math inline">\(T_i\)</span> before it commits or aborts. That is, <span class="math inline">\(x_i \equiv x_{i.n} \, \textrm{where} \, n = \max \{j \mid x_{i.j} \, \textrm{exists} \}\)</span>.</li><li>There are three kinds of objects versions:<ul><li>During initialization, a transaction <span class="math inline">\(T_i\)</span> creates all objects that will ever exist in the database; at this point, each object <span class="math inline">\(x\)</span> has an initial version, <span class="math inline">\(x_{init}\)</span>, called the unborn version.</li><li>When an application transaction inserts an object <span class="math inline">\(x\)</span>, we model it as the creation of a visible version for <span class="math inline">\(x\)</span>.</li><li>When a transaction <span class="math inline">\(T_i\)</span> deletes an object <span class="math inline">\(x\)</span>, we model it as the creation of a special dead version, <span class="math inline">\(x_{dead}\)</span>.</li><li>Create, update, and delete operations can be modeled as update operations with the above conventions.</li></ul></li><li>All objects in the database have a unique identity that is not based on field values.<ul><li>Suppose transaction <span class="math inline">\(T_i\)</span> deletes <span class="math inline">\(x\)</span> and a later transaction <span class="math inline">\(T_j\)</span> checks if this tuple exists and inserts a new tuple. Transaction <span class="math inline">\(T_j\)</span>'s insert operation overwrites the unborn version of an object <span class="math inline">\(y\)</span> that has not been used before and creates a visible version of <span class="math inline">\(y\)</span>.</li><li>If two transactions try to insert a tuple with the same field values, the system selects two distinct objects for insertion. The decision whether both tuples can be inserted is left to the application and the database system, i.e., our model does not require that the database contains unique tuples.</li></ul></li></ul><h4 id="transaction-histories">Transaction Histories</h4><p>A history <span class="math inline">\(H\)</span> cover a set of transactions consists of two parts:</p><ul><li>a partial order of events <span class="math inline">\(E\)</span> that reflects the operations (e.g., read, write, abort, commit) of those transactions,<ul><li>The notion <span class="math inline">\(w_i(x_{i.m}, v)\)</span> denotes transaction <span class="math inline">\(T_i\)</span> performs a write operation on object <span class="math inline">\(x\)</span> as its <span class="math inline">\(m^{th}\)</span> modification (within the transaction <span class="math inline">\(T_i\)</span>) with value <span class="math inline">\(v\)</span>.</li><li>The notion <span class="math inline">\(r_j(x_{i.m}, v)\)</span> denotes transaction <span class="math inline">\(T_j\)</span> performs a read operation on a version of object <span class="math inline">\(x\)</span> that was written by transaction <span class="math inline">\(T_i\)</span> at its <span class="math inline">\(m^{th}\)</span> modification with value <span class="math inline">\(v\)</span> (<span class="math inline">\(T_i\)</span> could be the same as <span class="math inline">\(T_j\)</span>).</li><li>The partial order of events E in a history obeys the following constraints:<ul><li>It preserves the order of all events within a transaction including the commit and abort events.</li><li>If an event <span class="math inline">\(r_j(x_{i.m})\)</span> exists in E, it should be preceded by <span class="math inline">\(w_i(x_{i.m})\)</span> in <span class="math inline">\(E\)</span>, i.e., a transaction <span class="math inline">\(T_j\)</span> cannot read version <span class="math inline">\(x_i\)</span> of object <span class="math inline">\(x\)</span> before it has been produced by <span class="math inline">\(T_i\)</span>.</li><li>If an event <span class="math inline">\(w_i(x_{i.m})\)</span> is followed by <span class="math inline">\(r_i(x_j)\)</span> without an intervening event <span class="math inline">\(w_i(x_{i.n})\)</span> in <span class="math inline">\(E\)</span>, <span class="math inline">\(x_j\)</span> must be <span class="math inline">\(x{i.m}\)</span>. This condition ensures that if a transaction modifies object <span class="math inline">\(x\)</span> and later reads <span class="math inline">\(x\)</span>, it will observe its last update to <span class="math inline">\(x\)</span>.</li></ul></li><li>We would add extra conditions as they are needed at each isolation level.</li></ul></li><li>and a version order, <span class="math inline">\(\ll\)</span>, that is a total order on committed object versions.<ul><li>There is no constraint on versions due to uncommitted or aborted transactions.</li><li>The version order of committed object versions obeys the following constraints:<ul><li>The version order of each object <span class="math inline">\(x\)</span> contains exactly one initial version, <span class="math inline">\(x_{init}\)</span>, and at most one dead version, <span class="math inline">\(x_{dead}\)</span>.</li><li><span class="math inline">\(x_{init}\)</span> is <span class="math inline">\(x\)</span>'s first version in its version order and <span class="math inline">\(x_{dead}\)</span> is its last version (if it exists); all visible versions are placed between <span class="math inline">\(x_{init}\)</span> and <span class="math inline">\(x_{dead}\)</span>.</li><li>If <span class="math inline">\(r_j(x_i)\)</span> occurs in a history, then <span class="math inline">\(x_i\)</span> is a visible version. This condition ensures that transactions can only read visible versions.</li></ul></li></ul></li></ul><p>The version order in a history <span class="math inline">\(H\)</span> can be different from the order of write or commit events in <span class="math inline">\(H\)</span>.</p><ul><li>e.g., <span class="math inline">\(H_{write-order}: w_1(x_1) w_2(x_2) c_1 c_2 \quad [x_2 \ll x_1]\)</span>.<ul><li>The database system chooses the version order <span class="math inline">\(x_2 \ll x_1\)</span> even though <span class="math inline">\(T_1\)</span> writes <span class="math inline">\(x_1\)</span> before <span class="math inline">\(T_2\)</span> writes <span class="math inline">\(x_2\)</span>.</li><li>The fact that <span class="math inline">\(T_1\)</span> commits before <span class="math inline">\(T_2\)</span> does not determine the version order either.</li></ul></li><li>This flexibility is needed to allow certain optimistic and multi-version implementations.</li></ul><h4 id="predicates">Predicates</h4><h5 id="version-set">Version Set</h5><p>When a transaction executes a read or write based on a predicate <span class="math inline">\(P\)</span>, the system selects a version for <strong>each</strong> object in <span class="math inline">\(P\)</span>’s relations (where a relation corresponds to a MySQL table). The set of selected versions is called the Version set of this predicate-based operation and is denoted by <span class="math inline">\(\operatorname{Vset}(P)\)</span>.</p><p>Versions of objects in <span class="math inline">\(P\)</span>'s relations are selected before determining whether they match <span class="math inline">\(P\)</span> or not. Therefore, <span class="math inline">\(\operatorname{Vset}(P)\)</span> includes versions of all objects in <span class="math inline">\(P\)</span>'s relations, regardless of whether they are matched by <span class="math inline">\(P\)</span> or not. <span class="math inline">\(\operatorname{Vset}(P)\)</span> will be very large since it includes unborn and possibly dead versions of some objects.</p><h5 id="predicate-based-reads">Predicate-based Reads</h5><p>We denote a predicate-based read as <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>.</p><p>After the predicate-base read, <span class="math inline">\(T_i\)</span> can execute operations on the matched objects, e.g., it could read <span class="math inline">\(x_1\)</span>'s value. These reads will show up as <strong>separate</strong> events in the history. If <span class="math inline">\(T_i\)</span> does not read <span class="math inline">\(x_1\)</span>, we do not add a read event to the history. Thus, the history only shows reads of versions that were actually observed by transaction <span class="math inline">\(T_i\)</span>.</p><h5 id="predicate-based-modifications">Predicate-based Modifications</h5><p>We denote a medicate-based modification as <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>.</p><p>Note that a predicate-based modification can also be modeled as a predicate-based read followed by a set of writes on the matched objects:</p><ul><li>e.g., <span class="math inline">\(r_i(P:\operatorname{Vset}(P)) w_i(x_i)\)</span>. The paper "Generalized Isolation Level Definitions" employs this approach to define isolation levels.</li><li>Under the same constraints on histories, this technique provides weaker guarantees (than the approach given above) to predicate-based modifications at lower isolation levels.</li><li>However, it is possible to introduce additional constraints on histories to provide same guarantees.</li></ul><h4 id="conflicts-and-serialization-graphs">Conflicts and Serialization Graphs</h4><p>We define three kinds of direct conflicts that capture conflicts of two different <strong>committed</strong> transactions on the same object or intersecting predicates:</p><ul><li>Directly Read-Depends, <span class="math inline">\(T_i \stackrel{wr}{\longrightarrow} T_j\)</span>.<ul><li>Directly item-read-depends: We say that <span class="math inline">\(T_j\)</span> directly item-read-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs some object version <span class="math inline">\(x_i\)</span> and <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(x_i\)</span>.</li><li>Directly predicate-read-depends: Transaction <span class="math inline">\(T_j\)</span> directly predicate-read-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_j\)</span> performs an operation <span class="math inline">\(r_j(P:\operatorname{Vset}(P))\)</span> and <span class="math inline">\(x_i \in \operatorname{Vset}(P)\)</span>.<ul><li>Transaction <span class="math inline">\(T_j\)</span> directly predicate-read-depends on the initialization transaction <span class="math inline">\(T_{init}\)</span> since <span class="math inline">\(T_j\)</span> observes the unborn versions of objects that have yet not been inserted in <span class="math inline">\(P\)</span>'s relations.</li><li>If <span class="math inline">\(T_j\)</span> observes a dead version of some object, it directly read-depends on the transaction that deleted that object.</li></ul></li></ul></li><li>Directly Anti-Depends, <span class="math inline">\(T_i \stackrel{rw}{\longrightarrow} T_j\)</span>.<ul><li>Directly item-anti-depends: We say that <span class="math inline">\(T_j\)</span> directly item-anti-depends on transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> reads some object version <span class="math inline">\(x_k\)</span> and <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x\)</span>'s <strong>next</strong> version (after <span class="math inline">\(x_k\)</span>) in the <strong>version order</strong>.</li><li>Directly predicate-anti-depends: We say that <span class="math inline">\(T_j\)</span> directly predicate-anti-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>. That is, if <span class="math inline">\(T_j\)</span> installs a <strong>later (but not necessarily the next)</strong> version of some object that <strong>changes the matches</strong> of a predicate-based read performed by <span class="math inline">\(T_i\)</span>.<ul><li>Overwriting a predicate-based operation: We say that a transaction <span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> (or <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>) based on predicate <span class="math inline">\(P\)</span> if <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x_j\)</span> such that <span class="math inline">\(x_k \ll x_j\)</span>, <span class="math inline">\(x_k \in \operatorname{Vset}(P)\)</span> and <span class="math inline">\(x_k\)</span> matches <span class="math inline">\(P\)</span> whereas <span class="math inline">\(x_j\)</span> does not match <span class="math inline">\(P\)</span> or vice-versa. That is, <span class="math inline">\(T_j\)</span> makes a modification that changes the set of objects matched by <span class="math inline">\(T_i\)</span>'s predicate-based operation.</li></ul></li></ul></li><li>Directly Write-Depends, <span class="math inline">\(T_i \stackrel{ww}{\longrightarrow} T_j\)</span>.<ul><li>Directly item-write-depends: We say that <span class="math inline">\(T_j\)</span> directly item-write-depends on transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs a version <span class="math inline">\(x_i\)</span> and <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x\)</span>'s <strong>next</strong> version (after <span class="math inline">\(x_i\)</span>) in the version order.</li><li>Directly predicate-write-depends: We say that <span class="math inline">\(T_j\)</span> directly predicate-write-depends on <span class="math inline">\(T_i\)</span> if either<ol type="1"><li><span class="math inline">\(T_j\)</span> executes an operation <span class="math inline">\(w_j(Q:\operatorname{Vset}(Q))\)</span> and <span class="math inline">\(x_i \in \operatorname{Vset}(Q)\)</span>. In other words, the system selects a version <span class="math inline">\(x_i\)</span> in <span class="math inline">\(T_j\)</span>'s predicate-based write.</li><li><span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>. This means that <span class="math inline">\(T_j\)</span> installs a later version of an object that changes the matches of a predicate-based write performed by <span class="math inline">\(T_i\)</span>.</li></ol></li></ul></li></ul><p>The definition of predicate-write-dependencies is similar to the definitions of predicate-read-dependencies (the first part) and predicate-anti-dependencies (the second part).</p><p>We can define the direct serialization graph (DSG) of a given history <span class="math inline">\(H\)</span> as follows:</p><ul><li>Each node in <span class="math inline">\(\operatorname{DSG}(H)\)</span> corresponds to a committed transaction in <span class="math inline">\(H\)</span>.</li><li>Directed edges correspond to different types of direct conflicts.</li></ul><h5 id="refine-direct-predicate-anti-dependency">Refine: Direct Predicate-Anti-Dependency</h5><p>If <span class="math inline">\(T_j\)</span> installs a <strong>later</strong> version of an object that changes the matches of a predicate-based read performed by <span class="math inline">\(T_i\)</span>, but it is not the <strong>next</strong> version of that object in the version order, this still results in direct predicate-anti-dependency between <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>. Here's an example from the thesis.</p><p>When <span class="math inline">\(T_1\)</span> performs its query there are exactly two employees, <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, both in Sales. <span class="math inline">\(T_1\)</span> sums up the salaries of these employees and compares it with the sum-of-salaries maintained for this department. However, before it performs the final check, <span class="math inline">\(T_2\)</span> inserts a new employee in the Sales department, updates the sum-of-salaries, and commits. Thus, when <span class="math inline">\(T_1\)</span> reads the new sum-of-salaries value, it finds an inconsistency.</p><p><span class="math inline">\(H_{phantom}\)</span> is ruled out by PL-3 because the direct serialization graph contains a cycle with a predicate-anti-dependency edge.</p><p><span class="math display">\[\begin{align*}H_{phantom}: r_1(Dept=Sales:x_0,10;y0,10) &amp;\\             r_2(Sum_0,20)                &amp;\\             w_2(z_2=10)                  &amp;\\             w_2(Sum_2,30)                &amp;\\             c_2                          &amp;\\             r_1(Sum_2,30)                &amp;\\             c_1                          &amp;\\[Sum_0 \ll Sum_2, z_{init} \ll z_2]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T0 --&gt;|wr| T1;  T0 --&gt;|wr| T2;  T1 -.-&gt;|predicate-rw| T2;  T2 --&gt;|wr| T1;</code></pre><p>Let's consider a modification to <span class="math inline">\(H_{phantom}\)</span>:</p><ul><li>Change <span class="math inline">\(Sum\)</span> to <span class="math inline">\(SumMoreThan15\)</span>.</li><li>Add transaction <span class="math inline">\(T_3\)</span>, which increases employee <span class="math inline">\(z\)</span>'s salary from 10 to 20 and updates the sum-of-salaries after <span class="math inline">\(T_2\)</span> is committed.</li></ul><p><span class="math display">\[\begin{align*}H_{phantom}: r_1(Dept=Sales:x_0,10;y0,10;z_{init}) &amp;\\             r_2(SumMoreThan15_0,0)                &amp;\\             w_2(z_2=10)                           &amp;\\             w_2(SumMoreThan15_2,0)                &amp;\\             c_2                                   &amp;\\             r_3(SumMoreThan15_2,0)                &amp;\\             r_3(z_2=10)                           &amp;\\             w_3(z_3=20)                           &amp;\\             w_3(SumMoreThan15_3,20)               &amp;\\             c_3                                   &amp;\\             r_1(SumMoreThan15_3,20)               &amp;\\             c_1                                   &amp;\\[SumMoreThan15_0 \ll SumMoreThan15_2 \ll SumMoreThan15_3, z_{init} \ll z_2 \ll z_3]\end{align*}\]</span></p><p>If the answer is no, since <span class="math inline">\(z_3\)</span> is not the next version of <span class="math inline">\(z_{init}\)</span>, there is no predicate-anti-dependency relationship between <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_3\)</span>, and there is no cycle in the direct serialization graph. However, this scenario is nonsensical because <span class="math inline">\(T_1\)</span> would get an inconsistent result.</p><pre><code class=" mermaid">graph LR;  T0 --&gt;|wr| T1;  T0 --&gt;|wr| T2;  T2 --&gt;|wr| T3;  T3 --&gt;|wr| T1;</code></pre><p>To ensure the correctness of the theory, a predicate-anti-dependency between <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_3\)</span> should exist, even if <span class="math inline">\(z_3\)</span> is not considered the next version of <span class="math inline">\(z_{init}\)</span>.</p><pre><code class=" mermaid">graph LR;  T0 --&gt;|wr| T1;  T0 --&gt;|wr| T2;  T1 -.-&gt;|predicate-rw| T3;  T2 --&gt;|wr| T3;  T3 --&gt;|wr| T1;</code></pre><h3 id="isolation-levels-for-committed-transactions">Isolation Levels for Committed Transactions</h3><table><thead><tr class="header"><th>Phenomena</th><th>Histories Described in tr-95-51</th><th>Histories Described in adya-phd</th><th>Isolation Levels in tr-95-51</th></tr></thead><tbody><tr class="odd"><td>Dirty Write</td><td>P0: <code>w1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td><td></td><td></td></tr><tr class="even"><td></td><td></td><td>G0</td><td>PL-1</td></tr><tr class="odd"><td>Dirty Read</td><td>P1: <code>w1[x]...r2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td><td></td><td></td></tr><tr class="even"><td></td><td>A1: <code>w1[x]...r2[x]...(a1 and c2 in any order)</code></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td>G1a + G1b + G1c</td><td>PL-2</td></tr><tr class="even"><td></td><td></td><td>G1a + G1b + G1c + G1-predA</td><td>PL-2'</td></tr><tr class="odd"><td></td><td></td><td>G1a + G1b + G1c + G1-predB</td><td>PL-2''</td></tr><tr class="even"><td>Non-repeatable or Fuzzy Read</td><td>P2: <code>r1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td><td></td><td></td></tr><tr class="odd"><td></td><td>A2: <code>r1[x]...w2[x]...c2...r1[x]...c1</code></td><td></td><td></td></tr><tr class="even"><td>Phantom</td><td>P3: <code>r1[P]...w2[y in P]...((c1 or a1) and (c2 or a2) any order)</code></td><td></td><td></td></tr><tr class="odd"><td></td><td>A3: <code>r1[P]...w2[y in P]...c2...r1[P]...c1</code></td><td></td><td></td></tr><tr class="even"><td>Lost Update</td><td>P4: <code>r1[x]...w2[x]...w1[x]...c1</code></td><td></td><td></td></tr><tr class="odd"><td></td><td></td><td>G2</td><td>PL-3</td></tr></tbody></table><h4 id="isolation-level-pl-1">Isolation Level PL-1</h4><p><strong>G0: Write Cycles.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G0 if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle consisting entirely of write-dependency edges.</p><p>PL-1, which disallows G0, is considered to be more permissive than Read Uncommitted, which disallows P0, since G0 allows concurrent transactions to modify the same object while P0 does not. Thus, non-serializable interleaving of write operations is possible among uncommitted transactions as long as such interleavings are disallowed among committed transactions (e.g., by aborting some transactions).</p><p>According to tr-95-51, Dirty Writes (P0) are considered problematic for two main reasons:</p><ul><li>They can violate database consistency. Assume there is a constraint between <code>x</code> and <code>y</code> (e.g., <code>x</code> = <code>y</code>), and <code>T1</code> and <code>T2</code> each maintain the consistency of the constraint if run alone. However, the constraint can easily be violated if the two transactions write <code>x</code> and <code>y</code> in <strong>different orders</strong>, which can only happen if there are Dirty writes.</li><li>Without protection from P0, the system can't undo updates by restoring before images. Consider the history: <code>w1[x] w2[x] a1</code>. You don’t want to undo <code>w1[x]</code> by restoring its before-image of <code>x</code>, because that would wipe out <code>w2</code>'s update. But if you don't restore its before-image, and transaction <code>T2</code> later aborts, you can't undo <code>w2[x]</code> by restoring its before-image either!</li></ul><p>However, these two reasons have been criticized in adya-phd:</p><ul><li>... as such interleavings are disallowed among committed transactions (e.g., by aborting some transactions).</li><li>We believe that <span class="math inline">\(H_{recovery}\)</span> is a valid history and our consistency condition for no-dirty-writes (G0) allows it. Implementations can handle the aborts of <code>T1</code> and <code>T2</code> in a variety of ways. For example, when <code>T1</code> aborts, the system can let <code>x2</code> be the version that is stored in the database. If <code>T2</code> also aborts, the system reverts the value of <code>x</code> to <code>x0</code>. Furthermore, some client-server systems such as Thor do not install modifications into the committed state until the commit point of transactions. In such systems, we do not even have to revert the value of <code>x</code> when either transaction aborts.</li></ul><h4 id="isolation-level-pl-2">Isolation Level PL-2</h4><ul><li>PL-2: Disallow G1a, G1b and G1c.</li><li>PL-2': Disallow G1a, G1b, G1c and G1-predA.</li><li>PL-2'': Disallow G1a, G1b, G1c and G1-predB.</li></ul><h5 id="g1a-aborted-reads">G1a: Aborted Reads</h5><p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1a if it contains an aborted transaction <span class="math inline">\(T_i\)</span> and a committed transaction <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_j\)</span> has read some object (maybe via a predicate) modified by <span class="math inline">\(T_i\)</span>. Phenomenon G1a can be represented using the following history fragments:</p><ul><li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(x_{i.m}) \ldots (a_i \text{ and } c_j \text{ in any order })\)</span></li><li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(P:x_{i.m}, \dots) \ldots (a_i \text{ and } c_j \text{ in any order })\)</span></li></ul><p>Proscribing G1a ensures that if <span class="math inline">\(T_j\)</span> reads from <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_i\)</span> aborts, <span class="math inline">\(T_j\)</span> must also abort; these aborts are also called cascaded aborts. In a real implementation, the condition also implies that if <span class="math inline">\(T_j\)</span> reads from an uncommitted transaction <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_j\)</span>'s commit must be delayed until <span class="math inline">\(T_i\)</span>'s commit has succeeded.</p><h5 id="g1b-intermediate-reads">G1b: Intermediate Reads</h5><p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1b if it contains a committed transaction <span class="math inline">\(T_j\)</span> that has read a version of object <span class="math inline">\(x\)</span> (maybe via a predicate) written by transaction <span class="math inline">\(T_i\)</span> that was not <span class="math inline">\(T_i\)</span>'s final modification of <span class="math inline">\(x\)</span>. The following history fragments represent this phenomenon:</p><ul><li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(x_{i.m}) \ldots w_i(x_{i.n}) c_j\)</span></li><li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(P:x_{i.m}, \ldots) \ldots w_i(x_{i.n}) c_j\)</span></li></ul><p>Like our other conditions, G1b does not constrain the behavior of uncommitted transactions.</p><h5 id="g1c-circular-information-flow">G1c: Circular Information Flow</h5><p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1c if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle consisting entirely of dependency edges, where a dependency edge is defined as either a read-dependency edge or a write-dependency edge.</p><h5 id="g1">G1</h5><p>Our condition that captures the essence of no-dirty-reads is G1, which is comprised of G1a, G1b, and G1c. We define isolation level PL-2 as one in which phenomenon G1 is disallowed. (Note that G1c includes G0. We could have defined a weaker version of G1c that only concerned cycles having at least one read-dependency edge, but it seems simpler not to do this.)</p><p>Proscribing G1 is clearly weaker than proscribing P1 since G1 allows transactions to read from uncommitted transactions.</p><h5 id="g1-preda-non-atomic-predicate-based-reads">G1-predA: Non-atomic Predicate-based Reads</h5><p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1-predA if <span class="math inline">\(H\)</span> contains distinct committed transactions <span class="math inline">\(T_j\)</span> and <span class="math inline">\(T_i\)</span>, and operations <span class="math inline">\(w_j(Q:\operatorname{Vset}(Q)), w_j(x_j) \ldots w_j(y_j)\)</span> and <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> such that <span class="math inline">\(w_j(x_j)\)</span> and <span class="math inline">\(w_j(y_j)\)</span> are events generated due to <span class="math inline">\(w_j(Q:\operatorname{Vset}(Q))\)</span>, <span class="math inline">\(x_j \in \operatorname{Vset}(P)\)</span>, and <span class="math inline">\(w_j(y_j)\)</span> <strong>overwrites</strong> (refer to the following explanation for more details) <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>.</p><p>PL-2' can be defined as a level that disallows G1a, G1b, G1c, and G1-predA.</p><ul><li><p>In the context of overwriting a predicate-based operation:</p><blockquote><p>We say that a transaction <span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> (or <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>) based on predicate <span class="math inline">\(P\)</span> if <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x_j\)</span> such that <span class="math inline">\(x_k \ll x_j\)</span>, <span class="math inline">\(x_k \in \operatorname{Vset}(P)\)</span> and <span class="math inline">\(x_k\)</span> matches <span class="math inline">\(P\)</span> whereas <span class="math inline">\(x_j\)</span> does not match <span class="math inline">\(P\)</span> or vice-versa. That is, <span class="math inline">\(T_j\)</span> makes a modification that changes the set of objects matched by <span class="math inline">\(T_i\)</span>'s predicate-based operation.</p></blockquote></li><li><p>Based on my understanding, in the context of G1-predA, it is possible that <span class="math inline">\(w_j(x_j)\)</span> overwrites <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> if <span class="math inline">\(x_k \ll x_j\)</span>, <span class="math inline">\(x_k \in \operatorname{Vset}(P)\)</span>, regardless of whether <span class="math inline">\(x_j\)</span> is a modification that changes the set of objects matched by <span class="math inline">\(P\)</span>. However, it is important to note that this is only my interpretation and I am not entirely certain if it aligns with the author's intention. If my understanding is indeed correct, the author's assertion makes sense:</p><blockquote><p>Disallowing G1-predA guarantees that if <span class="math inline">\(T_i\)</span>'s predicate-based read observes an update by <span class="math inline">\(T_j\)</span>'s predicate-based write, it does not see any version older than the ones installed by <span class="math inline">\(T_j\)</span>'s write. Thus, disallowing G1-predA ensures that all read/write operations are indivisible with respect to each other.</p></blockquote></li><li><p>When the meaning of "overwrite" varies, it becomes difficult to definitively determine the relationship between PL-2' and PL-3. Is PL-3 remains more restrictive than PL-2' under these conditions?</p></li></ul><h5 id="g1-predb-non-atomic-predicate-based-reads-with-respect-to-transactions">G1-predB: Non-atomic Predicate-based Reads with respect to Transactions</h5><p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1-predB if <span class="math inline">\(H\)</span> contains distinct committed transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_i\)</span> <strong>overwrites</strong> (refer to the following explanation for more details) an operation <span class="math inline">\(r_j(P:\operatorname{Vset}(P))\)</span> and there exists a version <span class="math inline">\(x_i\)</span> in <span class="math inline">\(\operatorname{Vset}(P)\)</span>.</p><p><span class="math display">\[\begin{align*}H_{atomic-read}: w_1(\text{Dept=Sales}:x_0;y_0;z_0)               &amp;\\                 w_1(x_1)                                         &amp;\\                 w_1(y_1)                                         &amp;\\                 w_1(z_1)                                         &amp;\\                 r_2(\text{Dept=Sales or Dept=Legal}:x_1;y_1;z_0) &amp;\\                 r_2(x_1)                                         &amp;\\                 r_2(y_1)                                         &amp;\\                 c1                                               &amp;\\                 c2                                               &amp;\\[x_0 \ll x_1, y_0 \ll y_1, z_0 \ll z_1]\end{align*}\]</span></p><p>In this case, <span class="math inline">\(z_0\)</span> represents an employee record in the legal department, and <span class="math inline">\(w_1(z_1)\)</span> is a regular write, not one generated by <span class="math inline">\(w_1(\text{Dept=Sales}:x_0;y_0;z_0)\)</span>. Disallowing G1-predB will prohibit <span class="math inline">\(H_{atomic-read}\)</span>, but it would be allowed if only G1-predA is disallowed. This is because G1-predA requires <span class="math inline">\(w_1(z_1)\)</span> to be generated by <span class="math inline">\(w_1(\text{Dept=Sales}:x_0;y_0;z_0)\)</span>, while G1-predB has no such requirement.</p><p>In my opinion, the overwriting concept in G1-predB appears similar to that in G1-predA. This is reflected in the fact that:</p><ul><li>Disallowing G1-predB will prohibit <span class="math inline">\(H_{atomic-read}\)</span>, implies</li><li><span class="math inline">\(T_1\)</span> overwrites <span class="math inline">\(r_2(\text{Dept=Sales or Dept=Legal}:x_1;y_1;z_0)\)</span>, implies</li><li><span class="math inline">\(w_1(z_1)\)</span> overwrites <span class="math inline">\(r_2(\text{Dept=Sales or Dept=Legal}:x_1;y_1;z_0)\)</span>, implies</li><li>Overwriting in G1-predB does not require <span class="math inline">\(w_1(z_1)\)</span> is a modification that changes the set of objects matched by <span class="math inline">\(\text{Dept=Sales or Dept=Legal}\)</span>.</li></ul><h4 id="isolation-level-pl-3">Isolation Level PL-3</h4><p><strong>G2: Anti-dependency Cycles.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G2 if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle having one or more <strong>anti-dependency</strong> edges.</p><p>We define PL-3 as an isolation level that proscribes G1 and G2. Thus, all cycles are precluded at this level.</p><h4 id="pl-3-provides-conflict-serializability">PL-3 provides conflict-serializability</h4><p>The author claims that PL-3 provides conflict-serializability, but there is no detailed verification provided:</p><p>The conditions given in [BHG87] provides view-serializability whereas our specification for PL-3 provides conflict-serializability (this can shown using theorems presented in [GR93, BHG87]).</p><p><span class="math inline">\(\operatorname{DSG}(H)\)</span> is acyclic, and G1a, and G1b are satisfied for a history <span class="math inline">\(H\)</span> iff <span class="math inline">\(H\)</span> is conflict-serializable.</p><p>The Wormhole Theorem, as described in section 7.5.8.1 of "Transaction Processing: Concepts and Techniques" by J. N. Gray and A. Reuter (Morgan Kaufmann Publishers Inc., 1993), states:</p><p>A history achieves isolation if and only if it contains no wormhole transactions.</p><ul><li>Proof: (Isolated =&gt; no wormholes). This proof is by contradiction.<ol type="1"><li>Suppose <span class="math inline">\(H\)</span> is an isolated history of the execution of the set of transactions <span class="math inline">\(\left\{T_i \mid i=1, \ldots, n\right\}\)</span>. By definition, then, <span class="math inline">\(H\)</span> is equivalent to some serial execution history, <span class="math inline">\(SH\)</span>, for that same set of transactions.</li><li>Without loss of generality, assume that the transactions are numbered so that <span class="math inline">\(SH = T_1 \| T_2 \| \ldots \| T_n\)</span>.</li><li>Suppose, for the sake of contradiction, that <span class="math inline">\(H\)</span> has a wormhole; that is, there is some sequence of transactions <span class="math inline">\(T, T^\prime, T^{\prime\prime}, \ldots, T^{\prime\prime\prime}\)</span> such that each is BEFORE the other (i.e., <span class="math inline">\(T \ll_H T^\prime\)</span>), and the last is BEFORE the first (i.e., <span class="math inline">\(T^{\prime\prime\prime} \ll_H T\)</span>).</li><li>Let <span class="math inline">\(i\)</span> be the minimum transaction index such that <span class="math inline">\(T_i\)</span> is in this wormhole, and let <span class="math inline">\(T_j\)</span> be its predecessor in the wormhole (i.e., <span class="math inline">\(T_j \ll_H T_i\)</span>).</li><li>By the minimality of <span class="math inline">\(i\)</span>, <span class="math inline">\(T_j\)</span> comes completely AFTER <span class="math inline">\(T_i\)</span> in the execution history <span class="math inline">\(SH\)</span> (recall assumption of step 2), so that <span class="math inline">\(T_j \ll_{SH} T_i\)</span> is impossible (recall that <span class="math inline">\(SH\)</span> is a serial history). But since <span class="math inline">\(H\)</span> and <span class="math inline">\(SH\)</span> are equivalent, <span class="math inline">\(\ll_{H} = \ll_{SH}\)</span>; therefore, <span class="math inline">\(T_j \ll_H T_i\)</span> is also impossible. This contradiction proves that if <span class="math inline">\(H\)</span> isisolated, it has no wormholes.</li></ol></li><li>Proof: (No wormholes =&gt; isolated). This proof is by induction on the number of transactions, <span class="math inline">\(n\)</span>, that appear in the history, <span class="math inline">\(H\)</span>. The induction hypothesis is that any <span class="math inline">\(n\)</span> transaction history <span class="math inline">\(H\)</span> having no wormholes is isolated (equivalent to some serial history, <span class="math inline">\(SH\)</span>, for that set of transactions).<ul><li>If <span class="math inline">\(n &lt; 2\)</span>, then any history is a serial history, since only zero or one transaction appears in the history. In addition, any serial history is an isolated history. The basis of the induction, then, is trivially true.</li><li>Suppose the induction hypothesis is true for <span class="math inline">\(n-1\)</span> transactions, and consider some history <span class="math inline">\(H\)</span> of <span class="math inline">\(n\)</span> transactions that has no wormholes.<ol type="1"><li>Pick any transaction <span class="math inline">\(T\)</span>, then pick any other transaction <span class="math inline">\(T^\prime\)</span>, such that <span class="math inline">\(T \ll T^\prime\)</span>, and continue this construction as long as possible, building the sequence <span class="math inline">\(S = (T, T^\prime, \ldots)\)</span>. Either <span class="math inline">\(S\)</span> is infinite, or it is not. If <span class="math inline">\(S\)</span> is infinite, then some transaction <span class="math inline">\(T^{\prime\prime}\)</span> must appear in it twice. This, in turn, implies that <span class="math inline">\(T^{\prime\prime} \ll T^{\prime\prime}\)</span>; thus, <span class="math inline">\(T^{\prime\prime}\)</span> is a wormhole of <span class="math inline">\(H\)</span>. But since <span class="math inline">\(H\)</span> has no wormholes, <span class="math inline">\(S\)</span> cannot be infinite. The last transaction in <span class="math inline">\(S\)</span> - call it <span class="math inline">\(T^*\)</span> - has the property <span class="math inline">\(\operatorname{AFTER}(T^*) = \varnothing\)</span>, since the sequence cannot be continued past <span class="math inline">\(T^*\)</span>.</li><li>Consider the history, <span class="math inline">\(H^\prime = \left\langle\left\langle t_i, a_i, o_i\right\rangle \in H \mid t_i \neq T^*\right\rangle\)</span>. <span class="math inline">\(H^\prime\)</span> is the history <span class="math inline">\(H\)</span> with all the actions of transaction <span class="math inline">\(T^*\)</span> removed. By the choice of <span class="math inline">\(T^*\)</span>, <span class="math inline">\(\operatorname{DEP}(H^\prime) = \left\{\langle T, \langle o, i\rangle, T^\prime\rangle \in \operatorname{DEP}(H) \mid T^\prime \neq T^*\right\}\)</span>.<ol type="1"><li><span class="math inline">\(H^\prime\)</span> has no wormholes (since <span class="math inline">\(H\)</span> has no wormholes, and <span class="math inline">\(\operatorname{DEP}(H) \supseteq \operatorname{DEP}(H^\prime)\)</span>). The induction hypothesis, then, applies to <span class="math inline">\(H^\prime\)</span>. Hence, <span class="math inline">\(H^\prime\)</span> is isolated and has an equivalent serial history <span class="math inline">\({SH}^\prime = T_1 \| T_2 \| \ldots \| T_{n-1}\)</span> for some numbering of the other transactions.</li><li>The serial history <span class="math inline">\(SH = {SH}^\prime \| T^* = T_1 \| T_2 \| \ldots \| T_{n-1} \| T^*\)</span> is equivalent to <span class="math inline">\(H\)</span>. To prove this, it must be shown that <span class="math inline">\(\operatorname{DEP}(SH) = \operatorname{DEP}(H)\)</span>. By construction, <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:by-construction}\)</span>. By definition, <span class="math inline">\(\operatorname{DEP}({SH}^\prime) = \operatorname{DEP}(H^\prime)\)</span>. Using Equation <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:h-prime-depend}\)</span> to substitute into Equation <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:by-construction}\)</span> gives: <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:final}\)</span>. Thus, the identity <span class="math inline">\(DEP(SH)= DEP(H)\)</span> is established, and the induction step is proven.</li></ol></li></ol></li><li>The notion <span class="math inline">\(\langle t_i, a_i, o_i\rangle\)</span> represents that transaction <span class="math inline">\(t_i\)</span> performs action <span class="math inline">\(a_i\)</span> (e.g., read) on object <span class="math inline">\(o_i\)</span>. The notion <span class="math inline">\(\left\langle T, \langle o, i\rangle, T^\prime\right\rangle\)</span> represents that <span class="math inline">\(T^\prime\)</span> depends on <span class="math inline">\(T\)</span>, where <span class="math inline">\(o\)</span> is the object creating the dependency, and <span class="math inline">\(i\)</span> indicates the version of <span class="math inline">\(o\)</span> being read or written by <span class="math inline">\(T^\prime\)</span>.</li></ul></li></ul><p><span class="math display">\[\begin{align}  \operatorname{DEP}(SH)= \operatorname{DEP}({SH}^\prime \| T^*)=   \operatorname{DEP}({SH}^\prime)  \cup    \left\{      \left\langle T^\prime, \langle o, i\rangle, T^*\right\rangle      \in \operatorname{DEP}(H)    \right\}\label{the-wormhole-theorem:no-wormholes-infer-isolated:by-construction}\end{align}\]</span></p><p><span class="math display">\[\begin{align}    \operatorname{DEP}({SH}^\prime)  = \operatorname{DEP}(H^\prime)  = \left\{        \left\langle T, \langle o, i\rangle, T^\prime\right\rangle        \in \operatorname{DEP}(H)      \mid        T^\prime \neq T^*    \right\}\label{the-wormhole-theorem:no-wormholes-infer-isolated:h-prime-depend}\end{align}\]</span></p><p><span class="math display">\[\begin{align}&amp;\phantom{=} \operatorname{DEP}(SH)           \\          &amp;= \phantom{\cup}&amp;               \left\{                   \left\langle T, \langle o, i\rangle, T^\prime\right\rangle                   \in \operatorname{DEP}(H)                 \mid                  T^\prime \neq T^*               \right\}             \nonumber \\             &amp;\phantom{=} &amp;\cup               \left\{                 \left\langle T^\prime, \langle o, i\rangle, T^*\right\rangle                 \in \operatorname{DEP}(H)               \right\}             \nonumber \\          &amp;= \operatorname{DEP}(H)  \nonumber\label{the-wormhole-theorem:no-wormholes-infer-isolated:final}\end{align}\]</span></p><p>The Serializability Theorem, as described in Section 2.3 of "Concurrency Control and Recovery in Database Systems" by Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman, states:</p><p>A history <span class="math inline">\(H\)</span> is serializable iff <span class="math inline">\(\operatorname{SG}(H)\)</span> is acyclic.</p><ul><li>Proof: (Acyclic =&gt; serializable).<ol type="1"><li>Suppose <span class="math inline">\(H\)</span> is a history over <span class="math inline">\(T = \left\{T_1, T_2, \ldots, T_n\right\}\)</span>. Without loss of generality, assume <span class="math inline">\(\operatorname{C}(T) = \left\{T_1, T_2, \ldots, T_m \mid m \le n\right\}\)</span> are all of the transactions in <span class="math inline">\(T\)</span> that are committed in <span class="math inline">\(H\)</span>. Thus <span class="math inline">\(T_1, T_2, \ldots, T_m\)</span> are the nodes of <span class="math inline">\(\operatorname{SG}(H)\)</span>.</li><li>Since <span class="math inline">\(\operatorname{SG}(H)\)</span> is acyclic it may be topologically sorted (See Section A.3 of the Appendix for a definition of "topological sort of a directed acyclic graph"). Let <span class="math inline">\(i_1, i_2, \ldots, i_m\)</span> be a permutation of <span class="math inline">\(1, 2, \ldots, m\)</span> such that <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span> is a topological sort of <span class="math inline">\(\operatorname{SG}(H)\)</span>. Let <span class="math inline">\(H_s\)</span> be the serial history <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span>.</li><li>We claim that <span class="math inline">\(\operatorname{C}(H) \equiv H_s\)</span>. To see this, let <span class="math inline">\(p_i \in T_i\)</span> and <span class="math inline">\(q_j \in T_j\)</span>, where <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_j\)</span> are committed in <span class="math inline">\(H\)</span>. Suppose <span class="math inline">\(p_i\)</span>, <span class="math inline">\(q_j\)</span> conflict and <span class="math inline">\(p_i \lt_H q_j\)</span>. By definition of <span class="math inline">\(\operatorname{SG}(H)\)</span>, <span class="math inline">\(T_i \rightarrow T_j\)</span> is an edge in <span class="math inline">\(\operatorname{SG}(H)\)</span>. Therefore in any topological sort of <span class="math inline">\(\operatorname{SG}(H)\)</span>, <span class="math inline">\(T_i\)</span> must appear before <span class="math inline">\(T_j\)</span>. Thus in <span class="math inline">\(H_s\)</span> all operations of <span class="math inline">\(T_i\)</span> appear before any operation of <span class="math inline">\(T_j\)</span>, and in particular, <span class="math inline">\(p_i \lt_H q_j\)</span>. We have proved that any two conflicting operations are ordered in <span class="math inline">\(\operatorname{C}(H)\)</span> in the same way as <span class="math inline">\(H_s\)</span>. Thus <span class="math inline">\(\operatorname{C}(H) \equiv H_s\)</span> and, because <span class="math inline">\(H_s\)</span> is serial by construction, <span class="math inline">\(H\)</span> is serializable as was to be proved.</li></ol></li><li>Proof: (Serializable =&gt; acyclic).<ol type="1"><li>Suppose history <span class="math inline">\(H\)</span> is serializable. Let <span class="math inline">\(H_s\)</span> be a serial history equivalent to <span class="math inline">\(\operatorname{C}(H)\)</span>. Consider an edge <span class="math inline">\(T_i \rightarrow T_j\)</span> in <span class="math inline">\(\operatorname{SG}(H)\)</span>. Thus there are two conflicting operations <span class="math inline">\(p_i\)</span>, <span class="math inline">\(q_j\)</span> of <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_j\)</span> (respectively), such that <span class="math inline">\(p_i \lt_H q_j\)</span>. Because <span class="math inline">\(\operatorname{C}(H) \equiv H\)</span>, <span class="math inline">\(p_i \lt_{H_s} q_j\)</span>. Because <span class="math inline">\(H_s\)</span> is serial and <span class="math inline">\(p_i\)</span> in <span class="math inline">\(T_i\)</span> precedes <span class="math inline">\(q_j\)</span> in <span class="math inline">\(T_j\)</span>, it follows that <span class="math inline">\(T_i\)</span> appears before <span class="math inline">\(T_j\)</span> in <span class="math inline">\(H_s\)</span>. Thus, we've shown that if <span class="math inline">\(T_i \rightarrow T_j\)</span> is in <span class="math inline">\(\operatorname{SG}(H)\)</span> then <span class="math inline">\(T_i\)</span> appears before <span class="math inline">\(T_j\)</span> in <span class="math inline">\(H_s\)</span>.</li><li>Now suppose there is a cycle in <span class="math inline">\(\operatorname{SG}(H)\)</span>, and without loss of generality let that cycle be <span class="math inline">\(T_1 \rightarrow T_2 \rightarrow \ldots \rightarrow T_k \rightarrow T_1\)</span>. These edges imply that in <span class="math inline">\(H_s\)</span>, <span class="math inline">\(T_1\)</span> appears before <span class="math inline">\(T_2\)</span> which appears before <span class="math inline">\(T_3\)</span> appears before <span class="math inline">\(\ldots\)</span> before <span class="math inline">\(T_k\)</span> which appears before <span class="math inline">\(T_1\)</span>. Thus, the existence of the cycle implies that each of <span class="math inline">\(T_1, T_2, \ldots, T_k\)</span> appears before itself in the serial history <span class="math inline">\(H_s\)</span>, an absurdity. So no cycle can exist in <span class="math inline">\(\operatorname{SG}(H)\)</span>. That is, <span class="math inline">\(\operatorname{SG}(H)\)</span> is an acyclic directed graph, as was to be proved.</li></ol></li></ul><h4 id="isolation-level-pl-2.99">Isolation Level PL-2.99</h4><p><strong>G2-item: Item Anti-dependency Cycles.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G2-item if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle having one or more <strong>item</strong>-anti-dependency edges.</p><p>Level PL-2.99 is defined as one that proscribes G1 and G2-item.</p><p><span class="math inline">\(H_{phantom}\)</span> is ruled out by PL-3 but permitted by PL-2.99 because the DSG contains a cycle only if predicate anti-dependency edges are considered.</p><p><span class="math display">\[\begin{align*}H_{phantom}: r_1(\text{Dept=Sales}:x0,10;y0,10) &amp;\\             r_2(Sum0,20)                       &amp;\\             w_2(z_2=10 \text{ in Dept=Sales})  &amp;\\             w_2(Sum_2,30)                      &amp;\\             c_2                                &amp;\\             r_1(Sum_2,30)                      &amp;\\             c_1                                &amp;\\[Sum_0 \ll Sum_2, z_{init} \ll z_2]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T0 --&gt;|wr| T1;  T0 --&gt;|wr| T2;  T1 -.-&gt;|predicate-rw| T2;  T2 --&gt;|wr| T1;</code></pre><h3 id="mixing-of-isolation-levels">Mixing of Isolation Levels</h3><h3 id="correctness-and-flexibility-of-the-new-specifications">Correctness and Flexibility of the New Specifications</h3><h3 id="consistency-guarantees-for-executing-transactions">Consistency Guarantees for Executing Transactions</h3><p>All definitions presented in this chapter till now provide guarantees to committed transactions only. In this section, we discuss how the isolation levels presented in this chapter can be extended to provide guarantees to executing transactions. To ensure that there is no confusion regarding isolation levels for committed and executing transactions, we prefix all levels for executing transactions by "E".</p><h4 id="motivation">Motivation</h4><ul><li>Suppose that a programmer writes code under the assumption that certain integrity constraints will hold. If these constraints are violated, the transaction will be aborted when it tries to commit. However, before the transaction reaches its commit point, the program may behave in an unexpected manner, e.g., it may crash, go into an infinite loop, or output unexpected results on a user’s display.</li><li>Debugging also becomes more difficult for an application programmer; if the transaction observes a broken invariant, it may be difficult for the programmer to determine whether the invariant was violated due to a code bug or due to weak consistency guarantees provided to executing transactions by the system.</li></ul><p>If a transaction <span class="math inline">\(T_i\)</span> requires execution-time isolation guarantee <span class="math inline">\(L\)</span>, the system must ensure that <span class="math inline">\(T_i\)</span> does not detect that it is running below level <span class="math inline">\(L\)</span> at any given instant. Transaction <span class="math inline">\(T_i\)</span> can detect that it is running below level <span class="math inline">\(L\)</span> if it <strong>reads</strong> objects in a manner that is not allowed by that level. Since a transaction can determine whether it is executing below a certain degree only by observing the state of the database, our conditions will provide guarantees <strong>only for reads of uncommitted transactions and not for their writes</strong>.</p><p>For the purpose of providing consistency guarantees to an executing transaction <span class="math inline">\(T_i\)</span>, we consider <span class="math inline">\(T_i\)</span>'s predicate-based writes as predicate-based reads. This approach is taken so that appropriate guarantees can be provided for version sets of predicate-based writes performed by <span class="math inline">\(T_i\)</span> (ghost writes performed by <span class="math inline">\(T_i\)</span> are essentially reads).</p><h4 id="isolation-levels-epl-1-and-epl-2">Isolation Levels EPL-1 and EPL-2</h4><p>Isolation level PL-1 provides guarantees with respect to writes. Since our execution time guarantees are provided only for reads, level EPL-1 does not place any constraints on executing transactions.</p><p>Isolation level PL-2 guarantees that a transaction is allowed to commit if it observes values that existed in the committed state and there is unidirectional flow of information. To ensure that a transaction <span class="math inline">\(T_j\)</span> (while executing) reads from a transaction <span class="math inline">\(T_i\)</span> that does not later abort or modify the objects read by <span class="math inline">\(T_j\)</span> , we disallow reads from uncommitted transactions; furthermore, <strong>no dirty reads also ensure unidirectional information flow</strong>. We define EPL-2 as a level that disallows phenomenon P1.</p><h4 id="isolation-level-epl-3">Isolation Level EPL-3</h4><p>To specify EPL-3 for a history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span>, we use a new graph called the <strong>Direct Transaction Graph</strong> that is denoted by <span class="math inline">\(\operatorname{DTG}(H,T_i)\)</span>; recall that a DSG was defined for a history only. The DTG is exactly the same as DSG with one addition: it also contains a node for executing transaction <span class="math inline">\(T_i\)</span> and we add all edges corresponding to the <strong>reads</strong> of <span class="math inline">\(T_i\)</span> . Recall that we treat all predicate-based writes of <span class="math inline">\(T_i\)</span> as predicate-based reads so that consistency guarantees can be provided for version sets of predicate-based writes. Thus, we get some extra read-dependency and anti-dependency edges due to such "reads", e.g., if executing transaction <span class="math inline">\(T_i\)</span> performs <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span> and <span class="math inline">\(\operatorname{Vset}(P)\)</span> contains <span class="math inline">\(x_j\)</span>, we add a read-dependency edge from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(T_i\)</span> in the DTG.</p><p><span class="math display">\[\begin{align*}H_{incons-view}: w_0(x_0) &amp;\\                 w_0(y_0) &amp;\\                 c_0      &amp;\\                 w_1(x_1) &amp;\\                 w_1(y_1) &amp;\\                 c_1      &amp;\\                 r_2(x_0) &amp;\\                 r_2(y_1) &amp;\\[x_0 \ll x_1; y_0 \ll y_1]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T1[T1-committed];  T2[T2-executing];  T1 --&gt;|wr| T2;  T2 -.-&gt;|rw| T1;</code></pre><p><strong>E2: Anti-dependency Cycles at Runtime.</strong> A history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span> exhibit phenomenon E2 if <span class="math inline">\(\operatorname{DTG}(H,T_i)\)</span> contains a directed cycle involving <span class="math inline">\(T_i\)</span> that consists of dependency edges and one or more anti-dependency edges.</p><p>EPL-3 is defined as an isolation level that disallows phenomena P1 and E2. It is more restrictive than PL-3:</p><ul><li>P1 is more stringent than G1a: Aborted Reads, G1b: Intermediate Reads, G1c: Circular Information Flow.<ul><li>No dirty reads also ensure unidirectional information flow.</li></ul></li><li>E2: Anti-dependency Cycles at Runtime is more stringent than G2: Anti-dependency Cycles because E2 takes executing transactions into account.</li></ul><p>Note that we are ignoring anti-dependency edges due to writes by uncommitted transactions. This is in accordance with our goal of providing execution time guarantees for reads only. However, it also turns out that such writes must be ignored so that optimistic schemes can be allowed. To provide EPL-3, one might be tempted to say that all cycles are disallowed in the direct transaction graph. However, this condition is overly restrictive as shown by the following history:</p><p><span class="math display">\[\begin{align*}H_{antidep-cycle}: r_1(x_0) &amp;\\                   w_2(x_2) &amp;\\                   r_2(y_0) &amp;\\                   c_2      &amp;\\                   w_1(y_1) &amp;\\[x_0 \ll x_2, y_0 \ll y_1]\end{align*}\]</span></p><p>In this example, <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span> overwrite an object that the other transaction has read.</p><pre><code class=" mermaid">graph LR;  T0[T0-committed];  T1[T1-executing];  T2[T2-committed];  T0 --&gt;|ww,wr| T1;  T0 --&gt;|ww,wr| T2;  T1 -.-&gt;|rw| T2;  T2 -.-&gt;|rw| T1;</code></pre><p>Transaction <span class="math inline">\(T_1\)</span> is doomed to abort since a cycle with two anti-dependency edges has been formed.</p><ul><li>However, since it does not observe a non-serializable database state, there is no harm in executing it.</li><li>Furthermore, this situation can occur with an optimistic scheme in a client-server distributed system where <span class="math inline">\(T_1\)</span> may read <span class="math inline">\(x_0\)</span> and write <span class="math inline">\(y_1\)</span> in its client's cache before information about <span class="math inline">\(T_2\)</span>'s commit arrives at <span class="math inline">\(T_1\)</span>'s client.</li></ul><h2 id="specifications-for-intermediate-isolation-levels">Specifications for Intermediate Isolation Levels</h2><p>There is a wide gap between PL-2, which provides neither consistent reads nor consistent writes, and PL-3, which provides both (this is analogous to the gap between degrees 2 and 3).</p><pre><code class=" mermaid">graph BT;  PL-1;  PL-2;  PL-2L[PL-2L: Monotonic View];  PL-2+[PL-2+: Consistent View];  PL-FCV[PL-FCV: Forward Consistent View];  PL-3U[PL-3U: Update Serializability];  PL-3[PL-3: Full Serializability];  PL-SS[PL-SS: Strict Serializability];  PL-MSR[PL-MSR: Monotonic Snapshot Reads];  PL-SI[PL-SI: Snapshot Isolation];  PL-CS[PL-CS: Cursor Stability];  PL-2.99[PL-2.99: Repeatable Read];  style PL-1 fill:#ffffba;  style PL-2 fill:#ffffba;  style PL-2+ fill:#ffffba;  style PL-3 fill:#ffffba;  style PL-SI fill:#ffffba;  PL-1 --&gt; PL-2;  PL-2 --&gt; PL-2L;  PL-2L --&gt; PL-2+;  PL-2L --&gt; PL-MSR;  PL-2+ --&gt; PL-FCV;  PL-FCV --&gt; PL-3U;  PL-FCV --&gt; PL-SI;  PL-3U --&gt; PL-3;  PL-3 --&gt; PL-SS;  PL-2 --&gt; PL-CS;  PL-CS --&gt; PL-2.99;  PL-CS --&gt; PL-2+;  PL-2.99 --&gt; PL-3;  PL-2 --&gt; PL-MSR;  PL-MSR --&gt; PL-SI;  PL-SI --&gt; PL-SS;</code></pre><h3 id="isolation-level-pl-2-1">Isolation Level PL-2+</h3><p>Isolation level PL-2+ is motivated by the fact that certain applications only need to observe a consistent state of the database and serializability may not be required. In simpler terms, PL-2+ delivers consistent reads, a feature not offered by PL-2.</p><p>Consider the following history <span class="math inline">\(H_{broken}\)</span> where transaction <span class="math inline">\(T_1\)</span> observes an inconsistent state of the database. The consistency constraint, <span class="math inline">\(x + y \le 0\)</span>, is preserved by <span class="math inline">\(T_2\)</span>. However, transaction <span class="math inline">\(T_1\)</span> observes a state reflecting both before and after results of <span class="math inline">\(T_2\)</span> and erroneously concludes that the constraint is broken.</p><p><span class="math display">\[\begin{align*}H_{broken}: r_1(x_0,-50) &amp;\\            r_2(x_0,-50) &amp;\\            r_2(y_0,100) &amp;\\            w_2(x_2,100) &amp;\\            w_2(y_2,-50) &amp;\\            c_2          &amp;\\            r_1(y_2,-50) &amp;\\            c_1          &amp;\\[x_0 \ll x_2, y_0 \ll y_2]\end{align*}\]</span></p><p>The following <span class="math inline">\(\operatorname{DSG}(H_{broken})\)</span> shows that history <span class="math inline">\(H_{broken}\)</span> is allowed by PL-2 because the only cycle in <span class="math inline">\(\operatorname{DSG}(H_{broken})\)</span> involves an anti-dependency edge (for simplicity, <span class="math inline">\(T_0\)</span> is not shown); however, it is disallowed by PL-3. Note that P0 and P1 also allow <span class="math inline">\(H_{broken}\)</span>.</p><pre><code class=" mermaid">graph LR;  T1 -.-&gt;|rw| T2;  T2 --&gt;|wr| T1;</code></pre><p>The author introduces the no-depend-misses property, demonstrated by Chan and Gray to guarantee transaction <span class="math inline">\(T_j\)</span> does not observe violated integrity constraints if update transactions are serializable (i.e., commit at PL-3). The author then proves that disallowing G-single is equivalent to no-depend-misses, and presents PL-2+, which ensures consistent reads but not consistent writes.</p><h4 id="specification">Specification</h4><p><strong>Basic-Consistency.</strong> A transaction <span class="math inline">\(T_j\)</span> is provided basic-consistency if the values read by <span class="math inline">\(T_j\)</span> are the result of a serial execution of <strong>some subset of committed update transactions</strong> and each update transaction in the serial execution <strong>executes the same steps</strong> as it did in the concurrent execution.</p><p>In my understanding, "executing the same steps" implies that, within <strong>a subset of update transactions</strong>, each update transaction in the serial execution <strong>observes the same versions of objects</strong> and <strong>produces the same versions (values) of objects</strong> as it did in the concurrent execution of all update transactions.</p><p>It's important to note that we can't select arbitrary subsets of committed update transactions for <span class="math inline">\(T_j\)</span>. Basic consistency necessitates each update transaction in the serial execution to <strong>execute same steps</strong> (possibly <strong>observe the same versions of objects</strong> and <strong>produce the same versions (values) of objects</strong>) as in the concurrent execution. Consequently, update transaction <span class="math inline">\(T_i\)</span> must yields the same write operations in both serial and concurrent executions if it observes the same state. However, if <span class="math inline">\(T_i\)</span> observes a different state in the serial executions due to an incorrect subset of committed update transactions, it may not execute the same write operations. For example, if <span class="math inline">\(T_j\)</span> observes the updates of <span class="math inline">\(T_i\)</span>, it must not "miss the effects" of a transaction <span class="math inline">\(T_k\)</span> whose updates were observed by <span class="math inline">\(T_i\)</span>, i.e., basic-consistency requires that if the subset of transactions chosen for <span class="math inline">\(T_j\)</span>'s observed view includes <span class="math inline">\(T_i\)</span>, it must include <span class="math inline">\(T_k\)</span> as well.</p><p>We assume that the committed database state is consistent if the integrity constraints as defined by an application are valid. Furthermore, if an update transaction <span class="math inline">\(T_i\)</span> observes valid integrity constraints and runs alone to completion, we assume that it transforms the committed database state such that the integrity constraints continue to hold after <span class="math inline">\(T_i\)</span> commits.</p><p>As discussed in <a href="https://dl.acm.org/doi/pdf/10.1145/323596.323607">W. E. Weihl. Distributed Version Management for Read-only Actions</a>, basic-consistency ensures that <span class="math inline">\(T_j\)</span> observes a consistent state of the database because the result of a serial execution of update transactions always results in a consistent state.</p><p><strong>Missing Transaction Updates.</strong> A transaction <span class="math inline">\(T_j\)</span> misses the effects of a transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs <span class="math inline">\(x_i\)</span> and an event <span class="math inline">\(r_j(x_k)\)</span> exists such that <span class="math inline">\(x_k \ll x_i\)</span>, i.e., <span class="math inline">\(T_j\)</span> reads a version of <span class="math inline">\(x\)</span> that is older than the version that was installed by <span class="math inline">\(T_i\)</span>.</p><p><strong>No-Depend-Misses</strong>. If <span class="math inline">\(T_j\)</span> depends on <span class="math inline">\(T_i\)</span>, it does not miss the effects of <span class="math inline">\(T_i\)</span>. This property (along with P1) has been shown by <a href="https://ieeexplore.ieee.org/document/1702133">W. E. Weihl. Distributed Version Management for Read-only Actions</a> to ensure that transaction <span class="math inline">\(T_j\)</span> does not observe violated integrity constraints if update transactions are serializable (i.e., commit at PL-3). We give a synopsis of this proof in <a href="#relationship-between-pl-2+-and-basic-consistency">Relationship between PL-2+ and Basic-Consistency</a>.</p><p><strong>G-single</strong>: Single Anti-dependency Cycles. A history <span class="math inline">\(H\)</span> exhibits phenomenon G-single if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle with <strong>exactly one anti-dependency edge</strong>.</p><p>We now prove Theorem 2+, which states that disallowing G-single is equivalent to no-depend-misses:</p><ul><li>Disallowing G-single implies no-depend-misses.<ul><li>Suppose that a history <span class="math inline">\(H\)</span> does not exhibit G-single but the no-depend-misses property is violated. Then there exist transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_j\)</span> depends on <span class="math inline">\(T_i\)</span>, yet it misses some effect of <span class="math inline">\(T_i\)</span>; recall that missing <span class="math inline">\(T_i\)</span>'s effects implies that history <span class="math inline">\(H\)</span> contains events <span class="math inline">\(r_j(x_k)\)</span> and <span class="math inline">\(w_i(x_i)\)</span> such that <span class="math inline">\(xk \ll xi\)</span>. This situation is shown in the following figure where <span class="math inline">\(T_u\)</span> overwrites <span class="math inline">\(x_k\)</span> and hence there is an anti-dependency edge from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(T_u\)</span>; a "*" denotes 0 or more edges and a "+" denotes 1 or more edges. In this figure, <span class="math inline">\(T_i\)</span> could be the same as <span class="math inline">\(T_u\)</span>, i.e., <span class="math inline">\(T_i\)</span> could have overwritten the version that <span class="math inline">\(T_j\)</span> read. Thus, the DSG has a cycle with one anti-dependency edge, which is a contradiction. Therefore, if history <span class="math inline">\(H\)</span> does not exhibit phenomenon G-single, it satisfies the no-depend-misses property.</li></ul></li><li>No-depend-misses implies that phenomenon G-single cannot occur.<ul><li>Suppose that a history <span class="math inline">\(H\)</span> satisfies no-depend-misses but exhibits phenomenon G-single. The existence of a cycle with one anti-dependency edge implies that there must be transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_i\)</span> depends on <span class="math inline">\(T_j\)</span> and also <span class="math inline">\(T_j\)</span> <strong>directly</strong> anti-depends on <span class="math inline">\(T_i\)</span>. Because of the direct anti-dependency, there must be some object <span class="math inline">\(x\)</span> such that <span class="math inline">\(T_j\)</span> overwrote the version of <span class="math inline">\(x\)</span> that <span class="math inline">\(T_i\)</span> read, i.e., <span class="math inline">\(T_i\)</span> missed <span class="math inline">\(T_j\)</span>'s effects even though it depends on <span class="math inline">\(T_j\)</span>. But this contradicts the no-depend-misses property. Therefore, if <span class="math inline">\(H\)</span> satisfies the no-depend-misses property, phenomenon G-single cannot occur in <span class="math inline">\(H\)</span>.</li></ul></li></ul><pre><code class=" mermaid">graph LR;  Tk --&gt;|ww| Tu;  Tk --&gt;|wr| Tj;  Tj -.-&gt;|rw| Tu;  Tu --&gt;|ww*| Ti;  Ti --&gt;|ww+/wr+| Tj;</code></pre><p>Level PL-2+ proscribes G1 and G-single. Intuitively, PL-2+ provides consistency because cycles with one anti-dependency edge occur exactly when some transaction both observes and misses modifications of another transaction.</p><h4 id="relationship-between-pl-2-and-basic-consistency">Relationship between PL-2+ and Basic-Consistency</h4><p id=relationship-between-pl-2+-and-basic-consistency><p>We now show that PL-2+ is the <strong>weakest</strong> level that ensures basic-consistency provided update transactions modify the database consistently and are serializable.</p><p>Theorem: In a history that contains a set of transactions <span class="math inline">\(\Phi\)</span>, <strong>such that</strong> all update transactions in <span class="math inline">\(\Phi\)</span> are serializable, each transaction is provided basic-consistency iff it is committed with at least PL-2+ guarantees.</p><p>We will prove this theorem with respect to the reads of a transaction <span class="math inline">\(Q\)</span> in <span class="math inline">\(\Phi\)</span>; <span class="math inline">\(Q\)</span>'s writes are not considered since basic-consistency is only concerned with what a transaction observes. Of course, if <span class="math inline">\(Q\)</span> is an update transaction, it must be serializable (by assumption).</p><ul><li>PL-2+ is sufficient: Given that all update transactions in <span class="math inline">\(\Phi\)</span> are serializable and <span class="math inline">\(Q\)</span> is committed at level PL-2+ (at least), <span class="math inline">\(Q\)</span> must be provided basic-consistency.<ul><li>Suppose that transaction <span class="math inline">\(Q\)</span> depends on a sequence of transactions <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span> in <span class="math inline">\(\Phi\)</span> (these transactions are serialized from left to right); we call these transactions <span class="math inline">\(Q\)</span>'s depend-set. Transaction <span class="math inline">\(Q\)</span> misses the effects of the rest of the transactions in <span class="math inline">\(\Phi\)</span>; these transactions are called <span class="math inline">\(Q\)</span>'s missed-set; <span class="math inline">\(Q\)</span> <strong>may anti-depend on</strong> some of the transactions in its missed-set.</li><li>We can prove <span class="math inline">\(Q\)</span> is provided basic-consistency with the following two steps:<ul><li>Each update transaction in <span class="math inline">\(Q\)</span>'s depend-set executes the same steps (observes the same versions of objects and produces the same versions (values) of objects) as it did in the concurrent execution.<ul><li>Consider any transaction <span class="math inline">\(T_{i_p}\)</span> in <span class="math inline">\(Q\)</span>'s depend-set; <span class="math inline">\(T_{i_p}\)</span>'s depend-set is a subset of <span class="math inline">\(Q\)</span>'s depend-set because depends is a transitive relationship. Since <span class="math inline">\(T_{i_p}\)</span> does not depend on any transaction <span class="math inline">\(T_{k_h}\)</span> in <span class="math inline">\(Q\)</span>'s missed-set, <span class="math inline">\(T_{k_h}\)</span> has no impact on <span class="math inline">\(T_{i_p}\)</span>'s behavior, i.e., <span class="math inline">\(T_{i_p}\)</span>'s modifications (which are based on its reads) are unaffected by the presence or absence of any transaction in <span class="math inline">\(Q\)</span>'s missed-set. Considering a history with only <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span> (in this order), the database state observed by any transaction in this history remains unchanged.</li></ul></li><li>The values read by <span class="math inline">\(Q\)</span> are the result of a serial execution of its depend-set.<ul><li>Since <span class="math inline">\(Q\)</span> commits with at least PL-2+ guarantees, none of the transactions in its depend-set could have aborted (property G1a).</li><li>Furthermore, <span class="math inline">\(Q\)</span> must read the final modifications of each object (property G1b).</li><li>Since <span class="math inline">\(Q\)</span> commits with at least PL-2+ guarantees, G-single cannot occur for <span class="math inline">\(Q\)</span>. We have proven that disallowing G-single is equivalent to no-depend-misses, then <span class="math inline">\(Q\)</span> does not miss the effects of <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span>.</li></ul></li></ul></li></ul></li><li>PL-2+ is necessary: Given that all update transactions in <span class="math inline">\(\Phi\)</span> are serializable (i.e., commit at PL-3), <span class="math inline">\(Q\)</span> is provided basic-consistency only if it is committed with at least PL-2+ guarantees.<ul><li>We have to prove that <span class="math inline">\(Q\)</span> will not be provided basic-consistency if it is committed below PL-2+. For this purpose, we will show that if any phenomenon of PL-2+ is allowed, it results in violation of basic-consistency.<ul><li>Phenomena G1a and G1b: The definition of basic-consistency requires a transaction to read from a set of committed transactions. Thus, G1a and G1b must be disallowed for providing basic-consistency.</li><li>Phenomenon G1c: Phenomenon G1c can occur only when update transactions form a cycle consisting of dependency edges. However, since we are given that all update transactions in <span class="math inline">\(\Phi\)</span> are serializable and we are only concerned with <span class="math inline">\(Q\)</span>'s reads, phenomenon G1c cannot occur in the history.</li><li>Phenomenon G-single: <span class="math inline">\(H_{n-cycle}\)</span> is a counter-example which shows that basic-consistency can be violated if G-single is allowed. Each transaction <span class="math inline">\(T_i\)</span> maintains the invariant <span class="math inline">\(x&lt;y\)</span> but <span class="math inline">\(Q\)</span> observes it as broken.<ul><li>The author provides a counter-example, but this does not form a complete proof. It is still uncertain whether any histories exist that are both disallowed by G-single and do not violate basic-consistency. Further research is required to definitively answer this question.</li></ul></li></ul></li></ul></li></ul><p><span class="math display">\[\begin{align*}H_{n-cycle}: r_1(x_0,5)     &amp;\\             r_1(y_0,7)     &amp;\\             w_1(x_1,10)    &amp;\\             w_1(y_1,14)    &amp;\\             \ldots         &amp;\\             w_n(x_n,5*2^n) &amp;\\             w_n(y_n,7*2^n) &amp;\\             r_Q(y0,7)      &amp;\\             r_Q(x_n,5*2^n) &amp;\\[x_0 \ll \ldots x_n, y_0 \ll \ldots y_n]\end{align*}\]</span></p><h4 id="why-g-single-emphasizes-exactly-one-anti-dependency-edge">Why G-single Emphasizes Exactly One Anti-dependency Edge</h4><p>Why does G-single specifically emphasize having exactly one anti-dependency edge, rather than allowing one or more anti-dependency edges? As an example, let's consider <span class="math inline">\(H_{anti-dependency-edges}\)</span>. Notice that all update transactions in <span class="math inline">\(H_{anti-dependency-edges}\)</span> are serializable.</p><p><span class="math display">\[\begin{align*}H_{anti-dependency-edges}: w_0(x_0) &amp;\\                           w_0(y_0) &amp;\\                           c_0      &amp;\\                           r_1(x_0) &amp;\\                           r_2(x_0) &amp;\\                           r_2(y_0) &amp;\\                           w_2(x_2) &amp;\\                           c_2      &amp;\\                           r_3(y_0) &amp;\\                           w_3(y_3) &amp;\\                           c_3      &amp;\\                           r_1(y_3) &amp;\\                           c1       &amp;\\[x_0 \ll x_2, y_0 \ll y_3]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T0 --&gt;|wr| T1;  T0 --&gt;|wr,ww| T2;  T0 --&gt;|wr,ww| T3;  T1 -.-&gt;|rw| T2;  T2 -.-&gt;|rw| T3;  T3 --&gt;|wr| T1;</code></pre><p>Based on the wormhole theorem, a cycle in <span class="math inline">\(\operatorname{DSG}(H_{anti-dependency-edges})\)</span> containing two anti-dependency edges, indicates <span class="math inline">\(H_{anti-dependency-edges}\)</span> is non-serializable. Despite <span class="math inline">\(T_1\)</span> reading object versions that might not be present in any serializable schedule, basic consistency is preserved.</p><p>By removing <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span> from <span class="math inline">\(H_{anti-dependency-edges}\)</span>, we obtain <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>. We can demonstrate that the final state <span class="math inline">\(\{x_0, y_3\}\)</span> of <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span> satisfies the integrity constraints as follows:</p><ul><li><span class="math inline">\(T_3\)</span> is a valid transaction in <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span> because:<ul><li><span class="math inline">\(T_3\)</span> must be valid or invalid in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span> since it reads and writes the same versions of objects in both histories:<ul><li><span class="math inline">\(T_3\)</span> observes <span class="math inline">\(\{y_0\}\)</span> in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>.</li><li>We assume that if a transaction reads the same versions of objects, it must execute the same steps and write the same versions of objects. Based on this assumption, <span class="math inline">\(T_3\)</span> writes <span class="math inline">\(\{y_3\}\)</span> in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>.</li></ul></li><li><span class="math inline">\(T_3\)</span> is a valid transaction in <span class="math inline">\(H_{anti-dependency-edges}\)</span>.</li></ul></li><li><span class="math inline">\(\{x_0, y_3\}\)</span> is a a state that satisfies the integrity constraints:<ul><li>We assume that:<ul><li>The committed database state is consistent if the integrity constraints as defined by an application are valid.</li><li>Furthermore, if a valid update transaction <span class="math inline">\(T_i\)</span> observes valid integrity constraints and runs alone to completion, it transforms the committed database state such that the integrity constraints continue to hold after <span class="math inline">\(T_i\)</span> commits.</li></ul></li><li>Therefore:<ul><li><span class="math inline">\(\{x_0, y_0\}\)</span> is a state that satisfies the integrity constraints in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>.</li><li>Since <span class="math inline">\(T_3\)</span> observes a state that satisfies the integrity constraints and runs independently to completion, and it is a <strong>valid</strong> transaction, the integrity constraints must hold after <span class="math inline">\(T_3\)</span> commits.</li></ul></li></ul></li></ul><p>Drawing inspiration from the above example, let's consider a history <span class="math inline">\(H\)</span> that consists of serializable update transactions and exactly one read transaction <span class="math inline">\(Q\)</span> committed at PL-2+. Let <span class="math inline">\(H^\prime\)</span> be a subset of <span class="math inline">\(H\)</span> containing <span class="math inline">\(Q\)</span> and the depend-set of <span class="math inline">\(Q\)</span>. If <span class="math inline">\(Q\)</span> reads only the versions of objects written by its depend-set, then <span class="math inline">\(H\)</span> can be considered serializable. However, if this condition is not met, <span class="math inline">\(H\)</span> might not be serializable, and <span class="math inline">\(Q\)</span> could potentially read versions of objects not found in any serializable schedule of <span class="math inline">\(H\)</span>. Despite this possibility, <span class="math inline">\(Q\)</span> still maintains basic consistency. Please note that this statement serves as an intuitive understanding derived from the example, rather than a formal proof.</p><p>From a programmer’s perspective, PL-2+ provides a useful guarantee since it allows an application to <strong>rely on invariants without full serializability</strong>. As demonstrated in the case of <span class="math inline">\(H_{anti-dependency-edges}\)</span>, <span class="math inline">\(T_1\)</span> reads <span class="math inline">\(x_0\)</span> and <span class="math inline">\(y_3\)</span>, which are not present in any serializable schedule. Nevertheless, all integrity constraints remain intact.</p><h4 id="discussion">Discussion</h4><p>In <a href="#relationship-between-pl-2+-and-basic-consistency">Relationship between PL-2+ and Basic-Consistency</a>, the assumption is that all update transactions are serializable (e.g., committed at PL-3). However, if an update transaction is not committed at PL-3 but instead at PL-2+, there is a possibility that it may update the database inconsistently. For instance, in <span class="math inline">\(H_{wskew}\)</span>, transactions break the constraint <span class="math inline">\(x + y &lt; 10\)</span> because their operations are interleaved in a non-serializable manner.</p><p><span class="math display">\[\begin{align*}H_{wskew}: r_1(x_0,1) &amp;\\           r_1(y_0,5) &amp;\\           r_2(x_0,1) &amp;\\           r_2(y_0,5) &amp;\\           w_1(x_1,4) &amp;\\           c_1        &amp;\\           w_2(y_2,8) &amp;\\           c_2        &amp;\\[x_0 \ll x_1, y_0 \ll y_2]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T0 --&gt;|ww,wr| T1;  T0 --&gt;|ww,wr| T2;  T1 -.-&gt;|rw| T2;  T2 -.-&gt;|rw| T1;</code></pre><p>Nevertheless:</p><ul><li>PL-2+ is useful for read-only transactions and update transactions where the application programmer knows that the writes will not destroy the consistency of the database, e.g., if the updates are performed to a private part of the database.</li><li>Level PL-2+ also rules out inconsistencies due to phantom reads, since these also give rise to cycles containing one anti-dependency edge. For example, it disallows history <span class="math inline">\(H_{phantom}\)</span>.</li><li>Another advantage of PL-2+ over PL-2 is that it avoids the lost updates problem. For example, it disallows history <span class="math inline">\(H_{lost-update}\)</span>.</li><li>PL-2+ provides a notion of "causal consistency" since it ensures that a transaction is placed after all transactions that causally affect it.</li></ul><p><span class="math display">\[\begin{align*}H_{lost-update}: r_1(x_0,10) &amp;\\                 r_2(x_0,10) &amp;\\                 w_2(x_2,15) &amp;\\                 c_2         &amp;\\                 w_1(x_1,14) &amp;\\                 c_1         &amp;\\[x_0 \ll x_2 \ll x_1]\end{align*}\]</span></p><h3 id="isolation-level-pl-2l">Isolation Level PL-2L</h3><h4 id="specification-1">Specification</h4><p>A lock-based implementation of degree 2 (i.e., long write-locks and short read-locks) provides stronger guarantees than what is specified by degree 2 (READ COMMITTED). Our new isolation level, PL-2L, characterizes one such guarantee, the lock-monotonicity property.</p><p><strong>Lock-monotonicity.</strong> Suppose that an event <span class="math inline">\(r_i(x_j)\)</span> exists in a history. <strong>After</strong> this point, <span class="math inline">\(T_i\)</span> will not miss the effects of <span class="math inline">\(T_j\)</span> and all transactions that <span class="math inline">\(T_j\)</span> depends on.</p><p>This property says that a transaction observes a <strong>monotonically increasing prefix</strong> of the database history as it executes (in accordance with write/read-dependencies). For example, if <span class="math inline">\(T_i\)</span> modifies objects <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, and <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(x_i\)</span> and then <span class="math inline">\(y\)</span>, this property ensures that <span class="math inline">\(T_j\)</span> observes <span class="math inline">\(y_i\)</span> or a later version of <span class="math inline">\(y\)</span> <strong>after</strong> reading <span class="math inline">\(x_i\)</span>. However, if <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(y\)</span> before it reads <span class="math inline">\(x_i\)</span>, it could have read a version of <span class="math inline">\(y\)</span> that is older than <span class="math inline">\(y_i\)</span>. Thus, the lock-monotonicity property is <strong>weaker</strong> than the no-depends-misses property and does not guarantee that <span class="math inline">\(T_j\)</span> observes a consistent database state; recall that the no-depend-misses property ensures that <span class="math inline">\(T_j\)</span> does not miss <span class="math inline">\(T_i\)</span>'s effects irrespective of when <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(x_i\)</span>.</p><p>We use a graph called the Unfolded Serialization Graph or USG that is a variation of the DSG. The USG is specified for the transaction of interest, <span class="math inline">\(T_i\)</span>, and a history, <span class="math inline">\(H\)</span>, and is denoted by <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span>; recall that a DSG is specified over a history.</p><ul><li>For the USG, we retain all nodes and edges of the DSG except for <span class="math inline">\(T_i\)</span> and the edges incident on it.<ul><li>For each edge from node <span class="math inline">\(p\)</span> to node <span class="math inline">\(q\)</span> in <span class="math inline">\(\operatorname{DSG}(H)\)</span>, where <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are different from <span class="math inline">\(T_i\)</span>, we draw a corresponding edge in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span>.</li></ul></li><li>Instead, we split the node for <span class="math inline">\(T_i\)</span> into multiple nodes — one node for every read/write event in <span class="math inline">\(T_i\)</span>, these nodes are called read nodes and write nodes respectively.<ul><li>Any edge that was incident on <span class="math inline">\(T_i\)</span> in the DSG is now incident on the relevant event of <span class="math inline">\(T_i\)</span> in the USG, e.g.,if <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) exists in <span class="math inline">\(H\)</span>, a read-dependency edge is added from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) in the USG.</li><li>Finally, consecutive events in <span class="math inline">\(T_i\)</span> are connected by order edges, e.g., if an action (e.g., SQL statement) reads object <span class="math inline">\(y_j\)</span> and immediately follows a write on object <span class="math inline">\(x\)</span> in transaction <span class="math inline">\(T_i\)</span>, we add an order-edge from <span class="math inline">\(w_i(x_i)\)</span> to <span class="math inline">\(r_i(y_j)\)</span>. These edges are needed to maintain the order of events in a transaction; we denote such order edges between events <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> as <span class="math inline">\(p \stackrel{\text{order}}{\longrightarrow} q\)</span>.</li></ul></li></ul><p><span class="math display">\[\begin{align*}H_{non-2L}: w_1(x_1) &amp;\\            w_1(y_1) &amp;\\            c_1      &amp;\\            w_2(y_2) &amp;\\            w_2(x_2) &amp;\\            w_2(z_2) &amp;\\            r_3(x_2) &amp;\\            w_3(z_3) &amp;\\            r_3(y_1) &amp;\\            c_2      &amp;\\            c_3      &amp;\\[x_1 \ll x_2, y_1 \ll y_2, z_2 \ll z_3]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T1 --&gt;|ww| T2;  T1 --&gt;|wr| T3;  T2 --&gt;|wr,ww| T3;  T3 -.-&gt;|rw| T2;</code></pre><pre><code class=" mermaid">graph LR;  T1 --&gt;|ww| T2;  T1 --&gt;|wr| r3_y1;  T2 --&gt;|wr| r3_x2;  T2 --&gt;|ww| w3_z3;  r3_x2 --&gt;|order| w3_z3;  w3_z3 --&gt;|order| r3_y1;  r3_y1 -.-&gt;|rw| T2;</code></pre><p>Since the lock-monotonicity property is defined from the perspective of a particular transaction <span class="math inline">\(T_i\)</span> as it executes, we define PL-2L with respect to <span class="math inline">\(T_i\)</span>. Isolation Level PL-2L for transaction <span class="math inline">\(T_i\)</span> is defined such that phenomena G1 and G-monotonic are disallowed:</p><p><strong>G-monotonic: Monotonic Reads.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G-monotonic for transaction <span class="math inline">\(T_i\)</span> if there exists a cycle in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span> containing <strong>exactly one anti-dependency edge from a read node</strong> <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) to some transaction node <span class="math inline">\(T_k\)</span> (and any number of order or dependency edges).</p><p>Disallowing phenomenon G-monotonic is identical to the lock-monotonicity property given above and their equivalence can be proved in a way similar to Theorem 2+ where we showed that the no-depend-misses condition and disallowing G-single are identical.</p><p>Since PL-2L is weaker than PL-2+, it's easy to find a history that breaks G-single but doesn't break G-monotonic. Indeed, by merely changing the sequence of <span class="math inline">\(r_3(y_1)\)</span> and <span class="math inline">\(r_3(x_2)\)</span> in <span class="math inline">\(H_{non-2L}\)</span>, the resulting history <span class="math inline">\(H_{non-2L}^\prime\)</span> will not breach G-monotonic, yet it will still breach G-single.</p><p><span class="math display">\[\begin{align*}H_{non-2L}^\prime: w_1(x_1) &amp;\\                   w_1(y_1) &amp;\\                   c_1      &amp;\\                   w_2(y_2) &amp;\\                   w_2(x_2) &amp;\\                   w_2(z_2) &amp;\\                   r_3(y_1) &amp;\\                   w_3(z_3) &amp;\\                   r_3(x_2) &amp;\\                   c_2      &amp;\\                   c_3      &amp;\\[x_1 \ll x_2, y_1 \ll y_2, z_2 \ll z_3]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T1 --&gt;|ww| T2;  T1 --&gt;|wr| r3_y1;  T2 --&gt;|wr| r3_x2;  T2 --&gt;|ww| w3_z3;  r3_y1 --&gt;|order| w3_z3;  w3_z3 --&gt;|order| r3_x2;  r3_y1 -.-&gt;|rw| T2;</code></pre><h4 id="consistency-guarantees-for-predicate-based-reads-at-pl-2l">Consistency Guarantees for Predicate-based Reads at PL-2L</h4><p>To enhance the guarantees for predicate-based reads in PL-2, the author suggests introducing two phenomenons, G1-predA and G1-predB. By disallowing G1-predA, indivisibility is ensured with respect to any predicate-based write. Similarly, disallowing G1-predB guarantees indivisibility with respect to all transaction writes of a transaction. The following consistency guarantees can also be provided to such reads:</p><ul><li>If a predicate-based read observes the effects of transaction <span class="math inline">\(T_i\)</span>, it observes the complete effects of <span class="math inline">\(T_i\)</span> and all transactions that <span class="math inline">\(T_i\)</span> depends on. This guarantee is provided by level PL-2L because of the following reason.<ul><li>When a transaction <span class="math inline">\(T_i\)</span> performs a read based on a predicate <span class="math inline">\(P\)</span>, we represent this read event, <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>, in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span> by a single read node; this node captures conflicts with respect to all object versions accessed by <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>. Since G-monotonic ensures that there is no single anti-dependency cycle originating from <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>, PL-2L ensures that this event does not miss the effects of some transaction <span class="math inline">\(T_j\)</span> that it depends on, i.e., <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> observes a consistent view of the database (assuming that transactions modify the database consistently).</li><li>In the extreme case, when transaction <span class="math inline">\(T_i\)</span> contains only one action, the whole transaction observes a consistent database state, i.e., we get isolation level PL-2+.</li><li>Isolation level PL-2+ provides stronger guarantees for normal and predicate-based reads; it ensures that if a read by transaction <span class="math inline">\(T_j\)</span> observes <span class="math inline">\(T_i\)</span>'s effects, <strong>all</strong> reads by <span class="math inline">\(T_j\)</span> observe the complete effects of <span class="math inline">\(T_i\)</span> and all transactions that <span class="math inline">\(T_i\)</span> depends on.</li></ul></li><li>Each predicate-based read executes as a PL-3 transaction. While this guarantee is not provided by PL-2L by default, it can be achieved by treating each predicate-based read as a sub-transaction that requires PL-3. For a more in-depth understanding and details on this approach, refer to the original paper.</li><li>We can also provide guarantees to predicate-based writes such that the version set of such operations is consistent. For this purpose, we can treat predicate-based writes as predicate-based reads and add the corresponding edges in the USG for these operations, e.g., if transaction <span class="math inline">\(T_i\)</span> performs <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span> and <span class="math inline">\(\operatorname{Vset}(P)\)</span> contains <span class="math inline">\(x_j\)</span>, we can treat <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span> as a predicate-based read, <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>, and add a read-dependency edge from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> in the USG.</li></ul><h3 id="snapshot-isolation">Snapshot Isolation</h3><p>Snapshot Isolation was first defined in <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels, by Hal Berenson, Phil Bernstein, Jim Gray, Jim Melton, Elizabeth O'Neil and Patrick O'Neil</a>, but the definition in is both informal and operational: it comes very close to describing how an implementation would work.</p><p><strong>Snapshot Isolation.</strong> A transaction <span class="math inline">\(T_1\)</span> executing with Snapshot Isolation always reads data from a <strong>snapshot</strong> of committed data valid as of the (logical) time <span class="math inline">\(T_1\)</span> started, called the start-timestamp. (The snapshot could be at the time when <span class="math inline">\(T_1\)</span> started or some point in logical time before it.) Updates of other transactions active after <span class="math inline">\(T_1\)</span> started are not visible to <span class="math inline">\(T_1\)</span>. When <span class="math inline">\(T_1\)</span> is ready to commit, it is assigned a commit-timestamp and allowed to commit if no other concurrent transaction <span class="math inline">\(T_2\)</span> (i.e., one whose active period (start-timestamp, commit-timestamp) overlaps with that of <span class="math inline">\(T_1\)</span>) has already written data that <span class="math inline">\(T_1\)</span> intends to write; this is called the First-committer-wins rule to prevent lost updates.</p><p>Snapshot isolation offers several key features:</p><ul><li>Snapshot isolation ensures that the objects read by a transaction represent a consistent state of the data at some point in time before the transaction began.</li><li>First-committer-wins.</li><li>Imagine a two-dimensional table with time on the x-axis and objects on the y-axis. Suppose a committed transaction has an active period of t1, t2, and t3, and writes to objects x and y. This results in marking the points (t1, x), (t1, y), (t2, x), ..., (t3, y) black on the table. Snapshot isolation guarantees that no point will be marked black twice. I refer to this principle as the "<strong>no-time-objects conflicts</strong>" rule.</li></ul><h4 id="specification-2">Specification</h4><p><strong>Time-Precedes Order.</strong> The time-precedes order, <span class="math inline">\(\prec_t\)</span>, is a partial order specified for history <span class="math inline">\(H\)</span> such that:</p><ul><li><span class="math inline">\(s_i \prec_t c_i\)</span>, i.e., the start point of a transaction precedes its commit point.</li><li>for all <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, if the scheduler chooses <span class="math inline">\(T_j\)</span>'s start point after <span class="math inline">\(T_i\)</span>'s commit point, we have <span class="math inline">\(c_i \prec_t s_j\)</span>; otherwise, we have <span class="math inline">\(s_j \prec_t c_i\)</span>.</li></ul><p><strong>Concurrent Transactions.</strong> Two transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> are concurrent if <span class="math inline">\(s_i \prec_t c_j\)</span> and <span class="math inline">\(s_j \prec_t c_i\)</span>. Thus, concurrent transactions overlap; neither starts after the other one commits.</p><p>To capture the system's choice of ordering start and commit events of different transactions, we include the time-precedes order in a history (along with the version order and the partial order of events). For convenience, in our examples we will <strong>only</strong> show time-precedes constraints of the type <span class="math inline">\(c_i \prec_t s_j\)</span>; <strong>no relationship is shown for a pair of concurrent transactions</strong> <span class="math inline">\(T_a\)</span> and <span class="math inline">\(T_b\)</span>, i.e., <span class="math inline">\(s_a \prec_t c_b\)</span> and <span class="math inline">\(s_b \prec_t c_a\)</span> holds for these cases. Please notice an important point: the order of events in the history does not specify the relationship between commit and start points of transactions.</p><p><strong>Start-Depends.</strong> <span class="math inline">\(T_j\)</span> start-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(c_i \prec_t s_j\)</span>, i.e., if it starts after Ti commits.</p><p><strong>Start-ordered Serialization Graph or SSG.</strong> For a history <span class="math inline">\(H\)</span>, <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains the same nodes and edges as <span class="math inline">\(\operatorname{DSG}(H)\)</span> along with start-dependency edges.</p><p>Level PL-SI proscribes G1 and G-SI, and property G-SI consists of G-SIa and G-SIb:</p><ul><li><strong>G-SIa: Interference.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G-SIa if <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains a read/write-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span> <strong>without</strong> there also being a start-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span>.</li><li><strong>G-SIb: Missed Effects.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G-SIb if <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains a directed cycle with <strong>exactly one anti-dependency edge</strong>. G-SIb is similar to condition G-single but provides stronger guarantees because of the extra start-dependency edges in the SSG.</li></ul><p>We now show that our specification for level PL-SI is correct. A history <span class="math inline">\(H\)</span> consisting of committed transactions executes under Snapshot Isolation iff G1 and G-SI are disallowed.</p><ul><li>First, we can formally redefine Snapshot Isolation using two distinct properties, Snapshot Read and Snapshot Write. These properties, when combined, provide a complete definition of Snapshot Isolation.<ul><li><strong>Snapshot Write.</strong> If <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> are concurrent, they cannot both modify the same object. That is, if <span class="math inline">\(w_i(x_i)\)</span> and <span class="math inline">\(w_j(x_j)\)</span> both occur in history <span class="math inline">\(H\)</span>, then either <span class="math inline">\(c_i \prec_t s_j\)</span> or <span class="math inline">\(c_j \prec_t s_i\)</span>. This is the first-committer-wins property.</li><li><strong>Snapshot Read.</strong> All reads performed by a transaction <span class="math inline">\(T_i\)</span> That is, if <span class="math inline">\(r_i(x_j)\)</span> occurs in history <span class="math inline">\(H\)</span>, then:<ul><li><ol type="1"><li><span class="math inline">\(c_j \prec_t s_i\)</span>, and</li></ol></li><li><ol start="2" type="1"><li>if <span class="math inline">\(w_k(x_k)\)</span> also occurs in <span class="math inline">\(H(j \neq k)\)</span>, then either</li></ol><ul><li>(2a) <span class="math inline">\(s_i \prec_t c_k\)</span>, or</li><li>(2b) <span class="math inline">\(c_k \prec_t s_i\)</span> and <span class="math inline">\(x_k \ll x_j\)</span></li></ul></li><li>My understanding of snapshot reads is that transaction <span class="math inline">\(T_i\)</span> always reads the latest committed state of the database at a slightly earlier time, <span class="math inline">\(s_i - \delta\)</span>. Here, <span class="math inline">\(\delta\)</span> represents an extremely short duration that can often be disregarded, as it is typically less than 1 nanosecond.</li></ul></li></ul></li><li>Next, we prove that if G1 and G-SI are disallowed for history <span class="math inline">\(H\)</span>, <span class="math inline">\(H\)</span> must have executed under Snapshot Isolation.<ul><li>Suppose Snapshot Write is not satisfied. Then <span class="math inline">\(H\)</span> contains two concurrent transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that one of them, say <span class="math inline">\(T_i\)</span>, overwrites <span class="math inline">\(T_j\)</span>'s modification of some object <span class="math inline">\(x\)</span>. This implies that a write-dependency edge exists from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(T_i\)</span>, but no start-dependency edge, which violates G-SIa. Therefore, the Snapshot Write property is satisfied.</li><li>Now suppose that the Snapshot Read property is violated.<ul><li>Property G-SIa guarantees that a transaction can only observe modifications of transactions that committed before it started, this handles properties (1) and (2a) of Snapshot Read.</li><li>Now we consider the other part of Snapshot Read concerning missed updates (Snapshot Read 2b). Suppose transaction <span class="math inline">\(T_i\)</span> reads <span class="math inline">\(x\)</span> but does not observe the updates to <span class="math inline">\(x\)</span> made by transactions that committed before <span class="math inline">\(T_i\)</span> started; assume <span class="math inline">\(T_k\)</span> made the first of these updates. This means that there exists an anti-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_k\)</span>. Furthermore, since <span class="math inline">\(c_k \prec_t s_i\)</span>, there exists a start-dependency edge from <span class="math inline">\(T_k\)</span> to <span class="math inline">\(T_i\)</span>. Therefore, phenomenon G-SIb exists in the history, which is a contradiction.</li></ul></li></ul></li><li>Lastly, we prove that if a history <span class="math inline">\(H\)</span> executes under Snapshot Isolation, G1 and G-SI are disallowed.<ul><li>It is straightforward to determine that both G1a and G1b are disallowed.</li><li>Suppose G-SIa is allowed, i.e., there is a read/write-dependency from some <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span> without a corresponding start-dependency. If there is no start-dependency, <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> must be concurrent and neither a read-dependency (by Snapshot Read property) nor a write-dependency (by Snapshot Write property) can exist between <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>. So we have a contradiction and G-SIa must be disallowed.</li><li>Suppose G1c is allowed, then <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains a cycle with 0 anti-dependency edges. Let this cycle have the form <span class="math inline">\(\langle T_1, T_2, T_3, \ldots, T_n, T_1\rangle\)</span>. Under PL-SI, if there is a dependency edge (i.e., start/read/write-dependency) from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_{i+1}\)</span>, we must have <span class="math inline">\(c_i \prec_t s_{i+1} \prec_t c_{i+1}\)</span> and hence <span class="math inline">\(c_i \prec_t c_{i+1}\)</span>. Thus, we get <span class="math inline">\(c_1 \prec_t c_2 \prec_t \ldots \prec_t c_1\)</span>, which is impossible, and therefore G1c is disallowed.</li><li>Suppose G-SIb is allowed, i.e., there is a cycle with exactly one anti-dependency edge. Let this cycle have the form <span class="math inline">\(\langle T_1, T_2, T_3, \ldots, T_n, T_1\rangle\)</span>. Without loss of generality, suppose this edge is from <span class="math inline">\(T_1\)</span> to <span class="math inline">\(T_2\)</span> and the rest are dependency edges. Then we have: <span class="math inline">\(s_1 \prec_t c_2 \prec_t c_3 \prec_t \ldots \prec_t c_n \prec_t s_1\)</span>, i.e., <span class="math inline">\(s_1 \prec_t s_1\)</span>, which again is impossible, and therefore G-SIb is disallowed.<ul><li>Under PL-SI, if there is an anti-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span>, then <span class="math inline">\(s_i \prec_t c_j\)</span>. This is because an anti-dependency edge implies that <span class="math inline">\(T_i\)</span> did not see <span class="math inline">\(T_j\)</span>'s update. Therefore, we cannot have <span class="math inline">\(c_j \prec_t s_i\)</span>. By property (2) of <strong>Time-Precedes Order</strong>, we must have <span class="math inline">\(s_i \prec_t c_j\)</span>.</li><li>Under PL-SI, if there is a dependency edge (i.e., start/read/write-dependency) from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_{i+1}\)</span>, we must have <span class="math inline">\(c_i \prec_t s_{i+1} \prec_t c_{i+1}\)</span>.</li></ul></li></ul></li></ul><h4 id="discussion-1">Discussion</h4><p>Snapshot Isolation is incomparable with PL-3. It both accepts some non-serializable histories, and rejects certain serializable histories.</p><ul><li>Snapshot Isolation accepts some non-serializable histories.</li><li>Snapshot Isolation rejects certain serializable histories:<ul><li>Some serializable histories are rejected because of the Snapshot Write property. This property was introduced to rule out lost updates; however, it also prevents blind writes by concurrent transactions. (Recall that a blind write occurs when a transaction modifies an object without first reading it.) For example, <span class="math inline">\(H_{blind-nonSI}\)</span> is not permitted by Snapshot Isolation (phenomenon G-SIa occurs) but is allowed by PL-3.</li><li>The Snapshot Read property also rules out certain serializable histories. It prohibits a transaction <span class="math inline">\(T_j\)</span> from reading a modification made by a transaction <span class="math inline">\(T_i\)</span> that committed after the start point chosen for <span class="math inline">\(T_j\)</span> or from missing updates of transactions that committed before <span class="math inline">\(T_j\)</span>'s start point. <span class="math inline">\(H_{serial-nonSI}\)</span> is an example, it is serializable in the order <span class="math inline">\(T_0, T_2, T_1\)</span> but Snapshot Isolation disallows it since <span class="math inline">\(T_2\)</span> misses <span class="math inline">\(T_1\)</span>'s updates even though <span class="math inline">\(c_1 \prec_t s_2\)</span>.<ul><li>Note that the system could have chosen a different time-precedes order (e.g., in consonance with the serial order) and allowed the above history. This is similar to the case with version orders where the database system could choose a version order that allows a history to be serializable.</li></ul></li><li><strong>Real Time Guarantees.</strong> The definition of Snapshot Isolation has a notion of logical time that we have captured with the time-precedes order. If this ordering is consistent with real-time, an application can be provided useful guarantees that are not provided by PL-2+ or even PL-3.</li></ul></li></ul><p><span class="math display">\[\begin{align*}H_{blind-nonSI}: r_1(x_0) &amp;\\                 r_2(x_0) &amp;\\                 w_1(z_1) &amp;\\                 w_2(z_2) &amp;\\                 c_1      &amp;\\                 c_2      &amp;\\[z_1 \ll z_2; c_0 \prec_t s_1, c_0 \prec_t s_2]\end{align*}\]</span></p><p><span class="math display">\[\begin{align*}H_{serial-nonSI}: w_1(x_1) &amp;\\                  c_1      &amp;\\                  r_2(x_0) &amp;\\                  c_2      &amp;\\[x_0 \ll x_1; c_0 \prec_t s_1, c_1 \prec_t s_2]\end{align*}\]</span></p><h3 id="forward-consistent-view">Forward Consistent View</h3><p>We define an isolation level called Forward Consistent View or PL-FCV by precluding G1 and G-SIb. PL-FCV is strictly stronger than PL-2+ because G-SIb is strictly stronger than G-single.</p><p>In the opening of the section titled "Specifications for Intermediate Isolation Levels," the author presents a graph called "A Partial Order to Relate Various Isolation Levels." According to this graph, PL-FCV is considered weaker than PL-3, implying that all histories allowed by PL-3 should also be permitted by PL-FCV. However, I believe the author's assertion is incorrect. I identified a specific history that is permitted by PL-3 but not by PL-FCV, which contradicts the author's claim.</p><p><span class="math display">\[\begin{align*}H_{FCV-nonSer}: w_0(x_0) &amp;\\                c_0      &amp;\\                w_1(x_1) &amp;\\                c_1      &amp;\\                r_2(x_0) &amp;\\                c_2      &amp;\\[x_0 \ll x_1; c_0 \prec_t s_1, c_0 \prec_t s_2, c_1 \prec_t s_2]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T0 --&gt;|ww,s| T1;  T0 --&gt;|wr,s| T2;  T1 --&gt;|s| T2;  T2 -.-&gt;|rw| T1;</code></pre><p>The history <span class="math inline">\(H_{FCV-nonSer}\)</span> can be serialized as <span class="math inline">\(T_0, T_2, T_1\)</span>, yet it is not permitted by PL-FCV. The reason for this disallowance is related to "time": <span class="math inline">\(T_2\)</span> reads a stale version of object <span class="math inline">\(x\)</span>, specifically <span class="math inline">\(x_0\)</span>.</p><h3 id="monotonic-snapshot-reads">Monotonic Snapshot Reads</h3><h3 id="cursor-stability">Cursor Stability</h3><h3 id="update-serializability">Update Serializability</h3><p>In this section, we present an isolation level, PL-3U, for <strong>read-only transactions</strong> that is stronger than PL-2+ but weaker than serializability.</p><h4 id="specification-3">Specification</h4><p><strong>No-update-conflict-misses.</strong> If <span class="math inline">\(T_i\)</span> depends on <span class="math inline">\(T_j\)</span>, it must not miss the effects of <span class="math inline">\(T_j\)</span> and all update transactions that <span class="math inline">\(T_j\)</span> <strong>depends or anti-depends on</strong>. Note that the no-update-conflict-misses condition imposes stronger constraints than the no-depend-misses condition since it takes anti-dependencies into account as well. The no-update-conflict-misses condition is sufficient to ensure PL-3U for a transaction <span class="math inline">\(T_i\)</span> (<span class="math inline">\(T_i\)</span> could be a read-only transaction).</p><p><strong>G-update: Single Anti-Dependency Cycles with Update Transactions.</strong> A history <span class="math inline">\(H\)</span> and transaction <span class="math inline">\(T_i\)</span> show phenomenon G-update if a DSG containing all update transactions of <span class="math inline">\(H\)</span> and transaction <span class="math inline">\(T_i\)</span> contains a cycle with <strong>1 or more</strong> anti-dependency edges.</p><p>A transaction <span class="math inline">\(T_i\)</span> is provided PL-3U if phenomena G1 and G-update are disallowed; we can prove the equivalence of G-update and the no-update-conflict-misses using an argument similar to the one presented for Theorem 2+.</p><h4 id="differentiating-between-levels-pl-2-and-pl-3u">Differentiating Between Levels PL-2+ and PL-3U</h4><p>PL-2+ ensures that a transaction observes a <strong>consistent</strong> state of the database and PL-3U states that the transaction observes a <strong>serializable</strong> state of the database.</p><ul><li>In the section "Why G-single Emphasizes Exactly One Anti-dependency Edge", I mention <span class="math inline">\(H_{anti-dependency-edges}\)</span>. <span class="math inline">\(T_1\)</span> is the exactly one read transaction that commits at PL-2+ in the history. Even though the final state <span class="math inline">\(x_0, y_3\)</span> reached by serially executing a specific subset of transactions from <span class="math inline">\(H_{anti-dependency-edges}\)</span> and read by <span class="math inline">\(T_1\)</span> is not serializable, it is consistent.</li><li><span class="math inline">\(H_{non-3U}\)</span> is another history that can distinguish between PL-2+ and PL-3U. <span class="math inline">\(H_{non-3U}\)</span> depicts what occurred in a stock reporting system. We know that stock prices will not change after the stock market has closed. We assume that there is an object called <span class="math inline">\(\text{Market-status}\)</span> that indicates whether the market is open or not. Suppose there are companies <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> whose stock prices are always the same. Transactions <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span> check that the market is open and update the stock prices to be 50 and 55 respectively and transaction <span class="math inline">\(T_3\)</span> closes the market. Suppose that a read-only transaction <span class="math inline">\(T_q\)</span> reads the stock market status and the stock prices of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. PL-2+ guarantees that <span class="math inline">\(T_q\)</span> will see the same prices for <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, e.g., the two observed values will be 50 or both will be 55. However, with PL-2+, it is possible that <span class="math inline">\(T_q\)</span> observes the stock market to be closed and reads the stock prices to be 50, i.e., it observes T3's updates but misses the effects of transaction <span class="math inline">\(T_2\)</span> that <span class="math inline">\(T_3\)</span> anti-depends on; this is what happens in history <span class="math inline">\(H_{non-3U}\)</span>.</li></ul><p><span class="math display">\[\begin{align*}H_{non-3U}: r_1(M_0,Open)   &amp;\\            w_1(X_1,50)     &amp;\\            w_1(Y_1,50)     &amp;\\            c_1             &amp;\\            r_2(M_0,Open)   &amp;\\            w_2(X_2,55)     &amp;\\            w_2(Y_2,55)     &amp;\\            c_2             &amp;\\            w_3(M_3,Closed) &amp;\\            c_3             &amp;\\            r_q(M_3,Closed) &amp;\\            r_q(X_1,50)     &amp;\\            r_q(Y_1,50)     &amp;\\            c_q             &amp;\\[M_0 \ll M_3, X_1 \ll X_2, Y_1 \ll Y_2]\end{align*}\]</span></p><pre><code class=" mermaid">graph LR;  T1 --&gt;|ww| T2;  T1 -.-&gt;|rw| T3;  T1 --&gt;|wr| Tq;  T2 -.-&gt;|rw| T3;  T3 --&gt;|wr| Tq;  Tq -.-&gt;|rw| T2;</code></pre><h4 id="differentiating-between-levels-pl-3u-and-pl-3">Differentiating Between Levels PL-3U and PL-3</h4><p>Consider a variation on the above stock-market example that shows a history that executes at PL-3U but not at PL-3. Notice that we are no longer maintaining the invariant that the stock prices of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are the same.</p><p><span class="math display">\[\begin{align*}H_{3U}: r_1(M_0,Open) &amp;\\        w_1(X_1,50)   &amp;\\        w_1(Y_1,50)   &amp;\\        c_1           &amp;\\        r_4(M_0,Open) &amp;\\        w_4(X_4,70)   &amp;\\        c_4           &amp;\\        r_5(M_0,Open) &amp;\\        w_5(Y_5,75)   &amp;\\        c_5           &amp;\\        r_a(X_4,70)   &amp;\\        r_a(Y_1,50)   &amp;\\        c_a           &amp;\\        r_b(X_1,50)   &amp;\\        r_b(Y_5,75)   &amp;\\        c_b           &amp;\\[X_1 \ll X_4, Y_1 \ll Y_5]\end{align*}\]</span></p><p>Transaction <span class="math inline">\(T_a\)</span> observes the updates of <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_4\)</span> but misses <span class="math inline">\(T_5\)</span>'s effects. Transaction <span class="math inline">\(T_b\)</span> reads the updates of <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_5\)</span> but misses <span class="math inline">\(T_4\)</span>'s effects. Thus, each read-only transaction "forces" transactions <span class="math inline">\(T_4\)</span> and <span class="math inline">\(T_5\)</span> to be serialized in the opposite order to what the other transaction requires: transaction <span class="math inline">\(T_a\)</span> forces the serialization order <span class="math inline">\(\langle T_1, T_4, T_a, T_5\rangle\)</span> whereas <span class="math inline">\(T_b\)</span> forces an order where <span class="math inline">\(T_5\)</span> must be serialized before <span class="math inline">\(T_4\)</span>, e.g., <span class="math inline">\(\langle T_1, T_5, T_b , T_4\rangle\)</span>.</p><p>The DSG of history <span class="math inline">\(H_{3U}\)</span> is shown below (for simplicity, we do not show <span class="math inline">\(T_1\)</span>):</p><pre><code class=" mermaid">graph LR;  T4 --&gt;|wr| Ta;  Ta -.-&gt;|rw| T5;  T5 --&gt;|wr| Tb;  Tb -.-&gt;|rw| T4;</code></pre><p>The DSG contains a cycle but if we remove either <span class="math inline">\(T_a\)</span> or <span class="math inline">\(T_b\)</span> from the graph, the cycle no longer exists. Thus, each read-only transaction is at level PL-3U but the whole system is not serializable. If clients/entities that execute <span class="math inline">\(T_a\)</span> and <span class="math inline">\(T_b\)</span> communicate with each other, they may be confused about the relative order in which the stock prices went up. Thus, this departure from serializability matters only when clients of read-only transactions communicate with each other directly; otherwise, PL-3U is as good as serializability.</p><h3 id="intermediate-degrees-for-running-transactions">Intermediate Degrees for Running Transactions</h3><p><strong>E-single: Single Anti-dependency Cycles at Runtime.</strong> A history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span> exhibit phenomenon E-single if <span class="math inline">\(\operatorname{DTG}(H,T_i)\)</span> contains a directed cycle involving <span class="math inline">\(T_i\)</span> with exactly one anti-dependency edge.</p><p><strong>E-monotonic: Monotonic Reads at Runtime.</strong> A history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span> exhibit phenomenon E-monotonic if there is a cycle in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span> containing exactly one anti-dependency edge from a read node <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) to some transaction node <span class="math inline">\(T_k\)</span> (and any number of order or dependency edges).</p><p>In a similar manner, other levels such EPL-SI, EPL-FCV, EPL-CS, EPL-MSR and EPL-3U can be defined by extending the relevant graph and phenomena conditions.</p><h2 id="optimistic-implementations-for-client-server-systems">Optimistic Implementations for Client-Server Systems</h2><p>Our schemes have been designed for a system where database objects may be <strong>distributed over multiple servers and clients</strong> may cache some of the objects on their machines for better performance.</p><p>Further reading materials:</p><ul><li>CLOCC, Clock-based Lazy Optimistic Concurrency Control: Work well for environments where all operations are executed by clients.<ul><li><a href="https://citeseerx.ist.psu.edu/doc/10.1.1.72.8778">A. Adya. Transaction Management for Mobile Objects Using Optimistic Concurrency Control. Master’s thesis, Massachusetts Institute of Technology, Jan. 1994.</a></li><li><a href="https://users.cs.utah.edu/~stutsman/cs6963/public/papers/thor.pdf">A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks</a></li><li><a href="https://dspace.mit.edu/handle/1721.1/10762">R. Gruber. Optimism vs. Locking: A Study of Concurrency Control for Client-Server Object-Oriented Databases</a></li></ul></li><li>Weak-CLOCC: Our optimistic mechanism for providing PL-2.</li><li>AACC, Asynchronous Avoidance-based Cache Consistency: Outperform in environments where servers may perform part of the work.</li><li>Mechanisms perform well in workloads where there are hotspots.<ul><li>Field calls, <a href="https://dl.acm.org/doi/pdf/10.1145/588111.588126">A. Reuter. Concurrency on High-Traffic Data Elements</a>.</li><li>Escrow reads, <a href="https://www.cs.umb.edu/~poneil/EscrowTM.pdf">P. O'Neil. The Escrow Transactional Method</a></li></ul></li></ul><h3 id="serializability-for-committed-transactions-clocc">Serializability for Committed Transactions: CLOCC</h3><p>I aim to connect Adya's CLOCC mechanism and theoretical isolation levels framework to gain a better understanding of CLOCC and the spectrum of isolation levels in this section.</p><ul><li>The master's thesis "Transaction Management for Mobile Objects Using Optimistic Concurrency Control" by Atul Adya introduces CLOCC, an optimistic concurrency control mechanism that ensures serializability.</li><li>Adya's PhD dissertation "Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions" presents a theoretical framework for defining isolation levels.</li><li>However, these two works do not seem to have been connected well in subsequent literature.</li></ul><h4 id="the-two-phase-commit-protocol-in-thor">The Two-Phase Commit Protocol in Thor</h4><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/the-two-phase-commit-protocol-in-thor.png" alt="" /><figcaption>The two phase commit proto col in Thor</figcaption></figure><ul><li>When an application commits a transaction <span class="math inline">\(T\)</span>, the frontend sends the following information to the coordinator server:<ul><li>Read Object Set or ROS - Set of objects read by <span class="math inline">\(T\)</span>.</li><li>Modified Object Set or MOS - Set of objects modified by <span class="math inline">\(T\)</span>.</li></ul></li><li>The coordinator assigns a globally unique timestamp to <span class="math inline">\(T\)</span> and initiates the 2-phase commit protocol.<ul><li>In the first phase of the 2-phase commit protocol, the coordinator sends prepare messages to all participants. Each participant runs a serializability check and sends its vote to the coordinator. If the coordinator receives a yes vote from all participants, it decides to commit the transaction; otherwise, it aborts the transaction. It informs the frontend about the decision and the latter conveys the transaction's commit result to the application.<ul><li>Phase 1 includes two log updates to stable storage, but the optimizations suggested by Stamos can reduce this to a single log update.</li></ul></li><li>As part of the second phase, the coordinator informs the participants about the transaction's commit result. Each participant logs the coordinator's decision and sends an acknowledgement to the coordinator.</li><li>As an optimization, each participant sends invalidation messages to frontends that have cached objects modified by this transaction; these messages ask frontends to flush old copies of the modified objects from their cache. If the currently executing transaction at a frontend has read any of the objects, it is aborted. Thus, invalidation messages prevent transactions from doing wasted work.</li></ul></li><li>To make the protocol resilient to crashes, each participant must log a prepare record on stable storage before sending its vote to the coordinator. It must also log a commit record on stable storage before sending its acknowledgement message to the coordinator. Similarly, the coordinator needs to log a commit record before informing the application about the commit/abort decision.</li><li>Note that the frontend waits only while the first phase of the protocol is being executed. Thus, this phase of the commit protocol is said to have executed in the foreground. The second phase proceeds in the background, i.e., the application does not wait for this phase to be completed.</li><li>The messages and log forces involved in committing a transaction are shown above. Numbers indicate the order of messages, i.e., message <span class="math inline">\(i\)</span> precedes message <span class="math inline">\(i+1\)</span>. Messages with the same numbers can be sent in parallel. A force to the backup has a superscript <span class="math inline">\(i/j\)</span> indicating that it is done after receiving message <span class="math inline">\(i\)</span> but before sending message <span class="math inline">\(j\)</span>.</li></ul><h4 id="a-theorem-for-ros-and-mos-tests">A Theorem for ROS and MOS Tests</h4><p>In a distributed system, transactions that have accessed objects at multiple servers must be <strong>serialized in the same order</strong> at all servers, although this order may not necessarily align with the real-world sequence of events. In CLOCC, transactions are serialized in timestamp order where timestamps are taken from real clocks. When a client wants to commit transaction <span class="math inline">\(T\)</span>, it assigns a timestamp <span class="math inline">\(\operatorname{ts}(T)\)</span> that contains the client's local clock value augmented with the client's identity to make it globally unique. The timestamp of each committed transaction <span class="math inline">\(T\)</span> can be viewed as the time when <span class="math inline">\(T\)</span> executed in an equivalent serial schedule <span class="math inline">\(H\)</span>. That is, if <span class="math inline">\(T\)</span> had been executed at time <span class="math inline">\(\operatorname{ts}(T)\)</span> (instantaneously), it would have read the same values as it did while running concurrently with other transactions. The timestamp is <strong>a predictor of the commit order</strong> for validating transactions.</p><ul><li>We assume that clocks are loosely synchronized, i.e., clocks at different nodes in the network may differ by at most a small skew (say, a few tens of milliseconds). In CLOCC, loose synchronization is needed only for performance reasons and not for correctness.</li><li>We assume that server clocks never run backwards, and advance rapidly enough that each transaction can be assigned a distinct timestamp; these assumptions are easy to guarantee.</li></ul><p>The start-depends conflict from Snapshot Isolation can help in understanding Read Object Set (ROS) and Modified Object Set (MOS) tests more effectively. This is particularly useful when utilizing the Start-ordered Serialization Graph. If the timestamp of transaction <span class="math inline">\(T_i\)</span> is less than the timestamp of transaction <span class="math inline">\(T_j\)</span> (<span class="math inline">\(\operatorname{ts}(T_i) &lt; \operatorname{ts}(T_j)\)</span>), then we draw a Start-Depends edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span>, denoted as <span class="math inline">\(T_i \stackrel{s}{\longrightarrow} T_j\)</span>.</p><p>The TM maintains sufficient validation information about prepared and committed transactions by keeping the complete history of committed and prepared transactions sorted by timestamp order. For each prepared or committed transaction <span class="math inline">\(S\)</span>, it keeps an entry in the history list with the following attributes - <span class="math inline">\(\operatorname{MOS}(S)\)</span>, <span class="math inline">\(\operatorname{ROS}(S)\)</span>, <span class="math inline">\(\operatorname{ts}(S)\)</span> and a boolean that indicates whether <span class="math inline">\(S\)</span> is prepared or committed. When transaction <span class="math inline">\(T\)</span> reads object <span class="math inline">\(x\)</span>, a tuple of the form <span class="math inline">\(\langle x, \text{install_ts}\rangle\)</span> is inserted in <span class="math inline">\(\operatorname{ROS}(T)\)</span>; <span class="math inline">\(\text{install_ts}\)</span> is the timestamp of the transaction that has installed the version of <span class="math inline">\(x\)</span> read by <span class="math inline">\(T\)</span>. When <span class="math inline">\(T\)</span> modifies <span class="math inline">\(x\)</span>, a tuple of the form <span class="math inline">\(\langle x, \text{newval}\rangle\)</span> is added to <span class="math inline">\(\operatorname{MOS}(T)\)</span> where <span class="math inline">\(\text{newval}\)</span> is the modified value of <span class="math inline">\(x\)</span>.</p><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/transaction-history.png" alt="" /><figcaption>Validation using transaction history</figcaption></figure><p>Suppose transaction <span class="math inline">\(T\)</span> reaches the server for validation such that <span class="math inline">\(\operatorname{ts}(S_i) &lt; \operatorname{ts}(T) &lt; \operatorname{ts}(S_j)\)</span>. Notice that every transaction in the transaction history must be validated against <span class="math inline">\(T\)</span>, not only adjacent transactions.</p><ul><li>To simplify our algorithm, we arrange the read set to always contain the write set (no blind writes), i.e., if a transaction modifies an object but does not read it, the client enters the object in the read set anyway. As a result, we don't need to consider Direct Write-Depends, since accounting for Direct Read-Depends achieves the same effect when determining whether any cycles exist in the SSG. Thus, we need not consider the following four conflicts:<ul><li><span class="math inline">\(S_i \stackrel{ww}{\longrightarrow} T\)</span></li><li><span class="math inline">\(T \stackrel{ww}{\longrightarrow} S_i\)</span></li><li><span class="math inline">\(T \stackrel{ww}{\longrightarrow} S_j\)</span></li><li><span class="math inline">\(S_j \stackrel{ww}{\longrightarrow} T\)</span></li></ul></li><li>The following three conflicts are valid because they have the same directions as the start-dependence conflicts in the SSG.<ul><li><span class="math inline">\(S_i \stackrel{wr}{\longrightarrow} T\)</span><ul><li>However, if transaction <span class="math inline">\(S_i\)</span> is prepared but not yet committed, transaction <span class="math inline">\(T\)</span> should not read versions of objects written by <span class="math inline">\(S_i\)</span>. If <span class="math inline">\(T\)</span> reads versions of objects written by <span class="math inline">\(S_i\)</span> before <span class="math inline">\(S_i\)</span> commits, it would constitute a dirty read if the coordinator ultimately aborts <span class="math inline">\(S_i\)</span>.</li></ul></li><li><span class="math inline">\(S_i \stackrel{rw}{\longrightarrow} T\)</span></li><li><span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_j\)</span></li></ul></li><li>Since <span class="math inline">\(S_i\)</span> is prepared/committed, it could not have observed <span class="math inline">\(T\)</span>'s updates (there are no dirty reads in CLOCC). In simpler terms, <span class="math inline">\(T \stackrel{wr}{\longrightarrow} S_i\)</span> is not possible. Similarly, <span class="math inline">\(T \stackrel{wr}{\longrightarrow} S_j\)</span> is not possible.</li><li>(1) <strong>ROS test.</strong> This test validates the objects that have been read by <span class="math inline">\(T\)</span>. Let <span class="math inline">\(S_k\)</span> be the transaction from which <span class="math inline">\(T\)</span> has read <span class="math inline">\(x\)</span>, i.e., <span class="math inline">\(\operatorname{ts}(S_k)\)</span> is equal to the value of <span class="math inline">\(\text{install_ts}\)</span> in <span class="math inline">\(x\)</span>'s ROS tuple.<ul><li>(1a) If <span class="math inline">\(\operatorname{ts}(S_k) &lt; \operatorname{ts}(S_i)\)</span>, then the transaction manager (TM) verifies that <span class="math inline">\(S_i\)</span> has not modified <span class="math inline">\(x\)</span>. This rule disables <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span>.</li><li>(1b) Furthermore, the TM also verifies that <span class="math inline">\(\operatorname{ts}(T)\)</span> is greater than <span class="math inline">\(\operatorname{ts}(S_k)\)</span>. This rule disables <span class="math inline">\(S_j \stackrel{wr}{\longrightarrow} T\)</span>.</li></ul></li><li>(2) <strong>MOS test</strong>. The TM validates <span class="math inline">\(\operatorname{MOS}(T)\)</span> by verifying that <span class="math inline">\(T\)</span> has not modified any object <span class="math inline">\(y\)</span> that has been read by <span class="math inline">\(S_j\)</span>. This rule disables <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span>.</li></ul><pre><code class=" mermaid">graph LR;  Sk --&gt;|s,ww,wr| Si;  Sk --&gt;|wr| T;  Si --&gt;|s| T;  T -.-&gt;|rw| Si;</code></pre><p>SSG when condition (1a) is violated.</p><pre><code class=" mermaid">graph LR;  T --&gt;|s| Sj;  Sj --&gt;|wr| T;</code></pre><p>SSG when condition (1b) is violated.</p><pre><code class=" mermaid">graph LR;  Si --&gt;|s,ww,wr| T;  Si --&gt;|wr| Sj;  T --&gt;|s| Sj;  Sj -.-&gt;|rw| T;</code></pre><p>SSG when condition (2) is violated.</p><h4 id="improvements-to-clocc-to-truncate-the-transaction-history">Improvements to CLOCC to Truncate the Transaction History</h4><p>The last section described the validation scheme at an abstract level without considering the space or logging requirements. To cut down on space requirements, the TM needs some way of truncating the transaction history while maintaining sufficient validation information about prepared and committed transactions. <strong>Once a transaction has committed</strong>, its modifications are installed at the relevant servers. At this point, its entry can be deleted from the history list.</p><h5 id="validation-against-prepared-transactions">Validation Against Prepared Transactions</h5><p>The transaction manager validates incoming transaction <span class="math inline">\(T\)</span> against the set of prepared transactions; this is called the Validation Queue Check (VQ-check).</p><p>Since there are no dirty reads in CLOCC, then transaction <span class="math inline">\(T\)</span> will not read any versions written by prepared (but not committed) transactions. Therefore, if there is a prepared transaction <span class="math inline">\(S_i\)</span> such that <span class="math inline">\(\operatorname{ts}(S_i) &lt; \operatorname{ts}(T)\)</span> and <span class="math inline">\(T\)</span> read some objects modified by <span class="math inline">\(S_i\)</span>, then there must be <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span>, which violates (1a) in the ROS test.</p><p>In conclusion, the TM performs the ROS test for <span class="math inline">\(T\)</span> against prepared transactions that have a timestamp value less than <span class="math inline">\(\operatorname{ts}(T)\)</span>. To pass the ROS test, <span class="math inline">\(T\)</span> should not have read any object being modified by such a transaction.</p><p>Similarly, prepared transactions will not read any version written by <span class="math inline">\(T\)</span>. Therefore, if there is a transaction <span class="math inline">\(S_j\)</span> such that <span class="math inline">\(\operatorname{ts}(T) &lt; \operatorname{ts}(S_j)\)</span> and <span class="math inline">\(S_j\)</span> read some objects modified by <span class="math inline">\(T\)</span>, then there must be <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span>, which violates (2) in the MOS test.</p><p>In conclusion, to pass the MOS test, <span class="math inline">\(T\)</span> should not modify any object that has been read by a prepared transaction whose timestamp is greater than <span class="math inline">\(\operatorname{ts}(T)\)</span>.</p><ol type="1"><li>ROS test: If <span class="math inline">\(\operatorname{ts}(S) &lt; \operatorname{ts}(T)\)</span>, then <span class="math inline">\(\operatorname{MOS}(S) \cap \operatorname{ROS}(T) = \phi\)</span>.</li><li>MOS test: If <span class="math inline">\(\operatorname{ts}(S) &gt; \operatorname{ts}(T)\)</span>, then <span class="math inline">\(\operatorname{ROS}(S) \cap \operatorname{MOS}(T) = \phi\)</span>.</li></ol><h5 id="validating-the-ros-against-committed-transactions">Validating the ROS Against Committed Transactions</h5><p>Once a transaction has committed, its modifications are installed at the relevant servers. At this point, <strong>its entry can be deleted from the history list</strong>. The TM captures the ROS and MOS information of committed transactions by maintaining two attributes for each object - rstamp and version. The version field of object <span class="math inline">\(x\)</span> stores the timestamp of the transaction that has installed <span class="math inline">\(x\)</span>'s current base version.</p><p>The version field of object <span class="math inline">\(x\)</span> truncates modification history of <span class="math inline">\(x\)</span>. It only maintains the timestamp of the transaction that has installed x's current base version. As a result, the TM does not have information about older versions of <span class="math inline">\(x\)</span>; it must abort any incoming transaction that has read an older version of <span class="math inline">\(x\)</span>.</p><p>For example, there is no difference between <span class="math inline">\(H_1: w_1(x_1) c_1 w_5 (x_5) c_5\)</span> and <span class="math inline">\(H_2: w_1(x_1) c_1 w_3(x_3) c_3 w_5(x_5) c_5\)</span> when <span class="math inline">\(T_4: r_4(x_1) c_4\)</span> reaches the server in the TM's sight. This is because the version fields in the two histories of <span class="math inline">\(x\)</span> are both 5. While <span class="math inline">\(T_4\)</span> should be aborted in <span class="math inline">\(H_2\)</span> but not in <span class="math inline">\(H_1\)</span>, the TM must abort <span class="math inline">\(T_4\)</span> in both <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span>.</p><p>We call the process to validate the ROS against committed transactions the "version check." The pseudocode for the version check is shown as follows:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">% Version Check<br>for each object x in ROS(T) do<br>  if ts(T) &lt; base_version(x) or<br>     install_ts(x) != base_version(x)<br>    Abort T<br></code></pre></td></tr></table></figure><p>To perform the version check, the TM first verifies that <span class="math inline">\(T\)</span> does not read any versions from truncated transactions (otherwise the TM does not know if it is safe to commit <span class="math inline">\(T\)</span>). Then, it verifies that an incoming transaction <span class="math inline">\(T\)</span> has read the current base version (which is also the latest version of committed transactions) of each object <span class="math inline">\(x\)</span> in <span class="math inline">\(\operatorname{ROS}(T)\)</span>.</p><ul><li>The TM aborts <span class="math inline">\(T\)</span> if <code>install_ts(x) &lt; base_version(x)</code> because <span class="math inline">\(T\)</span> has not read the latest version of <span class="math inline">\(x\)</span>. This means there exists <span class="math inline">\(S_i\)</span> such that <code>ts(Si) = base_version(x) &lt; ts(T)</code> and <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span>, which violates ROS test (1a).</li><li>We use <code>install_ts(x) != base_version(x)</code> instead of <code>install_ts(x) &gt;= base_version(x)</code> because:<ul><li><span class="math inline">\(T\)</span> will not read any versions from prepared but not yet committed transactions (there are no dirty reads in CLOCC).</li><li><code>base_version(x)</code> is the latest version of x which is written by committed transactions.</li></ul></li></ul><h5 id="validating-the-mos-against-committed-transactions">Validating the MOS Against Committed Transactions</h5><p>Once a transaction has committed, its modifications are installed at the relevant servers. At this point, <strong>its entry can be deleted from the history list</strong>. The TM captures the ROS and MOS information of committed transactions by maintaining two attributes for each object - rstamp and version. The rstamp attribute denotes the highest timestamp among committed transactions that have read that object.</p><p>The rstamp field of object <span class="math inline">\(x\)</span> truncates read history of <span class="math inline">\(x\)</span>. As a result, the TM does not have information about older versions of <span class="math inline">\(x\)</span>; it must abort any incoming transaction that has written an older version of <span class="math inline">\(x\)</span>.</p><p>For example, there is no difference between <span class="math inline">\(H_1: w_2(x_2) c_2 w_5(x_5) c_5 r_6(x_5) c_6\)</span> and <span class="math inline">\(H_2: w_2(x_2) c_2 r_4(x_2) c_4 w_5(x_5) c_5 r_6(x_5) c_6\)</span> when <span class="math inline">\(T_3: w_3(x_3) c_3\)</span> reaches the server in the TM's sight. This is because the rstamp fields in the two histories of <span class="math inline">\(x\)</span> are both 5. While <span class="math inline">\(T_3\)</span> should be aborted in <span class="math inline">\(H_2\)</span> but not in <span class="math inline">\(H_1\)</span>, the TM must abort <span class="math inline">\(T_3\)</span> in both <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span>.</p><p>We call the process to validate the MOS against committed transactions the "rstamp check." The pseudocode for the rstamp check is shown as follows:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">% Rstamp Check<br>for each object x in MOS(T) do<br>  if ts(T) &lt;= rstamp(x)<br>    Abort T<br></code></pre></td></tr></table></figure><ul><li>The TM aborts <span class="math inline">\(T\)</span> if <code>ts(T) &lt; rstamp(x)</code>. Without this check, histories like <span class="math inline">\(H_2\)</span> are possible, which violates MOS test (2).</li><li>Noticeably, the version of <span class="math inline">\(x\)</span> written by <span class="math inline">\(T\)</span> (which is equal to <code>ts(T)</code>) is greater than the rstamp of <span class="math inline">\(x\)</span>.</li></ul><h4 id="improvements-to-clocc-to-reduce-space-and-logging-overheads">Improvements to CLOCC to Reduce Space and Logging Overheads</h4><h5 id="storing-an-upper-bound-on-the-read-times-of-all-objects">Storing an upper bound on the read times of all objects</h5><p>This bound is called the read watermark or <span class="math inline">\(X_r\)</span> for the server. Since the TM has lost the read information for each object, it must assume that all objects at the server were read at time <span class="math inline">\(X_r\)</span>. Thus, to ensure that an update-at-site transaction <span class="math inline">\(T\)</span> does not invalidate a read operation of a committed transaction, the TM has to verify that <span class="math inline">\(\operatorname{ts}(T)\)</span> is greater than <span class="math inline">\(X_r\)</span>. This test is called the Read-watermark Check.</p><p>However, lack of per-object information can cause spurious aborts. But we expect such aborts to be rare since loosely synchronized clocks are being used to generate timestamps; transactions reaching a server will usually have timestamp values greater than the read-watermark at that server.</p><h5 id="implementing-the-version-field">Implementing the Version Field</h5><p>Similar to the previous section, we propose using a single write-watermark <span class="math inline">\(X_w\)</span> to represent the versions of all objects and implement the Write-watermark Check.</p><p>However, it is important to note that the Version Check has two conditions: <code>ts(T) &gt;= base_version(x)</code> and <code>install_ts(x) == base_version(x)</code>. If we simplify the second condition to <code>install_ts(x) == write_watermark</code>, then all write transactions would have to be executed sequentially.</p><p>Consider the following history <span class="math inline">\(H: w_1(x_1) w_1(y_1) c_1\)</span> and two transactions <span class="math inline">\(T_3: r_3(x_1) w_3(x_3) c_3\)</span> and <span class="math inline">\(T_2: r_2(y_1) w_2(y_2) c_2\)</span>. Suppose <span class="math inline">\(T_3\)</span> and then <span class="math inline">\(T_2\)</span> arrive at the server in that order. After <span class="math inline">\(T_3\)</span> commits, <span class="math inline">\(T_2\)</span> begins processing but will abort because the write-watermark is now 3, and <code>install_ts(y)</code> is 2, which does not equal 3.</p><p>This approach would not optimistically achieve serializability. We still need a version field for each object even with the write-watermark approach, but we can use a shorter version field instead of a timestamp. Suppose that the local timestamp and server ID require <span class="math inline">\(n\)</span> and <span class="math inline">\(d\)</span> bits of storage respectively. Then, the version field has a space overhead of <span class="math inline">\(n+d\)</span> bits per object. Another way to implement this attribute is to use a <span class="math inline">\(k\)</span>-bit counter where <span class="math inline">\(k&lt;n+d\)</span>, i.e., every object update causes the version field to increment by 1. The version field implemented using a counter is also referred to as the object's version number or vnum.</p><h4 id="the-serial-validation-algorithm">The Serial Validation Algorithm</h4><p>The author is proposing two enhancements to the CLOCC database consistency method. Given this, I suggests that three tests (labeled 1a, 1b and 2) should be performed separately on committed transactions and prepared transactions. After performing the three tests on committed and prepared transactions separately, this results in six total test cases:</p><ul><li>(1a-committed) The Write-watermark Check and the Version Check ensure that transaction <span class="math inline">\(T\)</span> will always read the latest versions installed by committed transactions.</li><li>(1b-committed) The Write-watermark Check ensures that <span class="math inline">\(T\)</span>'s timestamp is later than all committed update transactions, so <span class="math inline">\(\operatorname{ts}(T)\)</span> is greater than <span class="math inline">\(\operatorname{ts}(S_k)\)</span> if <span class="math inline">\(T\)</span> reads versions of objects written by transaction <span class="math inline">\(S_k\)</span>.</li><li>(2-committed) The Read-watermark Check ensures that transaction <span class="math inline">\(T\)</span>'s timestamp is later than all committed transactions, so there does not exist any committed transaction <span class="math inline">\(S_j\)</span> whose timestamp is later than <span class="math inline">\(T\)</span> and <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span> exists.</li><li>(1a-prepared) The ROS test against prepared transactions.</li><li>(1b-prepared) Transaction <span class="math inline">\(T\)</span> will not read any versions of objects written by prepared transactions because these versions have not yet been installed.</li><li>(2-prepared) The MOS test against prepared transactions.</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs text">// T Enters Validation<br>Lock(VQ-lock)<br>  // Write-watermark Check<br>  if ts(T) &lt; Xw<br>    Ask the coordinator to retry with a timestamp greater than Xw<br>  // Read-watermark Check<br>  if ts(T) &lt; Xr and MOS(T) is not empty set<br>    // A non-read-only-at-site transaction has failed the read-watermark test.<br>    Ask the coordinator to retry with a timestamp greater than Xr<br>  // Version Check<br>  for each object x in ROS(T) do<br>    Read-lock(x)<br>      if vnum(x) != vnum(base(x))<br>        Abort T<br>    Unlock(x)<br>  // Validation Queue Check<br>    // ROS test<br>    if ts(S) &lt; ts(T) and (MOS(S) and ROS(T) have at least one element in common)<br>      Abort T<br>    // MOS test<br>    if ts(S) &gt; ts(T) and (MOS(T) and ROS(S) have at least one element in common)<br>      Ask the coordinator to raise T&#x27;s timestamp<br>  // Validation Succeeded<br>  if MOS(T) is empty set<br>    Xr = max(Xr, T.ts)<br>  else<br>    // Add T to the VQ.<br>    insert_in_queue(VQ, T)<br>Unlock(VQ-lock)<br></code></pre></td></tr></table></figure><h4 id="proposed-enhancements-to-clocc-in-the-current-thesis">Proposed Enhancements to CLOCC in the Current Thesis</h4><h5 id="providing-external-consistency">Providing External Consistency</h5><p>Suppose <span class="math inline">\(S_j\)</span> has a timestamp later than <span class="math inline">\(T\)</span>. If <span class="math inline">\(T\)</span> has read an object that <span class="math inline">\(S_j\)</span> has modified, <span class="math inline">\(T\)</span> can still be serialized. However, as discussed in <a href="https://users.cs.utah.edu/~stutsman/cs6963/public/papers/thor.pdf">A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks</a>, we abort <span class="math inline">\(T\)</span> in this case also to provide external consistency (so that transaction commit order as observed by clients is the same as the real time order).</p><p>External consistency: The serialization order is such that, if transaction <span class="math inline">\(S\)</span> committed before <span class="math inline">\(T\)</span> began (in real time), <span class="math inline">\(S\)</span> is ordered before <span class="math inline">\(T\)</span>.</p><p>Since different transactions may be timestamped at different coordinators, and clocks are only loosely synchronized, a transaction <span class="math inline">\(T\)</span> that begins after some other transaction <span class="math inline">\(S_j\)</span> committed may actually receive a timestamp that is earlier than that of <span class="math inline">\(S_j\)</span> (although this situation is very unlikely). In this case, <span class="math inline">\(T\)</span> must not be committed if it read any object that <span class="math inline">\(S_j\)</span> modified, since that would violate external consistency.</p><p>The reader may wonder why transaction <span class="math inline">\(T\)</span> could commit if it did not read any object modified by transaction <span class="math inline">\(S_j\)</span> or modify any object read by <span class="math inline">\(S_j\)</span>, even though <span class="math inline">\(S_j\)</span> has a later timestamp than <span class="math inline">\(T\)</span>. In my understanding, this is because even if the server internally ordered <span class="math inline">\(T\)</span> before <span class="math inline">\(S_j\)</span> by timestamp order, contrary to the real-time order (<span class="math inline">\(S_j\)</span> before <span class="math inline">\(T\)</span>), the clients could not conclusively prove this was the case. However, if <span class="math inline">\(T\)</span> read an older version of an object and <span class="math inline">\(S_j\)</span> modified a newer version of that same object, the clients could irrefutably prove the mistake. Since <span class="math inline">\(T\)</span> read the older version rather than the newer version written by <span class="math inline">\(S_j\)</span>, the clients could conclusively prove the server ordered <span class="math inline">\(T\)</span> before <span class="math inline">\(S_j\)</span> incorrectly, despite <span class="math inline">\(S_j\)</span> executing earlier in real time.</p><p>To guarantee external consistency, the author specifies a more stringent validation test for transactions with later timestamps than the MOS condition proposed in <a href="https://citeseerx.ist.psu.edu/doc/10.1.1.72.8778">A. Adya. Transaction Management for Mobile Objects Using Optimistic Concurrency Control. Master’s thesis, Massachusetts Institute of Technology, Jan. 1994.</a> The stricter test is:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if ts(S) &gt; ts(T) and<br>  ((MOS(T) and ROS(S) have at least one element in common) or<br>   (ROS(T) and MOS(S) have at least one element in common))<br></code></pre></td></tr></table></figure><h5 id="other-enhancements">Other Enhancements</h5><p>The author also suggests some enhancements for CLOCC, such as implementing version checks without relying on version numbers and incorporating watermark checks as an additional improvement.</p><h3 id="mechanisms-for-isolation-level-pl-2">Mechanisms for Isolation Level PL-2</h3><p>We implement a variant of CLOCC, called Weak-CLOCC, to achieve PL-2 isolation. The serial validation algorithm of Weak-CLOCC is similar to CLOCC's, except that Weak-CLOCC simply considers a PL-2 transaction's read set to be empty for validation checks.</p><p>Since PL-2 isolation prohibits Aborted Reads (G1a), Intermediate Reads (G1b), and Circular Information Flow (G1c), Weak-CLOCC does not consider anti-dependency edges when validating transactions. Therefore, Weak-CLOCC skips (1a) which disable <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span> and (2) which disable <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span>, as described in the "Theorem for ROS and MOS Tests" section. Thus, Weak-CLOCC skips (1a-committed) (2-committed) (1a-prepared) (2-prepared), as described in the "Serial Validation Algorithm" section. As a result, Weak-CLOCC does not perform the Version Check, the Read-watermark Check, the ROS test and the MOS test, only performs the Write-watermark Check. Therefore, Weak-CLOCC's validation algorithm equals PL-3's if it considers transactions' read sets to be empty.</p><h3 id="multistamp-based-mechanism-for-pl-2-and-epl-2">Multistamp-Based Mechanism for PL-2+ and EPL-2+</h3><p><a href="https://dl.acm.org/doi/pdf/10.1145/259380.259425">A. Adya and B. Liskov. Lazy Consistency Using Loosely Synchronized Clocks. In Proceedings of the ACM Symposium on Principles of Distributed Computing, pages 73–82, Santa Barbara, CA, Aug. 1997.</a> provides a more detailed description of the multistamp-based mechanism. There are several key points to note that will aid our understanding of the multistamp-based mechanism:</p><ul><li>In the section "Serializability for Committed Transactions: CLOCC", the author mentions that a transaction <span class="math inline">\(T\)</span> is assigned a timestamp by the client, and this timestamp is the same across all servers. This implies that transactions are serialized in the same order at all servers. However, in this section, each server assigns a different timestamp to incoming transactions based on its own clock. Therefore, there is no global order of transactions across servers. Consequently, we cannot use the start-depends conflict relation and the Start-ordered Serialization Graph any longer.</li><li>We assume that server clocks monotonically increase and advance sufficiently quickly to assign each transaction a unique timestamp. Therefore, the timestamp order of transactions corresponds to their arrival order at a given server (though the arrival order may differ across servers).</li><li>The author has proven that disallowing G-single schedules is equivalent to enforcing the no-depend-misses property. Unlike the use of direct serialization graphs (DSG) and start-ordered serialization graphs (SSG) to guide the implementation of serializability for committed transactions, we would not use them to implement PL-2+. Instead, we would use the no-depend-misses property to guide the implementation of PL-2+.</li></ul><h4 id="a-theorem-for-multistamp-based-mechanism">A Theorem for Multistamp-Based Mechanism</h4><p>The fundamental idea is this: if a client running transaction <span class="math inline">\(U\)</span> observes a modification made by transaction <span class="math inline">\(T\)</span>, then it must already have received all the invalidations of <span class="math inline">\(T\)</span> and any transactions <span class="math inline">\(T\)</span> depended on.</p><p>The information about invalidations is conveyed to clients using multistamps. <strong>Each committed transaction has a multistamp</strong> that indicates its invalidations and those of all transactions it depends on. A multistamp is <strong>a set of tuples</strong> <span class="math inline">\(\langle C, S, ts\rangle\)</span>; each tuple <span class="math inline">\(\langle C, S, ts\rangle\)</span> means that an invalidation was generated for client <span class="math inline">\(C\)</span> at server <span class="math inline">\(S\)</span> at time <span class="math inline">\(ts\)</span>. The timestamp <span class="math inline">\(ts\)</span> is the value of <span class="math inline">\(S\)</span>'s clock at the time it <strong>prepared</strong> a transaction that caused invalidations for <span class="math inline">\(C\)</span>.</p><h4 id="base-algorithm">Base Algorithm</h4><h5 id="processing-at-the-server">Processing at the Server</h5><p>When a client requests a page, the server responds with a fetch response containing the page with modifications from transactions, as well as the merge of the multistamps of those transactions. There is an obvious merge operation on multistamps: if two input multistamps have a tuple for the same client/server pair, the merge retains the larger timestamp value for that pair.</p><ul><li>To provide a fetch response with the multistamps of updated transactions, the server maintains a <strong>PSTAMP</strong> table that maps pages to multistamps: the multistamp of a page is the merge of the multistamps of all transactions that modified that page.</li><li>To maintain the PSTAMP table, the server also maintains a <strong>VQ</strong> that records <strong>the multistamps of committed transactions</strong>, along with information about <strong>the reads and writes of prepared and committed transactions</strong>. The VQ information is used to calculate the multistamp of prepared transactions and ultimately the PSTAMP table.</li><li>Servers store the database objects in pages on disk, objects are typically smaller than pages. Clients maintain a page cache. When a client receives an invalidation message, it discards invalid <strong>objects but not the entire page</strong>. To achieve this, the server maintains an <strong>ILIST</strong> that maps clients to invalidation information. Each element of ILIST(C) is a timestamp <span class="math inline">\(ts\)</span> and a list of object ids, indicating that these objects were invalidated for <span class="math inline">\(C\)</span> at time <span class="math inline">\(ts\)</span>.</li></ul><h6 id="commit-processing">Commit Processing</h6><p>In the <strong>prepare</strong> phase, if validation of transaction <span class="math inline">\(T\)</span> succeeds, participant <span class="math inline">\(S\)</span> computes multistamp <span class="math inline">\(m\)</span> as follows:</p><ul><li><span class="math inline">\(S\)</span> initializes <span class="math inline">\(T\)</span>'s multistamp <span class="math inline">\(m\)</span> to be empty.</li><li>If the commit of <span class="math inline">\(T\)</span> would cause invalidations for any other clients, <span class="math inline">\(S\)</span>:<ul><li>Sets <span class="math inline">\(ts\)</span> to <strong>the current time of its clock</strong>.</li><li>For each potentially invalidated client <span class="math inline">\(C\)</span> (the server maintains a per-client directory listing pages cached at each client; the directory may list pages no longer actually cached, as the server has not yet been informed they were dropped):<ul><li><span class="math inline">\(S\)</span> adds tuple <span class="math inline">\(\langle C, S, ts\rangle\)</span> to <span class="math inline">\(m\)</span>.</li><li><span class="math inline">\(S\)</span> adds <span class="math inline">\(\langle ts, \text{olist}\rangle\)</span> to the ILIST for <span class="math inline">\(C\)</span>, where <span class="math inline">\(\text{olist}\)</span> contains ids of all objects modified by <span class="math inline">\(T\)</span> that are in pages listed in <span class="math inline">\(S\)</span>'s directory for <span class="math inline">\(C\)</span>.</li></ul></li></ul></li><li>For each transaction <span class="math inline">\(U\)</span> that <span class="math inline">\(T\)</span> depends on, <span class="math inline">\(S\)</span> merges <span class="math inline">\(U\)</span>'s multistamp with <span class="math inline">\(m\)</span>. The dependencies are determined using <span class="math inline">\(S\)</span>'s VQ.</li></ul><p>Then <span class="math inline">\(S\)</span> sends <span class="math inline">\(m\)</span> in the vote message to the coordinator. If the coordinator decides to commit <span class="math inline">\(T\)</span>, it <strong>merges multistamps received from participants</strong> to obtain <span class="math inline">\(T\)</span>'s multistamp. This multistamp is sent to participants in the commit messages. The participants store it in VQ(T).mstamp. Furthermore, for each page <span class="math inline">\(P\)</span> modified by <span class="math inline">\(T\)</span>, the participant <strong>merges this multistamp into PSTAMP(P)</strong>. If the coordinator decides to abort, it sends this information to the participants. The participant then removes information about <span class="math inline">\(T\)</span> from the ILIST.</p><h6 id="fetch-processing">Fetch Processing</h6><p>The author states that when a server receives a fetch request for object <span class="math inline">\(x\)</span> on page <span class="math inline">\(P\)</span>, if there is a prepared transaction <span class="math inline">\(T_i\)</span> that modified <span class="math inline">\(x\)</span>, the server <strong>waits for <span class="math inline">\(T_i\)</span> to complete</strong> before responding. It then sends the fetch reply containing <span class="math inline">\(P\)</span> and PSTAMP(P). Waiting for <span class="math inline">\(T_i\)</span> to complete ensures that the client receives <span class="math inline">\(T_i\)</span>'s <strong>final multistamp</strong> rather than an intermediate value.</p><p>The author seems to imply that <span class="math inline">\(T_i\)</span>'s multistamp at participant server <span class="math inline">\(S\)</span> is an intermediate value before <span class="math inline">\(S\)</span> receives the multistamp sent by the coordinator and merged from all participants, which is <span class="math inline">\(T_i\)</span>'s final multistamp. However, if <span class="math inline">\(S\)</span> instead returns <span class="math inline">\(P\)</span> without <span class="math inline">\(T_i\)</span>'s modifications and PSTAMP(P) without merging <span class="math inline">\(T_i\)</span>'s multistamp, would that be a valid option?</p><h6 id="invalidations">Invalidations</h6><ul><li>The server can produce an invalidation message <strong>proactively</strong> by traversing the ILIST <strong>in timestamp order</strong> from smallest to largest, stopping either when it has processed the entire list or reaches an entry for a prepared (but uncommitted) transaction. The message contains the ids of all objects in the processed entries and the <strong>largest timestamp</strong> from those entries.</li><li>Alternatively, a client may request invalidation information by providing a timestamp <span class="math inline">\(ts\)</span>. The server responds with an invalidation message containing a timestamp <strong>greater than or equal to</strong> <span class="math inline">\(ts\)</span>.<ul><li>It is possible that some entry in the table with a timestamp less than or equal to <span class="math inline">\(ts\)</span> exists for a transaction that has not yet committed (it is still prepared); in this case, the server delays the response until the outcome for that transaction is known.</li><li>If <span class="math inline">\(ts\)</span> is greater than the timestamp of all entries in the ILIST, the server responds with its current time.</li><li>Furthermore, the server waits for its clock to advance past <span class="math inline">\(ts\)</span> if necessary. We assume server clocks monotonically increase, so no entries with timestamp less than or equal to <span class="math inline">\(ts\)</span> can be added to PSTAMP, VQ or ILIST after the clock passes <span class="math inline">\(ts\)</span>.</li></ul></li></ul><h5 id="processing-at-the-client">Processing at the Client</h5><p>A client <span class="math inline">\(C\)</span> is responsible for using multistamps to <strong>ensure that it receives invalidations</strong> before their absence could lead to the current transaction viewing an inconsistency.</p><ul><li><span class="math inline">\(C\)</span> maintains two tables that store information about servers it is connected to. LATEST(S) stores the timestamp of the latest invalidation message it has received from server <span class="math inline">\(S\)</span> and REQ(S) is the largest timestamp for <span class="math inline">\(S\)</span> that <span class="math inline">\(C\)</span> <strong>is required to hear about</strong>. If REQ(S) &gt; LATEST(S), this means <span class="math inline">\(S\)</span> has invalidations for <span class="math inline">\(C\)</span> that <span class="math inline">\(C\)</span> has not yet heard about.</li><li>The client also maintains a set CURR that identifies all servers used by the currently running transaction. For each such server <span class="math inline">\(S\)</span> in CURR, it guarantees that LATEST(S) &gt;= REQ(S). In other words, for all servers used by the current transaction, the invalidation information is <strong>as recent as is required</strong>.</li></ul><p>Client <span class="math inline">\(C\)</span> does the following when a transaction first uses object <span class="math inline">\(x\)</span>:</p><ul><li>Adds <span class="math inline">\(x\)</span>'s server <span class="math inline">\(S\)</span> to CURR.</li><li>Fetches <span class="math inline">\(x\)</span> if necessary. When the fetch reply arrives it processes the invalidations as described above. Then it updates the information in REQ to reflect the multistamp in the fetch response: for each multistamp entry <span class="math inline">\(\langle C, R, ts\rangle\)</span> such that <span class="math inline">\(ts\)</span> is larger than REQ(R), it stores <span class="math inline">\(ts\)</span> in REQ(R).</li><li>If LATEST(R) &lt; REQ(R) for some server <span class="math inline">\(R\)</span> in CURR, it sends an invalidation request to <span class="math inline">\(R\)</span> (requesting <span class="math inline">\(R\)</span> to reply with a message timestamped same as or later than REQ(R)), waits for the response, and then processes it. This results in an extra message to server <span class="math inline">\(R\)</span> and delays the current transaction, causing a <strong>consistency stall</strong>.</li></ul><p>Note that invalidation processing in steps 2 and 3 can cause the transaction to abort (if the transaction had already used an invalidated object).</p><h5 id="validation">Validation</h5><p>A transaction <span class="math inline">\(T_i\)</span>'s reads are validated by its client and its writes are checked by the servers using Weak-CLOCC.</p><ul><li>To validate <span class="math inline">\(T_i\)</span> 's reads, its client <span class="math inline">\(C\)</span> ensures that <span class="math inline">\(C\)</span> has recent-enough information about invalidations for all servers used by <span class="math inline">\(T_i\)</span>, i.e., for each server <span class="math inline">\(X\)</span> in CURR, the client checks that LATEST(X) &gt;= REQ(X). This check is called the read-dependency check. If this condition does not hold for some servers, a consistency stall occurs and the client sends an invalidation-request messages to each server <span class="math inline">\(X\)</span> where the information was not sufficiently recent. When the client receives the replies, it processes them as in CLOCC, i.e., it <strong>aborts</strong> <span class="math inline">\(T_i\)</span> if the reply indicates <span class="math inline">\(T_i\)</span> has read an obsolete object; otherwise, <span class="math inline">\(T_i\)</span> passes the read-dependency check.</li><li>If transaction <span class="math inline">\(T_i\)</span> is read-only, there is no more work to be done and the transaction <strong>commits locally at the client</strong>.</li><li>Otherwise, the client sends the read and write sets to the servers so that the Weak-CLOCC checks can be performed, and so that <span class="math inline">\(T_i\)</span>'s multistamp can be computed.</li></ul><h4 id="truncation">Truncation</h4><p>We remove "old" tuples from multistamps. To account for the removed tuples, each multistamp <span class="math inline">\(m\)</span> also contains a timestamp <span class="math inline">\(m.threshold\)</span>; <span class="math inline">\(m.threshold\)</span> is <strong>greater than or equal to</strong> timestamps of <strong>all</strong> tuples that have been removed from <span class="math inline">\(m\)</span>. The threshold allows us to compute an effective multistamp <span class="math inline">\(\operatorname{EFF}(m)\)</span> containing a tuple <span class="math inline">\(\langle C, X, ts\rangle\)</span> for <strong>every</strong> client/server pair, where <span class="math inline">\(ts\)</span> is the timestamp in the tuple for client <span class="math inline">\(C\)</span> and server <span class="math inline">\(X\)</span> in <span class="math inline">\(m\)</span> if one exists and otherwise, <span class="math inline">\(ts\)</span> is <span class="math inline">\(m.threshold\)</span>.</p><p>Suppose there are two servers, <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, and two clients, <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span>. The non-truncated multistamp <span class="math inline">\(m\)</span> of transaction <span class="math inline">\(T_i\)</span> is:</p><table><thead><tr class="header"><th style="text-align: center;">Client</th><th style="text-align: center;">Server</th><th style="text-align: center;">Ts</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">Y</td><td style="text-align: center;">3:01:17 pm</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">X</td><td style="text-align: center;">3:02:11 pm</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">X</td><td style="text-align: center;">3:02:21 pm</td></tr></tbody></table><p>Then, <span class="math inline">\(\operatorname{EFF}(m) = m\)</span>:</p><table><thead><tr class="header"><th style="text-align: center;">Client</th><th style="text-align: center;">Server</th><th style="text-align: center;">Ts</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">Y</td><td style="text-align: center;">3:01:17 pm</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">X</td><td style="text-align: center;">3:02:11 pm</td></tr><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">X</td><td style="text-align: center;">3:02:21 pm</td></tr></tbody></table><p>Suppose <span class="math inline">\(m\)</span> is truncated to obtain <span class="math inline">\(m^\prime\)</span>:</p><table><thead><tr class="header"><th style="text-align: center;">Client</th><th style="text-align: center;">Server</th><th style="text-align: center;">Ts</th><th style="text-align: center;">Threshold</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">3:02:11 pm</td></tr><tr class="even"><td style="text-align: center;">C</td><td style="text-align: center;">X</td><td style="text-align: center;">3:02:21 pm</td><td style="text-align: center;"></td></tr></tbody></table><p>Then, <span class="math inline">\(\operatorname{EFF}(m^\prime)\)</span> is:</p><table><thead><tr class="header"><th style="text-align: center;">Client</th><th style="text-align: center;">Server</th><th style="text-align: center;">Ts</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">C</td><td style="text-align: center;">Y</td><td style="text-align: center;">3:02:11 pm</td></tr><tr class="even"><td style="text-align: center;">D</td><td style="text-align: center;">Y</td><td style="text-align: center;">3:02:11 pm</td></tr><tr class="odd"><td style="text-align: center;">D</td><td style="text-align: center;">X</td><td style="text-align: center;">3:02:11 pm</td></tr><tr class="even"><td style="text-align: center;">C</td><td style="text-align: center;">X</td><td style="text-align: center;">3:02:21 pm</td></tr></tbody></table><p>We observe that for any client/server pair, the timestamp in <span class="math inline">\(\operatorname{EFF}(m^\prime)\)</span> is greater than or equal to the timestamp in <span class="math inline">\(\operatorname{EFF}(m)\)</span>, i.e. the truncated multistamp is a more conservative version of the original.</p><p>The VQ and PSTAMP tables can also be truncated in a similar manner.</p><ul><li>Whenever the multistamp of a transaction contains no tuples (i.e., it consists only of a threshold), it is dropped from the VQ. The VQ has an associated multistamp <span class="math inline">\(VQ.threshold\)</span> that is greater than or equal to the (effective) multistamps of all transactions dropped from VQ. When a server generates a transaction <span class="math inline">\(T_i\)</span>'s multistamp (<span class="math inline">\(T_i.mstamp\)</span>), it initializes <span class="math inline">\(T_i.mstamp\)</span> to be <span class="math inline">\(VQ.threshold\)</span>.</li><li>Information is dropped from PSTAMP in the same way, with information about multistamps of dropped entries merged into <span class="math inline">\(PSTAMP.threshold\)</span>.</li></ul><h4 id="offloading-multistamp-generation-to-clients">Offloading Multistamp Generation to Clients</h4><p>As mentioned in section "Commit Processing", the final multistamp of prepared transaction <span class="math inline">\(T_i\)</span> is calculated in the following ways:</p><ul><li>Each participant server <span class="math inline">\(S\)</span> generates an intermediate multistamp with <span class="math inline">\(\left\{\left\langle C, S, ts\right\rangle \right\} \cup VQ[U_1].mstamp \cup VQ[U_2].mstamp \cup \ldots\)</span> where <span class="math inline">\(C\)</span> is a client whose cached pages may be invalidated by <span class="math inline">\(T_i\)</span> and <span class="math inline">\(U_1\)</span> is a transaction that <span class="math inline">\(T_i\)</span> depends on.<ul><li>For each potentially invalidated client <span class="math inline">\(C\)</span>, <span class="math inline">\(S\)</span> adds tuple <span class="math inline">\(\langle C, S, ts\rangle\)</span> to <span class="math inline">\(m\)</span>.</li><li>For each transaction <span class="math inline">\(U\)</span> that <span class="math inline">\(T\)</span> depends on, <span class="math inline">\(S\)</span> merges <span class="math inline">\(U\)</span>'s multistamp with <span class="math inline">\(m\)</span>.</li></ul></li><li>The coordinator merges multistamps received from participants to obtain <span class="math inline">\(T_i\)</span>'s multistamp.</li></ul><p>As mentioned in the "Fetch Processing" section, servers send fetch replies containing page <span class="math inline">\(P\)</span> and its multistamp PSTAMP(P).</p><p>So we can optimize this process through the following client-merger scheme:</p><ul><li>Let clients (instead of servers) generate a portion of the intermediate multistamps. When client <span class="math inline">\(C\)</span> receives a page <span class="math inline">\(P\)</span>'s multistamp, it retains it in a <strong>CLIENTPMAP</strong> table mapping page ids to their multistamps for pages in <span class="math inline">\(C\)</span>'s cache. The CLIENTPMAP table is maintained in a manner similar to the PSTAMP table, i.e., only multistamps of recently fetched pages are kept; other multistamps are summarized using a threshold multistamp. When transaction <span class="math inline">\(T_i\)</span> ends, <span class="math inline">\(C\)</span> computes <span class="math inline">\(T_i\)</span>'s initial multistamp by merging the multistamps of pages accessed by <span class="math inline">\(T_i\)</span> and sends it to the coordinator. The initial multistamp equals the merge of <span class="math inline">\(VQ[U_1].mstamp \cup VQ[U_2].mstamp \cup \ldots\)</span> from different participants.</li><li>Each participant <span class="math inline">\(S\)</span> simply sends tuples generated due to <span class="math inline">\(T_i\)</span>'s invalidations (<span class="math inline">\(\langle C, S, ts\rangle\)</span>) in its vote to the coordinator.</li><li>The coordinator merges these tuples to obtain <span class="math inline">\(T_i\)</span>'s final multistamp.</li></ul><p>Our original approach for generating multistamps used exact write sets from the VQ and <span class="math inline">\(T_i\)</span>'s read set. However, in the client-merger scheme, <span class="math inline">\(T_i\)</span>'s initial multistamp is computed at a client <strong>based on coarse-grained information</strong>, i.e., pages accessed by <span class="math inline">\(T_i\)</span> (since the CLIENTMAP table is maintained at a page granularity). The loss of precision can result in larger multistamps, and hence, more truncation, leading to a higher number of consistency stalls. To alleviate this problem of false dependencies, ...</p><h3 id="pl-3u-mechanism-for-read-only-transactions">PL-3U Mechanism for Read-only Transactions</h3><h4 id="a-theorem-for-implementing-pl-3u">A Theorem for Implementing PL-3U</h4><p>The author has proven that disallowing G-update schedules is equivalent to enforcing the no-update-conflict-misses property. Unlike the use of direct serialization graphs (DSG) and start-ordered serialization graphs (SSG) to guide the implementation of serializability for committed transactions, we would not use them to implement PL-3U. Instead, we would use the no-update-conflict-misses property to guide the implementation of PL-3U.</p><p>Our implementation for committing a read-only transaction <span class="math inline">\(T_q\)</span> at PL-3U ensures that the no-update-conflict-misses condition is satisfied, i.e., if the client running <span class="math inline">\(T_q\)</span> observes a modification of transaction <span class="math inline">\(T_i\)</span>, it can commit <span class="math inline">\(T_q\)</span> locally only if it has received all the invalidations of <span class="math inline">\(T_i\)</span> and any update transactions that <span class="math inline">\(T_i\)</span> <strong>depends or anti-depends on</strong>. Thus, multistamps need to capture <strong>dependencies and anti-dependencies</strong>.</p><h4 id="implementing-pl-3u">Implementing PL-3U</h4><p>We make the following change to the multistamp-based scheme for PL-2+. When a transaction <span class="math inline">\(T_i\)</span> prepares at a server <span class="math inline">\(X\)</span>, the server computes the multistamp by merging the multistamps of all transactions that <span class="math inline">\(T_i\)</span> depends and anti-depends on.</p><p>If a read-only transaction <span class="math inline">\(T_q\)</span> requests level PL-3U and accesses objects from only a server <span class="math inline">\(X\)</span>, it can be committed locally regardless of the values of LATEST(X) and REQ(X) (recall that single-server transactions can be committed locally at level PL-2+ as well). In this scenario, if <span class="math inline">\(T_q\)</span> observes the effects of a transaction <span class="math inline">\(T_i\)</span> from <span class="math inline">\(X\)</span>, it will not miss the effects of any committed update transaction that <span class="math inline">\(T_i\)</span> depends or anti-depends on. The reason is that after <span class="math inline">\(T_i\)</span> prepares at <span class="math inline">\(X\)</span>, CLOCC prevents any transaction that conflicts with <span class="math inline">\(T_i\)</span> to prepare with a timestamp earlier than <span class="math inline">\(T_i\)</span>. Thus, <span class="math inline">\(T_q\)</span> can be serialized after all update transactions (such as <span class="math inline">\(T_i\)</span> ) that <span class="math inline">\(T_q\)</span> depends or anti-depends on.</p><p>As stated in the "Fetch Processing" section:</p><p>When a server receives a fetch request for object <span class="math inline">\(x\)</span> on page <span class="math inline">\(P\)</span>, if there is a prepared transaction <span class="math inline">\(T_i\)</span> that modified <span class="math inline">\(x\)</span>, the server <strong>waits for <span class="math inline">\(T_i\)</span> to complete</strong> before responding. It then sends the fetch reply containing <span class="math inline">\(P\)</span> and PSTAMP(P). Waiting for <span class="math inline">\(T_i\)</span> to complete ensures that the client receives <span class="math inline">\(T_i\)</span>'s <strong>final multistamp</strong> rather than an intermediate value.</p><p>The author also states that if a <strong>preparing</strong> transaction <span class="math inline">\(T_i\)</span> anti-depends on a prepared transaction <span class="math inline">\(T_j\)</span>, <span class="math inline">\(T_i\)</span>'s prepare is delayed until <span class="math inline">\(T_j\)</span> commits or aborts. This ensures that the server merges <span class="math inline">\(T_j\)</span>'s final multistamp into <span class="math inline">\(T_i\)</span>'s multistamp.</p><p>The author seems to imply that <span class="math inline">\(T_j\)</span>'s multistamp at server <span class="math inline">\(S\)</span> before receiving the coordinator's merged multistamp is an intermediate value. However, if <span class="math inline">\(S\)</span> instead returns PSTAMP(P), RPSTAMP(P) and ILIST(C) without merging <span class="math inline">\(T_j\)</span>'s multistamp, would that be a valid option?</p><h4 id="pl-3u-in-action-an-illustrative-example">PL-3U in Action: An Illustrative Example</h4><p>The original thesis simply distinguishes PL-3U implementation from PL-2+ implementation. However, I am unclear on how to implement a system providing PL-3 for update transactions and PL-3U for read-only transactions. I will provide more details on implementing such a mixed system.</p><p>Assume two clients, <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span>, and two servers, <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span>.</p><ul><li><span class="math inline">\(S\)</span> contains page <span class="math inline">\(P\)</span> with objects <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</li><li><span class="math inline">\(T\)</span> contains page <span class="math inline">\(Q\)</span> with object <span class="math inline">\(M\)</span>.</li></ul><p>There is a history <span class="math inline">\(H_{non-3U}\)</span> allowed by PL-2+ but not PL-3U.</p><ul><li>Transactions <span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span>, ..., <span class="math inline">\(T_5\)</span> are prepared and committed in sequential order; for example, <span class="math inline">\(T_2\)</span> is prepared after <span class="math inline">\(T_1\)</span> commits.</li><li><span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_3\)</span> and <span class="math inline">\(T_4\)</span> are performed by client <span class="math inline">\(C\)</span>.</li><li><span class="math inline">\(T_2\)</span> and <span class="math inline">\(T_5\)</span> are performed by client <span class="math inline">\(D\)</span>.</li></ul><p><span class="math inline">\(T_2\)</span> caches <span class="math inline">\(X_1\)</span> and <span class="math inline">\(Y_1\)</span>, so <span class="math inline">\(T_5\)</span> reads stale data. We analyze why <span class="math inline">\(T_5\)</span> commits in PL-2+ but aborts in PL-3U.</p><p><span class="math display">\[\begin{align*}H_{non-3U}: r_1(M_0,Open)   &amp;\\            w_1(X_1,50)     &amp;\\            w_1(Y_1,50)     &amp;\\            c_1             &amp;\\            r_2(X_1,50)     &amp;\\            r_2(Y_1,50)     &amp;\\            c_2             &amp;\\            r_3(M_0,Open)   &amp;\\            w_3(X_3,55)     &amp;\\            w_3(Y_3,55)     &amp;\\            c_3             &amp;\\            w_4(M_4,Closed) &amp;\\            c_4             &amp;\\            r_5(X_1,50)     &amp;\\            r_5(Y_1,50)     &amp;\\            r_5(M_4,Closed) &amp;\\            c_5             &amp;\\[M_0 \ll M_4, X_1 \ll X_3, Y_1 \ll Y_3]\end{align*}\]</span></p><table><thead><tr class="header"><th style="text-align: center;">T</th><th style="text-align: center;">Client C's Cached Page</th><th style="text-align: center;">Client D's Cached Page</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">T1</td><td style="text-align: center;">{P,Q}</td><td style="text-align: center;">{}</td></tr><tr class="even"><td style="text-align: center;">T2</td><td style="text-align: center;">{P,Q}</td><td style="text-align: center;">{P}</td></tr><tr class="odd"><td style="text-align: center;">T3</td><td style="text-align: center;">{P,Q}</td><td style="text-align: center;">{P}</td></tr><tr class="even"><td style="text-align: center;">T4</td><td style="text-align: center;">{P,Q}</td><td style="text-align: center;">{P}</td></tr><tr class="odd"><td style="text-align: center;">T5</td><td style="text-align: center;">{P,Q}</td><td style="text-align: center;">{P,Q}</td></tr></tbody></table><p>The following table shows the T.mstamp and PSTAMP calculations in a PL-2+ implementation:</p><table><thead><tr class="header"><th style="text-align: center;">T</th><th style="text-align: center;">T.mstamp</th><th style="text-align: center;">PSTAMP(P)</th><th style="text-align: center;">PSTAMP(Q)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">T1</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td></tr><tr class="even"><td style="text-align: center;">T2</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td></tr><tr class="odd"><td style="text-align: center;">T3</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{}</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;">{}</td></tr><tr class="odd"><td style="text-align: center;">T4</td><td style="text-align: center;">{{C,T,11:10}}</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{{C,T,11:10}}</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;"></td></tr></tbody></table><p>For PL-3U, we also need to maintain anti-dependency information for pages; for this purpose:</p><ul><li>We use a new table, <strong>RPSTAMP</strong>, which maps a page <span class="math inline">\(P\)</span> to the (merged) multistamp of all <strong>update</strong> transactions that have <strong>read</strong> <span class="math inline">\(P\)</span>.</li><li>For each page <span class="math inline">\(P\)</span> modified by <span class="math inline">\(T_i\)</span>, it merges RPSTAMP(P) into <span class="math inline">\(T_i\)</span>'s multistamp.</li></ul><p>We first calculate the RPSTAMP table for <span class="math inline">\(H_{non-3U}\)</span> from top to bottom, from left to right. For example:</p><ul><li>After <span class="math inline">\(T_1\)</span> commits:<ul><li><span class="math inline">\(T_1\)</span> does not invalidate any clients or depend on any other transactions (we do not consider <span class="math inline">\(T_0\)</span> to simplify), so its multistamp is the empty set.</li><li><span class="math inline">\(T_1\)</span> is an update transaction. It reads <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> (we assume transactions always read objects before modifying them, disallowing blind writes). Therefore, RPSTAMP(P)(T1) and RPSTAMP(Q)(T1) are merged with T1.mstamp, both resulting in the empty set.</li></ul></li><li>After <span class="math inline">\(T_2\)</span> commits:<ul><li><span class="math inline">\(T_2\)</span> does not invalidate any clients, but it depends on <span class="math inline">\(T_1\)</span>. It does not modify any objects belonging to any pages. Therefore, it should not merge any RPSTAMP items. T2.mstamp results in the empty set.</li><li><span class="math inline">\(T_2\)</span> is a read-only transaction, not an update transaction. Therefore, RPSTAMP(P)(T2) and RPSTAMP(Q)(T2) should not merge T2.mstamp. They remain the same as RPSTAMP(P)(T1) and RPSTAMP(Q)(T1), resulting in the empty set.</li></ul></li><li>After <span class="math inline">\(T_3\)</span> prepares and commits at 11:00:<ul><li><span class="math inline">\(T_3\)</span> writes to <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, invalidating clients <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> which cache page <span class="math inline">\(P\)</span> on server <span class="math inline">\(S\)</span>. Therefore, its multistamp should contain {{C,S,11:00}, {D,S,11:00}}. <span class="math inline">\(T_3\)</span> depends on <span class="math inline">\(T_1\)</span>, so it merges T1.mstamp. <span class="math inline">\(T_3\)</span> also modifies <span class="math inline">\(P\)</span>, so it merges RPSTAMP(P)(T2). After these merges, the result is {{C,S,11:00}, {D,S,11:00}}.</li><li><span class="math inline">\(T_3\)</span> is an update transaction that reads <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>. Therefore, RPSTAMP(P)(T3) merges RPSTAMP(P)(T2) and T3.mstamp, resulting in {{C,S,11:00},{D,S,11:00}}. RPSTAMP(Q)(T2) is calculated the same way as RPSTAMP(P)(T2) is calculated, resulting in {{C,S,11:00},{D,S,11:00}}.</li></ul></li><li>After <span class="math inline">\(T_4\)</span> prepares and commits at 11:10:<ul><li><span class="math inline">\(T_4\)</span> writes to <span class="math inline">\(M\)</span>, invalidating client <span class="math inline">\(C\)</span> which caches <span class="math inline">\(Q\)</span> on server <span class="math inline">\(T\)</span>. Therefore, its multistamp should contain {{C,T,11:10}}. <span class="math inline">\(T_4\)</span> does not depend on any transaction (we do not consider <span class="math inline">\(T_0\)</span> to simplify), so T4.mstamp should not merge the multistamp of any other transactions. <span class="math inline">\(T_4\)</span> is an update transaction that writes <span class="math inline">\(Q\)</span>, so T4.mstamp should merge RPSTAMP(Q)(T3), resulting in {{C,T,11:10},{C,S,11:00},{D,S,11:00}}.</li><li><span class="math inline">\(T_4\)</span> is an update transaction that reads <span class="math inline">\(Q\)</span>, so RPSTAMP(Q)(T4) should merge RPSTAMP(Q)(T3) and T4.mstamp, resulting in {{C,S,11:00},{D,S,11:00},{C,T,11:10}}.</li></ul></li></ul><table><thead><tr class="header"><th style="text-align: center;">T</th><th style="text-align: center;">T.mstamp</th><th style="text-align: center;">RPSTAMP(P)</th><th style="text-align: center;">RPSTAMP(Q)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">T1</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td></tr><tr class="even"><td style="text-align: center;">T2</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td></tr><tr class="odd"><td style="text-align: center;">T3</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{{C,S,11:00},</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;">{D,S,11:00}}</td></tr><tr class="odd"><td style="text-align: center;">T4</td><td style="text-align: center;">{{C,T,11:10},</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{{C,S,11:00},</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">{C,S,11:00},</td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;">{D,S,11:00},</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;"></td><td style="text-align: center;">{C,T,11:10}}</td></tr></tbody></table><p>We then calculate the PSTAMP table for <span class="math inline">\(H_{non-3U}\)</span> from top to bottom. For example:</p><ul><li>After transaction <span class="math inline">\(T_1\)</span> commits, page <span class="math inline">\(P\)</span> is modified by <span class="math inline">\(T_1\)</span>. PSTAMP(P)(T1) should merge T1.mtamp, resulting in an empty set.</li><li>After transaction <span class="math inline">\(T_2\)</span> commits, no pages are modified by <span class="math inline">\(T_2\)</span>. PSTAMP(P)(T2) and PSTAMP(Q)(T2) remain the same as PSTAMP(P)(T1) and PSTAMP(Q)(T2), resulting in an empty set.</li><li>After transaction <span class="math inline">\(T_3\)</span> commits, page <span class="math inline">\(P\)</span> is modified by <span class="math inline">\(T_3\)</span>. PSTAMP(P)(T3) should merge PSTAMP(P)(T2) and T3.mstamp, resulting in {{C,S,11:00},{D,S,11:00}}.</li><li>After transaction <span class="math inline">\(T_4\)</span> commits, page <span class="math inline">\(Q\)</span> is modified by <span class="math inline">\(T_4\)</span>. PSTAMP(Q)(T4) should merge PSTAMP(Q)(T3) and T4.mstamp, resulting in {{C,T,11:10},{C,S,11:00},{D,S,11:00}}.</li></ul><table><thead><tr class="header"><th style="text-align: center;">T</th><th style="text-align: center;">T.mstamp</th><th style="text-align: center;">PSTAMP(P)</th><th style="text-align: center;">PSTAMP(Q)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">T1</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td></tr><tr class="even"><td style="text-align: center;">T2</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td><td style="text-align: center;">{}</td></tr><tr class="odd"><td style="text-align: center;">T3</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{}</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;">T4</td><td style="text-align: center;">{{C,T,11:10},</td><td style="text-align: center;">{{C,S,11:00},</td><td style="text-align: center;">{{C,T,11:10},</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">{C,S,11:00},</td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;">{C,S,11:00},</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">{D,S,11:00}}</td><td style="text-align: center;"></td><td style="text-align: center;">{D,S,11:00}}</td></tr></tbody></table><p>When client <span class="math inline">\(D\)</span> running transaction <span class="math inline">\(T_5\)</span> reads object <span class="math inline">\(M\)</span> belonging to page <span class="math inline">\(Q\)</span> in server <span class="math inline">\(T\)</span>, it will receive {D,S,11:00} asking it to wait for an invalidation message from server <span class="math inline">\(S\)</span>. The invalidation message will invalidate <span class="math inline">\(X_1\)</span> and <span class="math inline">\(Y_1\)</span>. <span class="math inline">\(T_5\)</span> will abort if it has read <span class="math inline">\(X_1\)</span> and <span class="math inline">\(Y_1\)</span>. Otherwise, <span class="math inline">\(T_5\)</span> will read <span class="math inline">\(X_3\)</span> and <span class="math inline">\(Y_3\)</span>, resulting in a valid transaction.</p><h5 id="the-aim-of-importing-the-rpstamp-table">The Aim of Importing the RPSTAMP Table</h5><p>For PL-3U, the no-update-conflict-misses condition requires that if transaction <span class="math inline">\(T_q\)</span> observes a modification of transaction <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_q\)</span> can only commit if it has received all invalidations of <span class="math inline">\(T_i\)</span> and any transactions that <span class="math inline">\(T_i\)</span> anti-depends on. The straightforward way to find all transactions that <span class="math inline">\(T_i\)</span> anti-depends on is to check all objects that <span class="math inline">\(T_i\)</span> writes. For each object that <span class="math inline">\(T_i\)</span> writes, we should find which transactions have read the last version of that object. Then merge the multistamps of those transactions into Ti.mstamp. However, the straightforward way is too costly.</p><p>We can take a coarser approach to accomplish this task: Find all pages written by <span class="math inline">\(T_i\)</span> and merge all the multistamps of transactions that have read those pages. We can cache the merged result of all multistamps of transactions that have read a page as the RPSTAMP table. When calculating Ti.mstamp, we should merge RPSTAMP(P) if <span class="math inline">\(T_i\)</span> writes page <span class="math inline">\(P\)</span>.</p><p>The coarse approach is coarser because we do not consider which transactions have read <strong>the exact last versions</strong> of those objects. We simply merge all multistamps of transactions that have read the pages. By taking a coarser approach and merging the multistamps of all transactions that have read the relevant pages, we avoid the cost of pinpointing exactly which transactions read the last version of each object. However, this coarseness may introduce some imprecision.</p><p>We can use the same coarse approach to calculate T.mstamp in PL-2+. We do not need to find all transactions that <span class="math inline">\(T\)</span> depends on and merge their multistamps. We simply merge all PSTAMP(P) entries for pages that <span class="math inline">\(T\)</span> reads.</p><h5 id="will-pl-3u-fail-if-an-earlier-update-transaction-arrives">Will PL-3U Fail if an Earlier Update Transaction Arrives?</h5><p>Let's assume there exists two committed transactions, read-only transaction <span class="math inline">\(Q\)</span> and update transaction <span class="math inline">\(T\)</span>, where <span class="math inline">\(Q\)</span> depends on <span class="math inline">\(T\)</span>. If two additional transactions then arrive - <span class="math inline">\(S_i\)</span> with an earlier timestamp than <span class="math inline">\(T\)</span> and <span class="math inline">\(S_j\)</span> with a later timestamp than <span class="math inline">\(T\)</span> - will they violate the PL-3U isolation guarantee for <span class="math inline">\(Q\)</span>?</p><ul><li>Because transaction <span class="math inline">\(S_j\)</span> arrives with a timestamp later than transaction <span class="math inline">\(T\)</span>, the serializable history of these transactions would be ordered as <span class="math inline">\(T\)</span>, then <span class="math inline">\(Q\)</span>, then <span class="math inline">\(S_j\)</span>. According to the current implementation, transaction <span class="math inline">\(Q\)</span> cannot depend on <span class="math inline">\(S_j\)</span> since <span class="math inline">\(S_j\)</span> has not yet committed. Therefore, any actions taken by <span class="math inline">\(S_j\)</span> will have no effect on committed transaction <span class="math inline">\(Q\)</span>.</li><li>After <span class="math inline">\(T\)</span> prepares, CLOCC prevents any transaction that conflicts with <span class="math inline">\(T\)</span> to prepare with a timestamp earlier than <span class="math inline">\(T\)</span>.<ul><li>As discussed in the section "Providing External Consistency", if transaction <span class="math inline">\(S_i\)</span> has read an object that <span class="math inline">\(T\)</span> has modified (<span class="math inline">\(S_i \stackrel{rw}{\longrightarrow} T\)</span>), <span class="math inline">\(S_i\)</span> can still be serialized. However, to provide external consistency (ensuring that the transaction commit order observed by clients matches real-time order), we abort <span class="math inline">\(S_i\)</span> in this case. So transaction <span class="math inline">\(T\)</span> will not anti-depends on transaction <span class="math inline">\(S_i\)</span>, which has an earlier timestamp yet arrives later.</li><li>As discussed in the section "A Theorem for ROS and MOS Tests", since transaction <span class="math inline">\(T\)</span> has already committed, it could not have observed any updates from transaction <span class="math inline">\(S_i\)</span> (which arrives later). In other words, <span class="math inline">\(S_i \stackrel{wr}{\longrightarrow} T\)</span> is impossible. Stated simply, <span class="math inline">\(T\)</span> will not depend on <span class="math inline">\(S_i\)</span>.</li></ul></li></ul><h5 id="the-pl-3u-does-not-guarantee-serializability">The PL-3U Does Not Guarantee Serializability</h5><p>The author states: "The PL-3U scheme also uses arrival order, but without coordinating this order across servers. As a result, it does not provide serializability: two read-only transactions <span class="math inline">\(T_q\)</span> and <span class="math inline">\(T_r\)</span> that commit at client machines are not ordered with respect to each other."</p><p>However, I find this statement confusing. I would like to propose an alternative interpretation. As an example, consider history <span class="math inline">\(H_{3U}\)</span> mentioned in the section "Differentiating Between Levels PL-3U and PL-3". Assume <span class="math inline">\(T_4\)</span>'s timestamp is earlier than <span class="math inline">\(T_5\)</span>'s timestamp. In CLOCC, transactions are serialized in timestamp order, so <span class="math inline">\(T_4\)</span> would be serialized before <span class="math inline">\(T_5\)</span>. However, there is no direct dependency between <span class="math inline">\(T_4\)</span> and <span class="math inline">\(T_5\)</span> (<span class="math inline">\(T_4\)</span> neither depends on nor anti-depends on <span class="math inline">\(T_5\)</span>; <span class="math inline">\(T_5\)</span> neither depends on nor anti-depends on <span class="math inline">\(T_4\)</span>). From <span class="math inline">\(T_b\)</span>'s view, <span class="math inline">\(T_5\)</span> could be serialized before <span class="math inline">\(T_4\)</span> (see the DSG of <span class="math inline">\(H_{3U}\)</span>). This is why PL-3U does not provide serializability - it allows read-only transactions like <span class="math inline">\(T_b\)</span> to observe a different order than timestamp order. Although <span class="math inline">\(T_b\)</span> observes an order different from timestamp order, <span class="math inline">\(T_b\)</span> can still be positioned within the serialized order (<span class="math inline">\(\langle T_1, T_5, T_b , T_4\rangle\)</span>) of the complete history that includes all update transactions as well as <span class="math inline">\(T_b\)</span> itself (and excludes any other read-only transactions like <span class="math inline">\(T_a\)</span>).</p><h2 id="reference">Reference</h2><ul><li><p><a href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions, by Atul Adya</a></p></li><li><p><a href="https://www.oreilly.com/library/view/transaction-processing/9780080519555/">J. N. Gray and A. Reuter. Transaction Processing: Concepts and Techniques. Morgan Kaufmann Publishers Inc., 1993.</a></p></li><li><p><a href="https://courses.cs.washington.edu/courses/csep552/18wi/papers/CSE550BHG-Ch7.pdf">Concurrency Control and Recovery in Database Systems, by Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman</a></p></li><li><p><a href="https://dl.acm.org/doi/pdf/10.1145/323596.323607">W. E. Weihl. Distributed Version Management for Read-only Actions</a></p></li><li><p><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels, by Hal Berenson, Phil Bernstein, Jim Gray, Jim Melton, Elizabeth O'Neil and Patrick O'Neil</a></p></li><li><p><a href="https://citeseerx.ist.psu.edu/doc/10.1.1.72.8778">A. Adya. Transaction Management for Mobile Objects Using Optimistic Concurrency Control. Master’s thesis, Massachusetts Institute of Technology, Jan. 1994.</a></p></li><li><p><a href="https://users.cs.utah.edu/~stutsman/cs6963/public/papers/thor.pdf">A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks</a></p></li><li><p><a href="https://dspace.mit.edu/handle/1721.1/10762">R. Gruber. Optimism vs. Locking: A Study of Concurrency Control for Client-Server Object-Oriented Databases</a></p></li><li><p>Field calls, <a href="https://dl.acm.org/doi/pdf/10.1145/588111.588126">A. Reuter. Concurrency on High-Traffic Data Elements</a>.</p></li><li><p>Escrow reads, <a href="https://www.cs.umb.edu/~poneil/EscrowTM.pdf">P. O'Neil. The Escrow Transactional Method</a></p></li><li><p><a href="https://dl.acm.org/doi/pdf/10.1145/259380.259425">A. Adya and B. Liskov. Lazy Consistency Using Loosely Synchronized Clocks. In Proceedings of the ACM Symposium on Principles of Distributed Computing, pages 73–82, Santa Barbara, CA, Aug. 1997.</a></p></li><li><p><a href="https://www.fabriziomusacchio.com/blog/2021-08-10-How_to_use_LaTeX_in_Markdown/#mjx-eqn-eqtest1">Fabrizio Musacchio: How to use LaTeX in Markdown</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Serializability</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - A Critique of ANSI SQL Isolation Levels</title>
    <link href="/2023/01/05/computer-science/serializability/paper-interpretation-a-critique-of-ansi-sql-solation-levels/"/>
    <url>/2023/01/05/computer-science/serializability/paper-interpretation-a-critique-of-ansi-sql-solation-levels/</url>
    
    <content type="html"><![CDATA[<p>This article reorganizes the structure of the original paper to make it easier to understand (at least in my opinion), quotes some important content from its reference, and adds my personal understanding of some confusing details (although it may be wrong).</p><h1 id="terminology">Terminology</h1><ul><li>A <strong>transaction</strong> groups a set of actions that transform the database from one consistent state to another.</li><li>A <strong>history</strong> models the interleaved execution of a set of transactions as a linear ordering of their actions, such as Reads and Writes (i.e., inserts, updates, and deletes) of specific data items.</li><li>The actions of committed transactions in the history are represented as graph nodes. If action <code>op1</code> of transaction <code>T1</code> conflicts with and precedes action <code>op2</code> of transaction <code>T2</code> in the history, then the pair <code>&lt;op1, op2&gt;</code> becomes an edge in the <strong>dependency graph</strong>.</li><li>Two histories are equivalent if they have the same committed transactions and the same dependency graph.</li><li><strong>Phenomena</strong> are the much broader interpretations of <strong>anomalies</strong>. <strong>Anomalies</strong> are strict interpretations of <strong>phenomena</strong>.<ul><li>Let's take dirty read as an example. ANSI SQL Isolation defines dirty read as follows: Transaction <code>T1</code> modifies a data item. Another transaction <code>T2</code> then reads the data item before <code>T1</code> executes a COMMIT or ROLLBACK. If <code>T1</code> then performs a ROLLBACK, <code>T2</code> has read a data item that was never committed and so never really existed.</li><li>The board interpretation is <code>P1: w1[x]...r2[x]...((c1 or a1) and (c2 or a2) in any order)</code>, and <code>P</code> is the capital first character of the word phenomena.</li><li>The strict interpretation is <code>A1: w1[x]...r2[x]...(a1 and c2 in any order)</code>, and <code>A</code> is the capital first character of the word anomaly.</li><li><code>P1</code> is a much broader interpretation than <code>A1</code>, since it prohibits all four possible commit-abort pairs by transactions <code>T1</code> and <code>T2</code>, while <code>A1</code> only prohibits two of the four.</li></ul></li><li><strong>Predicate lock</strong> is used to resolve conflicting actions that occur on a set of data items.</li></ul><h1 id="isolation-levels-defined-by-glpt-locking-isolation-levels">Isolation Levels Defined By GLPT &amp; Locking Isolation Levels</h1><h2 id="isolation-levels-defined-by-glpt">Isolation Levels Defined By GLPT</h2><p><a href="https://web.stanford.edu/class/cs245/readings/granularity-of-locks.pdf">Granularity of Locks and Degrees of Consistency in a Shared Data Base, by J.N. Gray, R.A. Lorie, G.R. Putzolu and I.L. Traiger</a> defined Degrees of Consistency in three ways: locking, data-flow graphs, and anomalies. The anomaly definitions were too vague. The authors continue to get criticism for that aspect of the definitions in <a href="https://dl.acm.org/doi/10.5555/573304">Transaction Processing: Concepts and Technique, by Jim Gray and Andreas Reuter</a>. Only the more mathematical definitions in terms of histories and dependency graphs or locking have stood the test of time.</p><blockquote><ul><li>Definition 1 (anomalies):<ul><li>Degree 3: Transaction <code>T</code> sees degree 3 consistency if:<ul><li><code>T</code> does not overwrite dirty data of other transactions.</li><li><code>T</code> does not commit any writes until it completes all its writes (i.e. until the end of transaction).</li><li><code>T</code> does not read dirty data from other transactions.</li><li>Other transactions do not dirty any data read by <code>T</code> before <code>T</code> completes.</li></ul></li><li>Degree 2: Transaction <code>T</code> sees degree 2 consistency if:<ul><li><code>T</code> does not overwrite dirty data of other transactions.</li><li><code>T</code> does not commit any writes before EOT.</li><li><code>T</code> does not read dirty data of other transactions.</li></ul></li><li>Degree 1: Transaction <code>T</code> sees degree 1 consistency if:<ul><li><code>T</code> does not overwrite dirty data of other transactions.</li><li><code>T</code> does not commit any writes before EOT.</li></ul></li><li>Degree 0: Transaction <code>T</code> sees degree 0 consistency if:<ul><li><code>T</code> does not overwrite dirty data of other transactions.</li></ul></li></ul></li><li>Definition 2 (locking):<ul><li>Degree 3: Transaction <code>T</code> observes degree 3 lock protocol if:<ul><li><code>T</code> sets a long exclusive lock on any data it dirties.</li><li><code>T</code> sets a long share lock on any data it reads.</li></ul></li><li>Degree 2: Transaction <code>T</code> observes degree 2 lock protocol if:<ul><li><code>T</code> sets a long exclusive lock on any data it dirties.</li><li><code>T</code> sets a (possibly short) share lock on any data it reads.</li></ul></li><li>Degree 1: Transaction <code>T</code> observes degree 1 lock protocol if:<ul><li><code>T</code> sets a long exclusive lock on any data it dirties.</li></ul></li><li>Degree 0: Transaction <code>T</code> observes degree 0 lock protocol if:<ul><li><code>T</code> sets a (possibly short) exclusive lock on any data it dirties.</li></ul></li></ul></li><li>Definition 2' (locking):<ul><li>Degree 3: <code>T</code> is well formed and <code>T</code> is two phase.</li><li>Degree 2: <code>T</code> is well formed and <code>T</code> is two phase with respect to writes.</li><li>Degree 1: <code>T</code> is well formed with respect to writes and <code>T</code> is two phase with respect to writes.</li><li>Degree 0: <code>T</code> is well formed with respect to writes.</li></ul></li><li>Definition 3 (data-flow graphs):<ul><li>Suppose that transaction <code>T</code> performs action <code>a</code> on entity <code>e</code> at some step in the schedule and that transaction <code>T'</code> performs action <code>a'</code> on entity <code>e</code> at a later step in the schedule. Further suppose that <code>T</code> does not equal <code>T'</code>. Then:<ul><li><code>T &lt;&lt;&lt; T'</code><ul><li>if <code>a</code> is a write action and <code>a'</code> is a write action</li><li>or <code>a</code> is a write action and <code>a'</code> is a read action</li><li>or <code>a</code> is a read action and <code>a'</code> is a write action</li></ul></li><li><code>T &lt;&lt; T'</code><ul><li>if <code>a</code> is a write action and <code>a'</code> is a write action</li><li>or <code>a</code> is a write action and <code>a'</code> is a read action</li></ul></li><li><code>T &lt; T'</code><ul><li>if <code>a</code> is a write action and <code>a'</code> is a write action</li></ul></li></ul></li><li>Let <code>&lt;*</code> be the transitive closure of <code>&lt;</code>.</li><li>A schedule is degree 1 (2 or 3) consistent if and only if the relation <code>&lt;*</code> (<code>&lt;&lt;*</code> or <code>&lt;&lt;&lt;*</code>) is a partial order.</li></ul></li></ul></blockquote><h2 id="locking-isolation-levels">Locking Isolation Levels</h2><p>The ANSI isolation levels are related to the behavior of lock schedulers.</p><h2 id="table-2-degrees-of-consistency-and-locking-isolation-levels-defined-in-terms-of-locks">Table 2: Degrees of Consistency and Locking Isolation Levels defined in terms of locks</h2><p>Consequently, it is necessary to differentiate isolation levels defined in terms of locks from the ANSI SQL phenomenabased isolation levels. To make this distinction, the levels in Table 2 are labeled with the "Locking" prefix, as opposed to the "ANSI" prefix of Table 1.</p><table><thead><tr class="header"><th style="text-align: left;">Consistency Level = Locking Isolation Level</th><th style="text-align: left;">Read Locks on Data Items and Predicates (the same unless noted)</th><th style="text-align: left;">Write Locks on Data Items and Predicates (always the same)</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">Degree 0</td><td style="text-align: left;">none required</td><td style="text-align: left;">Well-formed Writes</td></tr><tr class="even"><td style="text-align: left;">Degree 1 = Locking READ UNCOMMITTED</td><td style="text-align: left;">none required</td><td style="text-align: left;">Well-formed Writes<br/>Long duration Write locks</td></tr><tr class="odd"><td style="text-align: left;">Degree 2 = Locking READ COMMITTED</td><td style="text-align: left;">Well-formed Reads<br/>Short duration Read locks (both)</td><td style="text-align: left;">Well-formed Writes<br/>Long duration Write locks</td></tr><tr class="even"><td style="text-align: left;">Cursor Stability</td><td style="text-align: left;">Well-formed Reads<br/>Read locks held on current of cursor<br/>Short duration Read Predicate locks</td><td style="text-align: left;">Well-formed Writes<br/>Long duration Write locks</td></tr><tr class="odd"><td style="text-align: left;">Locking REPEATABLE READ</td><td style="text-align: left;">Well-formed Reads<br/>Long duration data-item Read locks<br/>Short duration Read Predicate locks</td><td style="text-align: left;">Well-formed Writes<br/>Long duration Write locks</td></tr><tr class="even"><td style="text-align: left;">Degree 3 = Locking SERIALIZABLE</td><td style="text-align: left;">Well-formed Reads<br/>Long duration Read locks (both)</td><td style="text-align: left;">Well-formed Writes<br/>Long duration Write locks</td></tr></tbody></table><p>The fundamental serialization theorem is that well-formed two-phase locking guarantees serializability — each history arising under two-phase locking is equivalent to some serial history. Conversely, if a transaction is not well-formed or two-phased then, except in degenerate cases, non-serializable execution histories are possible [EGLT].</p><p>We say Locking SERIALIZABLE == Serializable even though it is well known that a locking scheduler does not admit all possible Serializable histories.</p><h1 id="ansi-sql-isolation-levels">ANSI SQL Isolation Levels</h1><h2 id="phenomena-anomaly">Phenomena &amp; Anomaly</h2><ul><li>Dirty Read: Transaction <code>T1</code> modifies a data item. Another transaction <code>T2</code> then reads that data item before <code>T1</code> performs a COMMIT or ROLLBACK. If <code>T1</code> then performs a ROLLBACK, <code>T2</code> has read a data item that was never committed and so never really existed.</li><li>Non-repeatable or Fuzzy Read: Transaction <code>T1</code> reads a data item. Another transaction <code>T2</code> then modifies or deletes that data item and commits. If <code>T1</code> then attempts to reread the data item, it receives a modified value or discovers that the data item has been deleted.</li><li>Phantom: Transaction <code>T1</code> reads a set of data items satisfying some <code>&lt;search condition&gt;</code>. Transaction <code>T2</code> then creates data items that satisfy <code>T1</code>'s <search condition> and commits. If <code>T1</code> then repeats its read with the same <code>&lt;search condition&gt;</code>, it gets a set of data items different from the first read.</li></ul><table><thead><tr class="header"><th>Phenomena</th><th>Histories</th></tr></thead><tbody><tr class="odd"><td>Dirty Read</td><td><code>P1: w1[x]...r2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td></tr><tr class="even"><td></td><td><code>A1: w1[x]...r2[x]...(a1 and c2 in any order)</code></td></tr><tr class="odd"><td>Non-repeatable or Fuzzy Read</td><td><code>P2: r1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td></tr><tr class="even"><td></td><td><code>A2: r1[x]...w2[x]...c2...r1[x]...c1</code></td></tr><tr class="odd"><td>Phantom</td><td><code>P3: r1[P]...w2[y in P]...((c1 or a1) and (c2 or a2) any order)</code></td></tr><tr class="even"><td></td><td><code>A3: r1[P]...w2[y in P]...c2...r1[P]...c1</code></td></tr></tbody></table><h2 id="table-1-ansi-sql-isolation-levels-defined-in-terms-of-the-three-original-phenomena">Table 1: ANSI SQL Isolation Levels Defined in terms of the Three Original Phenomena</h2><table><thead><tr class="header"><th>Isolation Level</th><th><code>P1</code> (or <code>A1</code>)<br/>Dirty Read</th><th><code>P2</code> (or <code>A2</code>)<br/>Fuzzy Read</th><th><code>P3</code> (or <code>A3</code>)<br/>Phantom</th></tr></thead><tbody><tr class="odd"><td>ANSI READ UNCOMMITTED</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr class="even"><td>ANSI READ COMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr class="odd"><td>ANSI REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr class="even"><td>ANOMALY SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><p>Disallowing the three phenomena does not imply serializability, so Table 1 calls it ANOMALY SERIALIZABLE.</p><h1 id="enhanced-ansi-sql-isolation-levels">Enhanced ANSI SQL Isolation Levels</h1><h2 id="remark-3-ansi-sql-isolation-should-be-modified-to-require-p0-for-all-isolation-levels.">Remark 3: ANSI SQL isolation should be modified to require <code>P0</code> for all isolation levels.</h2><p>Dirty Write: Transaction <code>T1</code> modifies a data item. Another transaction <code>T2</code> then further modifies that data item before <code>T1</code> performs a COMMIT or ROLLBACK. If <code>T1</code> or <code>T2</code> then performs a ROLLBACK, it is unclear what the correct data value should be. The broad interpretation of this is:</p><p><code>P0: w1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code></p><p>Why Dirty Writes are bad?</p><ul><li>They can violate database consistency. Assume there is a constraint between <code>x</code> and <code>y</code> (e.g., <code>x=y</code>), and <code>T1</code> and <code>T2</code> each maintain the consistency of the constraint if run alone. However, the constraint can easily be violated if the two transactions write <code>x</code> and <code>y</code> in different orders, which can only happen if there are Dirty writes. For example consider the history <code>w1[x]w2[x]w2[y]c2w1[y]c1</code>. <code>T1</code>'s changes to <code>y</code> and <code>T2</code>'s to <code>x</code> both "survive". If <code>T1</code> writes 1 in both <code>x</code> and <code>y</code> while <code>T2</code> writes 2, the result will be <code>x=2</code>, <code>y=1</code> violating <code>x=y</code>.</li><li>Without protection from <code>P0</code>, the system can't undo updates by restoring before images. Consider the history: <code>w1[x]w2[x]a1</code>. You don't want to undo <code>w1[x]</code> by restoring its before-image of <code>x</code>, because that would wipe out <code>w2</code>'s update. But if you don't restore its before-image, and transaction <code>T2</code> later aborts, you can't undo <code>w2[x]</code> by restoring its before-image either! (We assume that each operation remembers at most one before-image of a variable (e.g. <code>x</code>) written by another transaction.)</li></ul><p>So even the weakest locking systems hold long duration write locks. Otherwise, their recovery systems would fail. Then we get remark 3.</p><p>Remark 3: ANSI SQL isolation should be modified to require <code>P0</code> for all isolation levels.</p><h2 id="remark-4-ansi-meant-to-define-p1-p2-and-p3-instead-of-a1-a2-and-a3.">Remark 4: ANSI meant to define <code>P1</code>, <code>P2</code>, and <code>P3</code> instead of <code>A1</code>, <code>A2</code>, and <code>A3</code>.</h2><p>Remark 4. Strict interpretations <code>A1</code>, <code>A2</code>, and <code>A3</code> have unintended weaknesses. The correct interpretations are the Broad ones. We assume in what follows that ANSI meant to define <code>P1</code>, <code>P2</code>, and <code>P3</code>.</p><ul><li><code>H1: r1[x=50]w1[x=10]r2[x=10]r2[y=50]c2r1[y=50]w1[y=90]c1</code>. <code>H1</code> is non-serializable, because transaction <code>T1</code> is transferring a quantity 40 from <code>x</code> to <code>y</code>, maintaining a total balance of 100, but <code>T2</code> reads an inconsistent state where the total balance is 60. H1 does not violate any of the anomalies <code>A1</code>, <code>A2</code>, or <code>A3</code>, but violates the broad interpretation of <code>A1</code>, the phenomenon <code>P1</code>.</li><li><code>H2: r1[x=50]r2[x=50]w2[x=10]r2[y=50]w2[y=90]c2r1[y=90]c1</code>. <code>H2</code> is non-serializable, because transaction <code>T1</code> sees a total balance of 140. <code>H2</code> does not violate any of the anomalies <code>A1</code>, <code>A2</code>, or <code>A3</code>, but violates the broad interpretation of <code>A2</code>, the phenomenon <code>P2</code>.</li><li><code>H3: r1[P]w2[insert y in P]r2[z]w2[z]c2r1[z]c1</code>. Here <code>T1</code> performs a <code>&lt;search condition&gt;</code> to find the list of active employees. Then <code>T2</code> performs an insert of a new active employee and then updates <code>z</code>, the count of employees in the company. Following this, <code>T1</code> reads the count of active employees as a check and sees a discrepancy. This history is clearly not serializable, but is allowed by <code>A3</code> since no predicate is evaluated twice. Again, the Broad interpretation solves the problem.</li></ul><h2 id="table-3-enhanced-ansi-sql-isolation-levels-defined-in-terms-of-the-four-phenomena">Table 3: Enhanced ANSI SQL Isolation Levels Defined in terms of the four phenomena</h2><table><thead><tr class="header"><th>Isolation Level</th><th><code>P0</code><br/>Dirty Write</th><th><code>P1</code><br/>Dirty Read</th><th><code>P2</code><br/>Fuzzy Read</th><th><code>P3</code><br/>Phantom</th></tr></thead><tbody><tr class="odd"><td>READ UNCOMMITTED</td><td>Not Possible</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr class="even"><td>READ COMMITTED</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td><td>Possible</td></tr><tr class="odd"><td>REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr class="even"><td>SERIALIZABLE</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><h1 id="difference-between-locking-isolation-levels-and-ansi-sql-isolation-levels">Difference Between Locking Isolation Levels And ANSI SQL Isolation Levels</h1><p>Locking isolation levels are more isolated than the same-named ANSI levels. Locking READ UNCOMMITTED provides long duration write locking to avoid a phenomenon called "Dirty Writes," but ANSI SQL does not exclude this anomalous behavior other than ANSI SERIALIZABLE.</p><p>Remark 6. For single version histories, it turns out that the <code>P0</code>, <code>P1</code>, <code>P2</code>, <code>P3</code> phenomena are disguised versions of locking. Thus the <strong>enhanced</strong> ANSI SQL isolation levels of Table 3 defined by these phenomena provide the same behavior as the locking isolation levels of Table 2:</p><ul><li>Prohibiting <code>P0</code> precludes a second transaction writing an item after the first transaction has written it, equivalent to saying that long-term Write locks are held on data items (and predicates).</li><li>Prohibiting <code>P1</code> is equivalent to having well-formed reads on data items.</li><li>Prohibiting <code>P2</code> means long-term Read locks on data items.</li><li>Prohibiting <code>P3</code> means long-term Read predicate locks.</li></ul><p>And we infer that locking isolation levels are more isolated than the same-named ANSI levels in another way:</p><ul><li>Locking READ UNCOMMITTED == (ENHANCED) READ UNCOMMITTED &gt;&gt; ANSI READ UNCOMMITTED</li><li>Locking READ COMMITTED == (ENHANCED) READ COMMITTED &gt;&gt; ANSI READ COMMITTED</li><li>...</li></ul><h1 id="other-isolation-types">Other Isolation Types</h1><h2 id="cursor-stability">Cursor Stability</h2><h3 id="lost-update">Lost Update</h3><p>Lost Update: The lost update anomaly occurs when transaction <code>T1</code> reads a data item and then <code>T2</code> updates the data item (possibly based on a previous read), then <code>T1</code> (based on its earlier read value) updates the data item and commits. In terms of histories, this is:</p><p><code>P4: r1[x]...w2[x]...w1[x]...c1</code></p><p>The problem, as illustrated in history <code>H4</code>, is that even if <code>T2</code> commits, <code>T2</code>'s update will be lost.</p><p><code>H4: r1[x=100]r2[x=100]w2[x=120]c2w1[x=130]c1</code></p><h3 id="cursor-stability-1">Cursor Stability</h3><p>Cursor Stability is designed to prevent the lost update phenomenon.</p><p>This is an example of using MySQL Cursor from <a href="https://www.mysqltutorial.org/mysql-cursor/">MySQL Tutorial: MySQL Cursor</a>:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> curEmail <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> email <span class="hljs-keyword">FROM</span> employees;<br><span class="hljs-keyword">OPEN</span> curEmail;<br>getEmail: LOOP<br>  <span class="hljs-keyword">FETCH</span> curEmail <span class="hljs-keyword">INTO</span> emailAddress;<br>  IF finished <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span><br>    LEAVE getEmail;<br>  <span class="hljs-keyword">END</span> IF;<br>  <span class="hljs-comment">-- Build email list.</span><br>  <span class="hljs-keyword">SET</span> emailList <span class="hljs-operator">=</span> CONCAT(emailAddress, &quot;;&quot;, emailList);<br><span class="hljs-keyword">END</span> LOOP getEmail;<br><span class="hljs-keyword">CLOSE</span> curEmail;<br></code></pre></td></tr></table></figure><p>The Cursor Stability isolation level extends READ COMMITTED locking behavior for SQL cursors by adding a new read action for FETCH from a cursor and requiring that a lock be held on the current item of the cursor.</p><ul><li>The lock is held until the cursor moves or is closed, possibly by a commit.</li><li>Naturally, the Fetching transaction can update the row, and in that case a write lock will be held on the row until the transaction commits, even after the cursor moves on with a subsequent Fetch.</li><li>The notation is extended to include, <code>rc</code>, meaning read cursor, and <code>wc</code>, meaning write the current record of the cursor. A <code>rc1[x]</code> and a later <code>wc1[x]</code> precludes an intervening <code>w2[x]</code>.</li></ul><p><code>P4</code>, renamed <code>P4C</code>, is prevented in this case: <code>P4C: rc1[x]...w2[x]...w1[x]...c1</code>.</p><h3 id="remark-7-strength-of-cursor-stability">Remark 7: Strength of Cursor Stability</h3><p>Remark 7: READ COMMITTED &lt;&lt; Cursor Stability &lt;&lt; REPEATABLE READ</p><p>The technique of putting a cursor on an item to hold its value stable can be used for multiple items, at the cost of using multiple cursors. Thus the programmer can parlay Cursor Stability to effective Locking REPEATABLE READ isolation for any transaction accessing a small, fixed number of data items. However this method is inconvenient and not at all general. Thus there are always histories fitting the <code>P4: r1[x]...w2[x]...w1[x]...c1</code> (when the user does not access <code>x</code> carefully by Cursor and FETCH?) (and of course the more general <code>P2: r1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code>) phenomenon that are not precluded by Cursor Stability.</p><h3 id="table-4.1-enhanced-ansi-sql-isolation-levels-defined-in-terms-of-the-six-phenomena">Table 4.1: Enhanced ANSI SQL Isolation Levels Defined in terms of the six phenomena</h3><table><thead><tr class="header"><th>Isolation Level</th><th><code>P0</code><br/>Dirty Write</th><th><code>P1</code><br/>Dirty Read</th><th><code>P4C</code><br/>Cursor Lost Update</th><th><code>P4</code><br/>Lost Update</th><th><code>P2</code><br/>Fuzzy Read</th><th><code>P3</code><br/>Phantom</th></tr></thead><tbody><tr class="odd"><td>READ UNCOMMITTED<br/>== Degree 1</td><td>Not Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr class="even"><td>READ COMMITTED<br/>== Degree 2</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr class="odd"><td>Cursor Stability</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Sometimes Possible</td><td>Sometimes Possible</td><td>Possible</td></tr><tr class="even"><td>REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td></tr><tr class="odd"><td>SERIALIZABLE<br/>== Degree 3</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><p>Why use the term "<strong>Sometimes Possible</strong>" other than "<strong>Possible</strong>" to describe the relationship between <code>P4</code>/<code>P2</code> and Cursor Stability? My understanding is: Users can avoid Lost Update or Fuzzy Read by using Cursor and FETCH, but Lost Update or Fuzzy Read can still happen if users don't use Cursor and FETCH correctly.</p><h2 id="snapshot-isolation">Snapshot Isolation</h2><p>Each transaction reads data from a snapshot of the (committed) data as of the time the transaction started, called its Start-Timestamp. This time may be any time before the transaction’s first Read. The transaction's writes (updates, inserts, and deletes) will also be reflected in this snapshot, to be read again if the transaction accesses (i.e., reads or updates) the data a second time. Updates by other transactions active after the transaction Start-Timestamp are invisible to the transaction.</p><p>When the transaction <code>T1</code> is ready to commit, it gets a Commit-Timestamp, which is larger than any existing Start-Timestamp or Commit-Timestamp. The transaction successfully commits only if no other transaction <code>T2</code> with a Commit-Timestamp in <code>T1</code>'s execution interval [Start-Timestamp, Commit-Timestamp] wrote data that <code>T1</code> also wrote. Otherwise, <code>T1</code> will abort.</p><p>When <code>T1</code> commits, its changes become visible to all transactions whose Start-Timestamps are larger than <code>T1</code>'s Commit-Timestamp.</p><h3 id="how-to-analyze-the-strength-of-snapshot-isolation-map-mv-histories-to-sv-histories">How to analyze the strength of Snapshot Isolation: Map MV histories to SV histories</h3><p><a href="https://www.amazon.com/Concurrency-Control-Recovery-Database-Systems/dp/0201107155">Concurrency Control and Recovery in Database Systems, by Philip Bernstein, Vassos Hadzilacos and Nathan Goodman, Chapter 2.6: VIEW EQUIVALENCE</a> tells us:</p><blockquote><p>We want to define equivalence so that two histories are equivalent if they have the same effects. The effects of a history are the values produced by the Write operations of unaborted transactions. Since we don't know anything about the computation that each transaction performs, we don't know much about the value written by each Write. All we do know is that it is some function of the values read by each of the transaction's Reads that preceded the Write. Thus, if each transaction's Reads read the same value in two histories, then its Writes will produce the same values in both histories. From this observation and a little careful thought, we can see that (1) if each transaction reads each of its data items from the same Writes in both histories, then all Writes write the same values in both histories, and (2) if for each data item <code>x</code>, the <strong>final Write</strong> on <code>x</code> is the same in both histories, then the final value of all data items will be the same in both histories. And if all Writes write the same values in both histories and leave the database in the same final state, then the histories must be equivalent.</p><p>Two histories are view equivalent if they have the same reads-from relationships and the same final writes.</p></blockquote><p><a href="https://www.amazon.com/Concurrency-Control-Recovery-Database-Systems/dp/0201107155">Concurrency Control and Recovery in Database Systems, by Philip Bernstein, Vassos Hadzilacos and Nathan Goodman, Chapter 5: MULTIVERSION CONCURRENCY CONTROL, Analyzing Correctness</a> also tells us:</p><blockquote><p>Only a subset of serial MV histories, called 1-serial MV histories, are equivalent to serial 1V histories.</p><p>For example, <code>w0[x=x0]w0[y=y0]c0r1[x=x0]r1[y=y0]w1[x=x1]w1[y=y1]c1r2[x=x0]r2[y=y1]c2</code> is a serial MV history, but not equivalent to a serial 1V history.</p></blockquote><p>But are all (serial/non-serial) MV histories equivalent to (non-serial) 1V histories? I think the answer is yes, but how to prove it?</p><p>In <a href="">An Investigation of Transactional Isolation Levels, by P. O'Neil, E. O'Neil, H. Berenson, P.Bernstein, J. Gray and J. Melton</a>, we show that all Snapshot Isolation histories can be mapped to single-valued histories while preserving dataflow dependencies (the MV histories are said to be View Equivalent with the SV histories). For example:</p><ul><li><code>H1: r1[x=50]w1[x=10]r2[x=10]r2[y=50]c2r1[y=50]w1[y=90]c1</code> is a non-serializable history. <code>T1</code> is transferring a quantity 40 from <code>x</code> to <code>y</code>, maintaining a total balance of 100, but <code>T2</code> reads an inconsistent state where the total balance is 60.</li><li>Under Snapshot Isolation, the same sequence of actions would lead to the multi-valued history: <code>H1.SI: r1[x0=50]w1[x1=10]r2[x0=50]r2[y0=50]c2r1[y0=50]w1[y1=90]c1</code>.</li><li>The MV history <code>H1.SI</code> would map to the serializable SV history: <code>H1.SI.SV: r1[x=50]r1[y=50]r2[x=50]r2[y=50]c2w1[x=10]w1[y=90]c1</code>.</li></ul><p>Mapping of MV histories to SV histories is the only rigorous touchstone needed to place Snapshot Isolation in the Isolation Hierarchy.</p><h3 id="snapshot-isolation-is-non-serializable">Snapshot Isolation is non-serializable</h3><p><code>H5: r1[x=50]r1[y=50]r2[x=50]r2[y=50]w1[y=-40]w2[x=-40]c1c2</code></p><p><code>H5</code> is non-serializable and has the same inter-transactional dataflows as could occur under Snapshot Isolation (there is no choice of versions read by the transactions). Here we assume that each transaction that writes a new value for <code>x</code> and <code>y</code> is expected to maintain the constraint that <code>x + y</code> should be positive, and while <code>T1</code> and <code>T2</code> both act properly in isolation, the constraint fails to hold in <code>H5</code>.</p><h3 id="strength-of-snapshot-isolation">Strength of Snapshot Isolation</h3><h4 id="remark-8-read-committed-snapshot-isolation">Remark 8: READ COMMITTED &lt;&lt; Snapshot Isolation</h4><p>In Snapshot Isolation, first-committer-wins precludes <code>P0</code> (dirty writes), and the timestamp mechanism prevents <code>P1</code> (dirty reads), so Snapshot Isolation is no weaker than READ COMMITTED. In addition, <code>A5A</code> is possible under READ COMMITTED, but not under the Snapshot Isolation timestamp mechanism.</p><h4 id="remark-9-repeatable-read-snapshot-isolation">Remark 9: REPEATABLE READ &gt;&gt;&lt;&lt; Snapshot Isolation</h4><ul><li>Write Skew (<code>A5B</code>) obviously can occur in a Snapshot Isolation history (e.g., <code>H5</code>), and in the Single Valued history interpretation we've been reasoning about, forbidding <code>P2</code> also precludes <code>A5B</code>. Therefore Snapshot Isolation admits history anomalies that REPEATABLE READ does not.<ul><li><code>A5</code> (Data Item Constraint Violation): Suppose <code>C()</code> is a database constraint between two data items <code>x</code> and <code>y</code> in the database. Here are two anomalies arising from constraint violation:<ul><li><code>A5A</code> (Read Skew). Suppose transaction <code>T1</code> reads <code>x</code>, and then a second transaction <code>T2</code> updates <code>x</code> and <code>y</code> to new values and commits. If now <code>T1</code> reads <code>y</code>, it may see an inconsistent state, and therefore produce an inconsistent state as output. In terms of histories, we have the anomaly: <code>A5A: r1[x]...w2[x]...w2[y]...c2...r1[y]...(c1 or a1)</code>.</li><li><code>A5B</code> (Write Skew). Suppose <code>T1</code> reads <code>x</code> and <code>y</code>, which are consistent with <code>C()</code>, and then a <code>T2</code> reads <code>x</code> and <code>y</code>, writes <code>x</code>, and commits. Then <code>T1</code> writes <code>y</code>. If there were a constraint between <code>x</code> and <code>y</code>, it might be violated. In terms of histories, we have the anomaly: <code>A5B: r1[x]...r2[y]...w1[y]...w2[x]...(c1 and c2 occur)</code>.</li></ul></li><li>Clearly neither <code>A5A</code> nor <code>A5B</code> could arise in histories where <code>P2: r1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code> is precluded, since both <code>A5A</code> and <code>A5B</code> have <code>T2</code> write a data item that has been previously read by an uncommitted <code>T1</code>. Thus, phenomena <code>A5A</code> and <code>A5B</code> are only useful for distinguishing isolation levels that are below REPEATABLE READ in strength.</li></ul></li><li>Snapshot Isolation cannot experience the <code>A3: r1[P]...w2[y in P]...c2...r1[P]...c1</code> anomaly. A transaction reading a predicate after an update by another will always see the same old set of data items. But the REPEATABLE READ isolation level can experience <code>A3</code> anomalies. Therefore REPEATABLE READ admits history anomalies that Snapshot Isolation does not.</li></ul><h4 id="remark-10-anomaly-serializable-snapshot-isolation">Remark 10: ANOMALY SERIALIZABLE &lt;&lt; SNAPSHOT ISOLATION</h4><p>Snapshot Isolation histories preclude anomalies <code>A1</code>, <code>A2</code> and <code>A3</code>. Therefore, in the anomaly interpretation of ANOMALY SERIALIZABLE of Table 1: ANOMALY SERIALIZABLE &lt;&lt; SNAPSHOT ISOLATION.</p><h3 id="snapshot-isolations-benefits">Snapshot Isolation's benefits</h3><p>Snapshot Isolation's benefits for update transactions is still debated. It probably isn’t good for long-running update transactions competing with high-contention short transactions, since the long-running transactions are unlikely to be the first writer of everything they write, and so will probably be aborted. (e.g., Start-Timestamp-1, Start-Timestamp-2, Commit-Timestamp-2, Start-Timestamp-1).</p><h3 id="table-4.2.-enhanced-ansi-sql-isolation-levels-defined-in-terms-of-the-eight-phenomena">Table 4.2. Enhanced ANSI SQL Isolation Levels Defined in terms of the eight phenomena</h3><table><thead><tr class="header"><th>Isolation Level</th><th><code>P0</code><br/>Dirty Write</th><th><code>P1</code><br/>Dirty Read</th><th><code>P4C</code><br/>Cursor Lost Update</th><th><code>P4</code><br/>Lost Update</th><th><code>P2</code><br/>Fuzzy Read</th><th><code>P3</code><br/>Phantom</th><th><code>A5A</code><br/>Read Skew</th><th><code>A5B</code><br/>Write Skew</th></tr></thead><tbody><tr class="odd"><td>READ UNCOMMITTED<br/>== Degree 1</td><td>Not Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr class="even"><td>READ COMMITTED<br/>== Degree 2</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr class="odd"><td>Cursor Stability</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Sometimes Possible</td><td>Sometimes Possible</td><td>Possible</td><td>Possible</td><td>Sometimes Possible</td></tr><tr class="even"><td>REPEATABLE READ</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Possible</td><td>Not Possible</td><td>Not Possible</td></tr><tr class="odd"><td>Snapshot</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Sometimes Possible (Why? A3 is not possible, but P3 is possible?)</td><td>Not Possible</td><td>Possible</td></tr><tr class="even"><td>SERIALIZABLE<br/>== Degree 3</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td><td>Not Possible</td></tr></tbody></table><p>Why use the term "<strong>Sometimes Possible</strong>" other than "<strong>Possible</strong>" to describe the relationship between <code>A5B</code> and Cursor Stability? My understanding is: Snapshot Isolation rejects history <code>rc1[x]...w2[x]...w1[y]...c1</code>, so users can avoid Write Skew by using Cursor and FETCH as follows:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DECLARE</span> curX <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">FROM</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">IS</span> x;<br><span class="hljs-keyword">OPEN</span> curX;<br><span class="hljs-keyword">FETCH</span> curX <span class="hljs-keyword">INTO</span> valueX;<br><span class="hljs-keyword">Update</span> <span class="hljs-operator">&lt;</span><span class="hljs-keyword">table</span><span class="hljs-operator">&gt;</span> <span class="hljs-keyword">SET</span> <span class="hljs-keyword">value</span> <span class="hljs-operator">=</span> y<span class="hljs-string">&#x27; WHERE value IS y;</span><br><span class="hljs-string">CLOSE curX;</span><br></code></pre></td></tr></table></figure><p>But Write Skew can still happen if users don't use Cursor and FETCH correctly.</p><h2 id="other-multi-version-systems">Other Multi-Version Systems</h2><h1 id="reference">Reference</h1><ul><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels, by Hal Berenson, Phil Bernstein, Jim Gray, Jim Melton, Elizabeth O'Neil and Patrick O'Neil</a></li><li><a href="https://web.stanford.edu/class/cs245/readings/granularity-of-locks.pdf">Granularity of Locks and Degrees of Consistency in a Shared Data Base, by J.N. Gray, R.A. Lorie, G.R. Putzolu and I.L. Traiger</a></li><li><a href="https://www.amazon.com/Concurrency-Control-Recovery-Database-Systems/dp/0201107155">Concurrency Control and Recovery in Database Systems, by Philip Bernstein, Vassos Hadzilacos and Nathan Goodman</a></li><li><a href="https://dl.acm.org/doi/10.5555/573304">Transaction Processing: Concepts and Technique, by Jim Gray and Andreas Reuter</a></li><li><a href="https://www.mysqltutorial.org/mysql-cursor/">MySQL Tutorial: MySQL Cursor</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Serializability</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Callback To C++20 Coroutine</title>
    <link href="/2023/01/03/computer-science/programming-language/c++/callback-to-c-20-coroutine/"/>
    <url>/2023/01/03/computer-science/programming-language/c++/callback-to-c-20-coroutine/</url>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ -std=c++20 -fcoroutines -ggdb -O0 main.cc -o main.o</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thirdFunc</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">const</span> std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span> j)&gt;&amp; callback)</span> </span>&#123;<br>  <span class="hljs-built_in">callback</span>(i + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">thirdFunc2Co</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">awaiter</span> : std::suspend_always &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">awaiter</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>: i_(i), j_(<span class="hljs-number">0</span>) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">await_suspend</span><span class="hljs-params">(std::coroutine_handle&lt;&gt; handle)</span> </span>&#123;<br>      <span class="hljs-built_in">thirdFunc</span>(i_, [<span class="hljs-keyword">this</span>, handle](<span class="hljs-type">int</span> j) &#123; j_ = j; <span class="hljs-built_in">handle</span>(); &#125;);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">await_resume</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> j_; &#125;<br>    <span class="hljs-type">int</span> i_, j_;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">awaiter</span>(i);<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ReturnObject</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span> &#123;<br>    <span class="hljs-function">ReturnObject <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        .h_ = std::coroutine_handle&lt;promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-function">std::suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>    <span class="hljs-function">std::suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span> </span>&#123;<br>      value_ = value;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span> </span>&#123;<br>      value_ = value;<br>    &#125;<br>    <span class="hljs-function">std::suspend_always <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_;<br>  &#125;;<br>  std::coroutine_handle&lt;promise_type&gt; h_;<br>&#125;;<br><br><span class="hljs-function">ReturnObject <span class="hljs-title">counter</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> j = <span class="hljs-keyword">co_await</span> <span class="hljs-built_in">thirdFunc2Co</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">co_return</span> j;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> h = <span class="hljs-built_in">counter</span>().h_;<br>  <span class="hljs-keyword">auto</span>&amp; promise = h.<span class="hljs-built_in">promise</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  h.<span class="hljs-built_in">destroy</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><ul><li><a href="https://stackoverflow.com/questions/64270626/turning-a-function-call-which-takes-a-callback-into-a-coroutine">Stack Overflow: Turning a function call which takes a callback into a coroutine</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Paper Interpretation - The Part-Time Parliament</title>
    <link href="/2022/10/05/computer-science/consensus/paper-interpretation-the-part-time-parliament/"/>
    <url>/2022/10/05/computer-science/consensus/paper-interpretation-the-part-time-parliament/</url>
    
    <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2><p>Honestly, it took me at least a year to develop a solid understanding of the Paxos consensus algorithm. As the authors of <a href="https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf">Raft: In Search of an Understandable Consensus Algorithm</a> wrote:</p><blockquote><p>We struggled with Paxos ourselves; we were not able to understand the complete protocol until after reading several simplified explanations and designing our own alternative protocol, a process that took almost a year.</p></blockquote><h2 id="the-problem">The Problem</h2><h3 id="requirements">Requirements</h3><ul><li>The first requirement of the parliamentary protocol was the <strong>consistency</strong> of ledgers, meaning that no two ledgers could contain contradictory information. If legislator <span class="math inline">\(\Phi \iota \sigma \partial \epsilon \rho\)</span> had the entry 132: Lamps must use only olive oil, then no other legislator's ledger could have a different entry for decree 132.</li><li>Progress condition: If a <strong>majority</strong> of the legislators were in the Chamber and no one entered or left the Chamber for a <strong>sufficiently long</strong> period of time then any decree proposed by a legislator in the Chamber would be passed, and every decree that had been passed would appear in the ledger of every legislator in the Chamber.</li></ul><h3 id="assumptions">Assumptions</h3><ul><li>Each legislator received a <strong>sturdy ledger</strong> in which to record the decrees, a pen, and a supply of <strong>indelible ink</strong>.</li><li>A legislator would write other notes on a slip of <strong>paper</strong>, which he might (or might not) lose if he left the Chamber.</li><li>Achieving the progress condition required that legislators be able to measure the passage of time, so they were given simple hourglass <strong>timers</strong>.</li><li>A messenger could be counted on not to garble messages, but he might forget that he had already delivered a message, and <strong>deliver it again</strong>. A messenger might leave the Chamber to conduct some business—perhaps taking a six-month voyage—before delivering a message. He might even leave forever, in which case the message would <strong>never be delivered</strong>.</li></ul><h2 id="the-single-decree-synod">The Single-Decree Synod</h2><p>Let us consider a simple consensus algorithm named Synod, a precursor to the Parliament protocol. The protocol’s requirements and assumptions were essentially the same as those of the later Parliament except that instead of containing a sequence of decrees, a ledger would have at most one decree. The Synod targets priests, not legislators, as its users.</p><p>Mathematicians derived the Synod protocol in a series of steps:</p><ul><li>First, they proved results showing that a protocol satisfying certain constraints would guarantee consistency and <strong>allow</strong> progress (not deadlock). A preliminary protocol was then derived directly from these constraints.</li><li>A restricted version of the preliminary protocol provided the basic protocol that guaranteed consistency, but <strong>not progress</strong>.</li><li>The complete Synod protocol, <strong>satisfying the consistency and progress requirements</strong>, was obtained by restricting the basic protocol.</li></ul><h3 id="mathematical-results">Mathematical Results</h3><p>The Synod’s decree was chosen through a series of numbered <strong>ballots</strong>, where a ballot was a referendum on a single decree. Formally, a ballot <span class="math inline">\(B\)</span> consisted of the following four components:</p><ul><li><span class="math inline">\(B_{dec}\)</span>: A decree (the one being voted on).</li><li><span class="math inline">\(B_{qrm}\)</span>: A nonempty set of priests (the ballot's quorum).</li><li><span class="math inline">\(B_{vot}\)</span>: A set of priests (the ones who cast votes for the decree).</li><li><span class="math inline">\(B_{bal}\)</span>: A ballot number.</li></ul><p>A ballot succeeded iff (if and only if) <strong>every</strong> priest in the quorum voted for the decree. A ballot <span class="math inline">\(B\)</span> was said to be <strong>successful</strong> iff $<span class="math inline">\(B_{qrm} \subseteq B_{vot}\)</span>, so a successful ballot was one in which every quorum member voted.</p><p>Paxon mathematicians defined three conditions on a set <span class="math inline">\(\mathcal{B}\)</span> of ballots, and then showed that consistency was guaranteed and progress was possible if the set of ballots that had taken place satisfied those conditions:</p><ul><li><span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span>: Each ballot in <span class="math inline">\(\mathcal{B}\)</span> has a unique ballot number.</li><li><span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span>: The quorums of <strong>any two</strong> ballots in <span class="math inline">\(\mathcal{B}\)</span> have <strong>at least one</strong> priest in common.</li><li><span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span>: For every ballot <span class="math inline">\(B\)</span> in <span class="math inline">\(\mathcal{B}\)</span>, if any priest in <span class="math inline">\(B\)</span>'s quorum <strong>voted in an earlier ballot</strong> in <span class="math inline">\(\mathcal{B}\)</span>, then the decree of <span class="math inline">\(B\)</span> equals the decree of the latest of those earlier ballots.<ul><li>Ballot numbers were chosen from an unbounded ordered set of numbers. If <span class="math inline">\(B_{bal}^{\prime} &gt; B_{bal}\)</span>, then ballot <span class="math inline">\(B_{bal}^{\prime}\)</span> was said to be later than ballot <span class="math inline">\(B\)</span>.</li><li>However, this indicated <strong>nothing</strong> about the order in which ballots were conducted; a later ballot could actually have taken place before an earlier one.</li></ul></li></ul><p>Let us illustrates condition <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> with a set <span class="math inline">\(\mathcal{B}\)</span> of five ballots for a Synod consisting of the five priests <span class="math inline">\(\mathrm{A}, \mathrm{B}, \Gamma, \Delta, \mathrm{E}\)</span>. This set <span class="math inline">\(\mathcal{B}\)</span> contains five ballots. For each ballot and priest, I mark Q if the priest is in the quorum, and QV if the priest votes, since voting implies quorum membership.</p><table><thead><tr class="header"><th style="text-align: left;">Ballot Number</th><th style="text-align: center;">Decree</th><th style="text-align: center;"><span class="math inline">\(\mathrm{A}\)</span></th><th style="text-align: center;"><span class="math inline">\(\mathrm{B}\)</span></th><th style="text-align: center;"><span class="math inline">\(\Gamma\)</span></th><th style="text-align: center;"><span class="math inline">\(\Delta\)</span></th><th style="text-align: center;"><span class="math inline">\(\mathrm{E}\)</span></th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">2</td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;">Q</td><td style="text-align: center;">Q</td><td style="text-align: center;">Q</td><td style="text-align: center;">QV</td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: left;">5</td><td style="text-align: center;"><span class="math inline">\(\beta\)</span></td><td style="text-align: center;">Q</td><td style="text-align: center;">Q</td><td style="text-align: center;">QV</td><td style="text-align: center;"></td><td style="text-align: center;">Q</td></tr><tr class="odd"><td style="text-align: left;">14</td><td style="text-align: center;"><span class="math inline">\(\alpha\)</span></td><td style="text-align: center;"></td><td style="text-align: center;">QV</td><td style="text-align: center;"></td><td style="text-align: center;">Q</td><td style="text-align: center;">QV</td></tr><tr class="even"><td style="text-align: left;">27</td><td style="text-align: center;"><span class="math inline">\(\beta\)</span></td><td style="text-align: center;">QV</td><td style="text-align: center;"></td><td style="text-align: center;">QV</td><td style="text-align: center;">QV</td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: left;">29</td><td style="text-align: center;"><span class="math inline">\(\beta\)</span></td><td style="text-align: center;"></td><td style="text-align: center;">QV</td><td style="text-align: center;">Q</td><td style="text-align: center;">Q</td><td style="text-align: center;"></td></tr></tbody></table><ul><li>Ballot number 2 is the earliest ballot, so the condition on that ballot is trivially true.</li><li>None of ballot 5's four quorum members <strong>voted</strong> in an earlier ballot, so the condition on ballot 5 is also trivially true.</li><li>The only member of ballot 14's quorum to vote in an earlier ballot is <span class="math inline">\(\Delta\)</span>, who <strong>voted</strong> in ballot number 2, so the condition requires that ballot 14's decree must equal ballot 2's decree.</li><li>(This is a successful ballot.) The members of ballot 27's quorum are <span class="math inline">\(\mathrm{A}\)</span>, <span class="math inline">\(\Gamma\)</span>, and <span class="math inline">\(\Delta\)</span>. Priest <span class="math inline">\(\mathrm{A}\)</span> did not vote in an earlier ballot, the only earlier ballot <span class="math inline">\(\Gamma\)</span> <strong>voted</strong> in was ballot 5, and the only earlier ballot <span class="math inline">\(\Delta\)</span> <strong>voted</strong> in was ballot 2. The <strong>latest</strong> of these two earlier ballots is ballot 5, so the condition requires that ballot 27's decree must equal ballot 5's decree.</li><li>The members of ballot 29's quorum are <span class="math inline">\(\mathrm{B}\)</span>, <span class="math inline">\(\Gamma\)</span>, and <span class="math inline">\(\Delta\)</span>. The only earlier ballot that <span class="math inline">\(\mathrm{B}\)</span> voted in was number 14, priest <span class="math inline">\(\Gamma\)</span> voted in ballots 5 and 27, and <span class="math inline">\(\Delta\)</span> voted in ballots 2 and 27. The latest of these four earlier ballots is number 27, so the condition requires that ballot 29's decree must equal ballot 27's decree.</li></ul><h4 id="a-formal-statement-of-three-conditions">A Formal Statement of Three Conditions</h4><p>To state <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span> - <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> formally requires some more notation. A vote <span class="math inline">\(v\)</span> was defined to be a quantity consisting of three components: a priest <span class="math inline">\(v_{pst}\)</span>, a ballot number <span class="math inline">\(v_{bal}\)</span>, and a decree <span class="math inline">\(v_{dec}\)</span>. It represents a vote cast by priest <span class="math inline">\(v_{pst}\)</span> for decree <span class="math inline">\(v_{dec}\)</span> in ballot number <span class="math inline">\(v_{bal}\)</span>. The Paxons also defined null votes to be votes <span class="math inline">\(v\)</span> with <span class="math inline">\(v_{bal} = -\infty\)</span> and <span class="math inline">\(v_{dec} = \text{BLANK}\)</span>, where <span class="math inline">\(-\infty &lt; b &lt; \infty\)</span> for any ballot number <span class="math inline">\(b\)</span>, and <span class="math inline">\(\text{BLANK}\)</span> is not a decree. For any priest <span class="math inline">\(p\)</span>, they defined <span class="math inline">\(null_p\)</span> to be the unique null vote <span class="math inline">\(v\)</span> with <span class="math inline">\(v_{pst} = p\)</span>.</p><p>For any votes <span class="math inline">\(v\)</span> and <span class="math inline">\(v^{\prime}\)</span>, if <span class="math inline">\(v_{bal} &lt; v_{bal}^{\prime}\)</span> then <span class="math inline">\(v &lt; v^{\prime}\)</span>. It is not known how the relative order of <span class="math inline">\(v\)</span> and <span class="math inline">\(v^{\prime}\)</span> was defined if <span class="math inline">\(v_{bal} = v_{bal}^{\prime}\)</span>.</p><p>For any set <span class="math inline">\(\mathcal{B}\)</span> of ballots, the set <span class="math inline">\(\operatorname{Votes}(\mathcal{B})\)</span> of votes in <span class="math inline">\(\mathcal{B}\)</span> was defined to consist of all votes <span class="math inline">\(v\)</span> such that <span class="math inline">\(v_{pst} \in B_{vot}\)</span>, <span class="math inline">\(v_{bal} = B_{bal}\)</span>, and <span class="math inline">\(v_{dec} = B_{dec}\)</span> for some <span class="math inline">\(B \in \mathcal{B}\)</span>.</p><p>If <span class="math inline">\(p\)</span> is a priest and <span class="math inline">\(b\)</span> is either a ballot number or <span class="math inline">\(\pm \infty\)</span>, then <span class="math inline">\(\operatorname{MaxVote}(b, p, \mathcal{B})\)</span> was defined to be the largest vote <span class="math inline">\(v\)</span> in <span class="math inline">\(\operatorname{Votes}(\mathcal{B})\)</span> cast by <span class="math inline">\(p\)</span> with <span class="math inline">\(v_{bal} &lt; b\)</span>, or to be <span class="math inline">\(null_p\)</span> if there was no such vote. Since <span class="math inline">\(null_p\)</span> is smaller than any real vote cast by <span class="math inline">\(p\)</span>, this means that <span class="math inline">\(\operatorname{MaxVote}(b, p, \mathcal{B})\)</span> is the largest vote in the set:</p><p><span class="math display">\[  \left\{    v \in \operatorname{Votes}(\mathcal{B}):      \left(v_{pst}=p\right)    \wedge      \left(v_{bal}&lt;b\right)  \right\}\cup  \left\{null_p\right\}\]</span></p><p>Conditions <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span> – <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> are stated formally as follows:</p><span class="math display">\[\begin{aligned}&amp;B1(\mathcal{B}) \triangleq  \forall B, B^{\prime} \in \mathcal{B}:    \left(B \neq B^{\prime}\right)    \Rightarrow    \left(B_{bal} \neq B_{bal}^{\prime}\right)   \\&amp;B2(\mathcal{B}) \triangleq  \forall B, B^{\prime} \in \mathcal{B}:    B_{qrm} \cap B_{qrm}^{\prime} \neq \emptyset \\&amp;B3(\mathcal{B}) \triangleq  \forall B \in \mathcal{B}:    \left(\operatorname{MaxVote}(B_{bal}, B_{qrm}, \mathcal{B})_{bal} \neq -\infty\right)    \Rightarrow                                  \\    &amp;\quad\left(B_{dec}=\operatorname{MaxVote}(B_{bal}, B_{qrm}, \mathcal{B})_{dec}\right)\end{aligned}\]</span><h4 id="lemma">Lemma</h4><p>To show that these conditions imply consistency, the Paxons first showed that <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span> – <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> imply that, if a ballot <span class="math inline">\(B\)</span> in <span class="math inline">\(\mathcal{B}\)</span> is <strong>successful</strong>, then any later ballot in <span class="math inline">\(\mathcal{B}\)</span> is for the same decree as <span class="math inline">\(B\)</span>. If <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span>, <span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span>, and <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> hold, then:</p><p><span class="math display">\[\forall B, B^{\prime} \in \mathcal{B}:    \left(        \left(B_{qrm} \subseteq B_{vot}\right)      \wedge        \left(B_{bal}^{\prime} &gt; B_{bal}\right)    \right)  \Rightarrow    \left(B_{dec}^{\prime} = B_{dec}\right)\]</span></p><h5 id="proof-of-lemma">Proof of Lemma</h5><p>The author uses <span class="math inline">\(B_{qrm} \subseteq B_{vot}\)</span> instead of <span class="math inline">\(B_{qrm} = B_{vot}\)</span> to express a successful ballot <span class="math inline">\(B\)</span>. This is because <span class="math inline">\(B_{qrm} = B_{vot}\)</span> is logically equivalent to <span class="math inline">\(\left(B_{vot} \subseteq B_{qrm}\right) \wedge \left(B_{qrm} \subseteq B_{vot}\right)\)</span>, but only the condition <span class="math inline">\(B_{qrm} \subseteq B_{vot}\)</span> is required to prove the lemma.</p><p>For any ballot <span class="math inline">\(B\)</span> in <span class="math inline">\(\mathcal{B}\)</span>, let <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B})\)</span> be the set of ballots in <span class="math inline">\(\mathcal{B}\)</span> later than <span class="math inline">\(B\)</span> for a decree different from <span class="math inline">\(B\)</span>'s:</p><p><span class="math display">\[\operatorname{\Psi}(B, \mathcal{B}) \triangleq    \left\{      B^{\prime} \in \mathcal{B}:          \left(B_{bal}^{\prime} &gt; B_{bal}\right)        \wedge          \left(B_{dec}^{\prime} \neq B_{dec}\right)    \right\}\]</span></p><p>To prove the lemma, it suffices to show that if <span class="math inline">\(B_{qrm} \subseteq B_{vot}\)</span> then <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B})\)</span> is empty. The Paxons gave a proof by contradiction. They assumed the existence of a <span class="math inline">\(B\)</span> with <span class="math inline">\(B_{qrm} \subseteq B_{vot}\)</span> and <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B}) \neq \emptyset\)</span>, and obtained a contradiction as follows:</p><ol type="1"><li>Choose <span class="math inline">\(C \in \operatorname{\Psi}(B, \mathcal{B})\)</span> such that <span class="math inline">\(C_{bal} = \min \left\{B_{bal}^{\prime}: B^{\prime} \in \Psi(B, \mathcal{B})\right\}\)</span>. Proof:<ul><li><span class="math inline">\(C\)</span> exists because <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B})\)</span> is nonempty and finite.</li></ul></li><li><span class="math inline">\(C_{bal} &gt; B_{bal}\)</span>. Proof:<ul><li>By the definition of <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B})\)</span> and 1.</li></ul></li><li><span class="math inline">\(B_{vot} \cap C_{qrm} \neq \emptyset\)</span>. Proof:<ul><li>Given ballot <span class="math inline">\(B\)</span> is successful, then <span class="math inline">\(B_{qrm} \subseteq B_{vot}\)</span> (by definition of a successful ballot).</li><li>By <span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span>, <span class="math inline">\(B_{qrm} \cap C_{qrm} \neq \emptyset\)</span>.</li><li>Therefore, <span class="math inline">\(B_{vot} \cap C_{qrm} \neq \emptyset\)</span>.</li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \geq B_{bal}\)</span>. Proof:<ul><li>By definition, <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})\)</span> is the largest vote in the set <span class="math inline">\(\eqref{proof-of-lemma:step-4:by-definition}\)</span>.</li><li>There exists at least one vote <span class="math inline">\(v\)</span> by priest <span class="math inline">\(p\)</span> in ballot <span class="math inline">\(B\)</span> satisfying the following conditions:<ul><li>By 2, <span class="math inline">\(v_{bal} = B_{bal} &lt; C_{bal}\)</span>.</li><li>By 3, <span class="math inline">\((p \in B_{vot}) \wedge (p \in C_{qrm})\)</span>.</li><li>Therefore, <span class="math inline">\(v\)</span> is a valid element of the set denoted by Equation <span class="math inline">\(\eqref{proof-of-lemma:step-4:by-definition}\)</span>.</li></ul></li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B}) \in \operatorname{Votes}(\mathcal{B})\)</span>. Proof:<ul><li>By 4, <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})\)</span> is not a null vote.</li><li>By the definition of <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})\)</span>.</li></ul></li><li><span class="math inline">\(C_{dec} = \operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{dec}\)</span>. Proof:<ul><li>By 5, <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \neq -\infty\)</span>.</li><li>By <span class="math inline">\(B3(\mathcal{B})\)</span>.</li></ul></li><li><ol type="i"><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{dec} \neq B_{dec}\)</span>. Proof:<ul><li>By the definition of <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B})\)</span> and 1, <span class="math inline">\(C_{dec} \neq B_{dec}\)</span>.</li><li>By 6, <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{dec} \neq B_{dec}\)</span>.</li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \neq B_{bal}\)</span>. Proof:<ul><li>By <span class="math inline">\(\left(B_{dec}^{\prime} \neq B_{dec}\right) \Rightarrow \left(B^{\prime} \neq B\right)\)</span>, <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B}) \neq B\)</span>.</li><li>By <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span>, <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \neq B_{bal}\)</span>.</li></ul></li></ol></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} &gt; B_{bal}\)</span>. Proof:<ul><li>By 4 and 7.ii.</li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B}) \in \operatorname{Votes}(\Psi(B, \mathcal{B}))\)</span>. Proof:<ul><li>By the definition of <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B})\)</span>, 8 and 7.i.</li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} &lt; C_{bal}\)</span>. Proof:<ul><li>By definition of <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})\)</span>.</li></ul></li><li>Contradiction. Proof:<ul><li>Ballot <span class="math inline">\(C\)</span> does not have the minimum ballot ID in the set <span class="math inline">\(\operatorname{\Psi}(B, \mathcal{B})\)</span>.<ul><li>By 8, <span class="math inline">\(B_{bal} &lt; \operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal}\)</span>.</li><li>By 10, <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} &lt; C_{bal}\)</span>.</li><li>By 7.i., <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{dec} \neq B_{dec}\)</span>.</li></ul></li><li>By 1.</li><li>By 9. Why do we need step 9 to prove the contradiction in this case?</li></ul></li></ol><p><span class="math display">\[\begin{align}  \left\{    v \in \operatorname{Votes}(\mathcal{B}):      \left(v_{pst} \in C_{qrm}\right)    \wedge      \left(v_{bal} &lt; C_{bal}\right)  \right\}\cup  \left\{null_p\right\}\label{proof-of-lemma:step-4:by-definition}\end{align}\]</span></p><h5 id="understanding-the-proof-of-the-lemma">Understanding the Proof of the Lemma</h5><p>The author proves the Lemma in the section "Proof of Lemma". I would like to analyze how the author constructed the proof in a new section. However, constructing the proof <strong>from scratch</strong> is too difficult. The key idea is that the author proves the Lemma by contradiction.</p><p>The contradiction is that we assume <span class="math inline">\(C\)</span> is the "first" ballot whose decree differs from <span class="math inline">\(B_{dec}\)</span> (step 1). However, we can find another ballot whose number is <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal}\)</span> that occurs "between" <span class="math inline">\(B\)</span> and <span class="math inline">\(C\)</span> and satisfies the required condition (step 11).</p><ul><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{dec} \neq B_{dec}\)</span> (step 7.i)<ul><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{dec} = C_{dec}\)</span> (step 6)<ul><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})\)</span> is not a null vote (step 5)<ul><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \ge B_{bal}\)</span> (step 4)</li></ul></li><li><span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span></li></ul></li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \gt B_{bal}\)</span> (step 8)<ul><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \ge B_{bal}\)</span> (step 4)<ul><li>At least one priest in the quorum <span class="math inline">\(C_{qrm}\)</span> has cast a vote for ballot <span class="math inline">\(B\)</span>.<ul><li><span class="math inline">\(B_{vot} \cap C_{qrm} \neq \emptyset\)</span> (step 3)</li><li><span class="math inline">\(C_{bal} &gt; B_{bal}\)</span> (step 2)</li></ul></li><li>By the definition of <span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})\)</span>.</li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \neq B_{bal}\)</span> (step 7.ii)</li></ul></li><li><span class="math inline">\(\operatorname{MaxVote}(C_{bal}, C_{qrm}, \mathcal{B})_{bal} \lt C_{bal}\)</span> (step 10)</li></ul><h4 id="theorem-1">Theorem 1</h4><p>With this lemma, it was easy to show that, if <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span> – <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> hold, then any two <strong>successful</strong> ballots are for the <strong>same</strong> decree.</p><p><span class="math display">\[\forall B, B^{\prime} \in \mathcal{B}:    \left(        \left(B_{qrm} \subseteq B_{vot}\right)      \wedge        \left(B_{qrm}^{\prime} \subseteq B_{vot}^{\prime}\right)    \right)  \Rightarrow    \left(B_{dec}^{\prime} = B_{dec}\right)\]</span></p><h5 id="proof-of-theorem-1">Proof of Theorem 1</h5><ul><li>If <span class="math inline">\(B_{bal}^{\prime} = B_{bal}\)</span>, then <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span> implies <span class="math inline">\(B^{\prime} = B\)</span>.</li><li>If <span class="math inline">\(B_{bal}^{\prime} \neq B_{bal}\)</span>, then the theorem follows immediately from the lemma.</li></ul><h4 id="theorem-2">Theorem 2</h4><p>The Paxons then proved a theorem asserting that if there are enough priests in the Chamber, then it is <strong>possible</strong> to conduct a successful ballot while preserving <span class="math inline">\(\operatorname{B1}\)</span> – <span class="math inline">\(\operatorname{B3}\)</span>. Although this <strong>does not guarantee progress</strong>, it at least shows that a balloting protocol based on <span class="math inline">\(\operatorname{B1}\)</span> – <span class="math inline">\(\operatorname{B3}\)</span> <strong>will not deadlock</strong>.</p><p>Let <span class="math inline">\(b\)</span> be a ballot number and <span class="math inline">\(Q\)</span> a set of priests such that <span class="math inline">\(b &gt; B_{bal}\)</span> and <span class="math inline">\(Q \cap B_{qrm} \neq \emptyset\)</span> for all <span class="math inline">\(B \in \mathcal{B}\)</span>. If <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span>, <span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span>, and <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> hold, then there <strong>is</strong> a ballot <span class="math inline">\(B^{\prime}\)</span> with <span class="math inline">\(B_{bal}^{\prime} = b\)</span> and <span class="math inline">\(B_{qrm}^{\prime} = B_{vot}^{\prime} = Q\)</span> such that <span class="math inline">\(\operatorname{B1}(\mathcal{B} \cup \{B^\prime\})\)</span>, <span class="math inline">\(\operatorname{B2}(\mathcal{B} \cup \{B^\prime\})\)</span> and <span class="math inline">\(\operatorname{B3}(\mathcal{B} \cup \{B^\prime\})\)</span> hold.</p><ul><li>Condition <span class="math inline">\(\operatorname{B1}(\mathcal{B} \cup \{B^\prime\})\)</span> follows from <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span>, the choice of <span class="math inline">\(B_{bal}^{\prime}\)</span>, and the assumption about <span class="math inline">\(b\)</span>.</li><li>Condition <span class="math inline">\(\operatorname{B2}(\mathcal{B} \cup \{B^\prime\})\)</span> follows from <span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span>, the choice of <span class="math inline">\(B_{qrm}^{\prime}\)</span> , and the assumption about <span class="math inline">\(Q\)</span>.</li><li>If <span class="math inline">\(\operatorname{MaxVote}(b, Q, \mathcal{B})_{bal} = −\infty\)</span> then let <span class="math inline">\(B_{dec}^{\prime}\)</span> be any decree, else <strong>let it equal</strong> <span class="math inline">\(\operatorname{MaxVote}(b, Q, \mathcal{B})_{dec}\)</span>. Condition <span class="math inline">\(\operatorname{B3}(\mathcal{B} \cup \{B^\prime\})\)</span> then follows from <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span>.</li></ul><h3 id="the-preliminary-protocol">The Preliminary Protocol</h3><p>The definition of the protocol specified how the set <span class="math inline">\(\mathcal{B}\)</span> changed, but the set was never explicitly calculated. The Paxons referred to <span class="math inline">\(\mathcal{B}\)</span> as a quantity observed only by the gods, since it might never be known to any mortal.</p><ul><li>To maintain <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span>, each ballot had to receive a unique number. An obvious method would have been to let a ballot number be a pair consisting of an integer and a priest, using a lexicographical ordering, where <span class="math inline">\((13, \Gamma \rho \alpha \breve{\iota}) &lt; (13, \Lambda \iota \nu \sigma \epsilon \breve{\iota}) &lt; (15, \Gamma \rho \alpha \breve{\imath})\)</span>.</li><li>To maintain <span class="math inline">\(\operatorname{B2}(\mathcal{B})\)</span>, a ballot's quorum was chosen to contain a <span class="math inline">\(\mu \alpha \delta \zeta \partial \omega \rho \iota \tau \breve{\sigma} \sigma \tau\)</span> of priests.<ul><li>Initially, <span class="math inline">\(\mu \alpha \delta \zeta \partial \omega \rho \iota \tau \breve{\sigma} \sigma \tau\)</span> just meant a simple majority.</li><li>Later, it was observed that fat priests were less mobile and spent more time in the Chamber than thin ones, so a <span class="math inline">\(\mu \alpha \delta \zeta \partial \omega \rho \iota \tau \breve{\sigma} \sigma \tau\)</span> was taken to mean any set of priests whose total weight was more than half the total weight of all priests, rather than a simple majority of the priests.</li><li>When a group of thin priests complained that this was unfair, actual weights were replaced with symbolic weights based on a priest’s attendance record.</li></ul></li><li>To maintain <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span>, before initiating a new ballot with ballot number <span class="math inline">\(b\)</span> and quorum <span class="math inline">\(Q\)</span>, a priest <span class="math inline">\(p\)</span> had to find <span class="math inline">\(\operatorname{MaxVote}(b, Q, \mathcal{B})_{dec}\)</span>. To do this, <span class="math inline">\(p\)</span> had to find <span class="math inline">\(\operatorname{MaxVote}(b, q, \mathcal{B})\)</span> for <strong>each</strong> priest <span class="math inline">\(q\)</span> in <span class="math inline">\(Q\)</span>.<ul><li>Priest <span class="math inline">\(p\)</span> obtains <span class="math inline">\(\operatorname{MaxVote}(b, q, \mathcal{B})\)</span> from <span class="math inline">\(q\)</span> by an <strong>exchange of messages</strong>.</li><li>Therefore, the first two steps in the protocol for conducting a single ballot initiated by <span class="math inline">\(p\)</span> are:<ul><li>(1) Priest <span class="math inline">\(p\)</span> chooses a new ballot number <span class="math inline">\(b\)</span> and sends a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message to <strong>some</strong> set of priests.</li><li>(2) A priest <span class="math inline">\(q\)</span> responds to the receipt of a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message by sending a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message to <span class="math inline">\(p\)</span>, where <span class="math inline">\(v\)</span> is the vote with the largest ballot number less than <span class="math inline">\(b\)</span> that <span class="math inline">\(q\)</span> has cast, or his null vote <span class="math inline">\(null_q\)</span> if <span class="math inline">\(q\)</span> did not vote in any ballot numbered less than <span class="math inline">\(b\)</span>.</li><li>When <span class="math inline">\(q\)</span> sends the <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message, <span class="math inline">\(v\)</span> equals <span class="math inline">\(\operatorname{MaxVote}(b, q, \mathcal{B})\)</span>. But the set <span class="math inline">\(\mathcal{B}\)</span> of ballots changes as new ballots are initiated and votes are cast. To keep <span class="math inline">\(\operatorname{MaxVote}(b, q, \mathcal{B})\)</span> from changing, <span class="math inline">\(q\)</span> <strong>must cast no new votes</strong> with ballot numbers between <span class="math inline">\(v_{bal}\)</span> and <span class="math inline">\(b\)</span>.</li></ul></li></ul></li></ul><p>The next two steps in the balloting protocol (begun in step 1 by priest <span class="math inline">\(p\)</span>) are:</p><ul><li>(3) After receiving a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message from every priest in some <strong>majority</strong> set <span class="math inline">\(Q\)</span>, priest <span class="math inline">\(p\)</span> initiates a new ballot with number <span class="math inline">\(b\)</span>, quorum <span class="math inline">\(Q\)</span>, and decree <span class="math inline">\(d\)</span>, where <span class="math inline">\(d\)</span> is chosen to satisfy <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span>. He then records the ballot in the back of his ledger and sends a <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message to <strong>every</strong> priest in <span class="math inline">\(Q\)</span>.<ul><li>The execution of step (3) is considered to add a ballot <span class="math inline">\(B\)</span> to <span class="math inline">\(\mathcal{B}\)</span>, where <span class="math inline">\(B_{bal} = b\)</span>, <span class="math inline">\(B_{qrm} = Q\)</span>, <span class="math inline">\(B_{vot} = \emptyset\)</span> (no one has yet voted in this ballot), and <span class="math inline">\(B_{dec} = d\)</span>.</li><li>In step (4), if priest <span class="math inline">\(q\)</span> decides to vote in the ballot, then executing that step is considered to change the set <span class="math inline">\(\mathcal{B}\)</span> of ballots by adding <span class="math inline">\(q\)</span> to the set <span class="math inline">\(B_{vot}\)</span> of voters in the ballot <span class="math inline">\(B \in \mathcal{B}\)</span>.</li></ul></li><li>(4) Upon receipt of the <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message, priest <span class="math inline">\(q\)</span> decides whether or not to cast his vote in ballot number <span class="math inline">\(b\)</span>.<ul><li>He may not cast the vote if doing so would violate a promise implied by a <span class="math inline">\(\operatorname{LastVote}(b^{\prime}, v^{\prime})\)</span> message he has sent for some other ballot.</li><li>A priest has the option not to vote in step (4), even if casting a vote would not violate any previous promise.</li><li>If <span class="math inline">\(q\)</span> decides to vote for ballot number <span class="math inline">\(b\)</span>, then he sends a <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message to <span class="math inline">\(p\)</span> and records the vote in the back of his ledger.</li></ul></li></ul><p>Steps (1) – (4) describe the complete protocol for initiating a ballot and voting on it. All that remains is to determine the results of the balloting and announce when a decree has been selected. Recall that a ballot is successful iff <strong>every</strong> priest in the quorum has voted.</p><ul><li>(5) If <span class="math inline">\(p\)</span> has received a <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message from <strong>every</strong> priest <span class="math inline">\(q\)</span> in <span class="math inline">\(Q\)</span> (the quorum for ballot number <span class="math inline">\(b\)</span>), then he writes <span class="math inline">\(d\)</span> (the decree of that ballot) in his ledger and sends a <span class="math inline">\(\operatorname{Success}(d)\)</span> message to every priest.</li><li>(6) Upon receiving a <span class="math inline">\(\operatorname{Success}(d)\)</span> message, a priest enters decree <span class="math inline">\(d\)</span> in his ledger.</li></ul><p>Since a priest enters a decree in his ledger only if it is the decree of a successful ballot, Theorem 1 implies that the priests' ledgers are consistent.</p><ul><li>The protocol does not address the question of progress. All the steps in this protocol are optional. For example, a priest <span class="math inline">\(q\)</span> can ignore a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message instead of executing step (2). Failure to take an action can prevent progress, but it cannot cause any inconsistency because it cannot make <span class="math inline">\(\operatorname{B1}(\mathcal{B})\)</span> – <span class="math inline">\(\operatorname{B3}(\mathcal{B})\)</span> false.</li><li>Receiving multiple copies of a message can cause an action to be repeated.<ul><li>Except in step (3), performing the action a second time has no effect. For example, sending several <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> messages in step (4) has the same effect as sending just one.</li><li>By executing step (3) more than once, priest <span class="math inline">\(p\)</span> may initiate multiple ballots with the same ballot number <span class="math inline">\(b\)</span> but with different quorums <span class="math inline">\(Q\)</span>, <span class="math inline">\(Q&#39;\)</span>, ... and decrees <span class="math inline">\(d\)</span>, <span class="math inline">\(d&#39;\)</span>, ... The repetition of step (3) is prevented by using the entry made in the back of the ledger when it is executed.</li><li>Thus, the consistency condition is maintained even if a messenger delivers the same message several times.</li></ul></li></ul><h3 id="the-basic-protocol">The Basic Protocol</h3><p>One problem with the preliminary protocol was that keeping track of all this information would have been difficult for the busy priests. The Paxons therefore <strong>restricted</strong> the preliminary protocol to obtain the more practical basic protocol in which each priest <span class="math inline">\(p\)</span> had to maintain only the following information in the back of his ledger:</p><ul><li><span class="math inline">\(\operatorname{lastTried}(p)\)</span>: The number of the last ballot that <span class="math inline">\(p\)</span> tried to initiate, or <span class="math inline">\(-\infty\)</span> if there was none.<ul><li>Though the author does not explicitly state this, I believe the intent of introducing <span class="math inline">\(\operatorname{lastTried}(p)\)</span> is to prevent executing step (3) more than once, which would result in initiating multiple ballots with the same ballot number <span class="math inline">\(b\)</span> but with different quorums <span class="math inline">\(Q\)</span>, <span class="math inline">\(Q&#39;\)</span> and decrees <span class="math inline">\(d\)</span>, <span class="math inline">\(d&#39;\)</span>.</li><li>The preliminary protocol allows <span class="math inline">\(p\)</span> to conduct any number of ballots concurrently. In the basic protocol, he conducts only one ballot at a time — ballot number <span class="math inline">\(\operatorname{lastTried}(p)\)</span>. After <span class="math inline">\(p\)</span> initiates this ballot, he ignores messages that pertain to any other ballot that he had previously initiated.</li><li>Priest <span class="math inline">\(p\)</span> keeps all information about the progress of ballot number <span class="math inline">\(\operatorname{lastTried}(p)\)</span> on a slip of <strong>paper</strong>. If he loses that slip of paper, then he stops conducting the ballot.</li></ul></li><li><span class="math inline">\(\operatorname{prevVote}(p)\)</span>: The <strong>vote</strong> cast by <span class="math inline">\(p\)</span> in the <strong>highest</strong>-numbered ballot in which he voted, or <span class="math inline">\(-\infty\)</span> if he never voted.<ul><li>Upon receipt of a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message from <span class="math inline">\(q\)</span> with <span class="math inline">\((b &gt; \operatorname{prevVote}(p)_{bal}) \wedge (b &gt; \operatorname{nextBal}(p))\)</span>, priest <span class="math inline">\(p\)</span> sends a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message to <span class="math inline">\(q\)</span>, where <span class="math inline">\(v\)</span> equals <span class="math inline">\(\operatorname{prevVote}(p)\)</span>.</li><li>If <span class="math inline">\(b \le \operatorname{prevVote}(p)_{bal}\)</span>, then priest <span class="math inline">\(p\)</span> does not remember the vote with the largest ballot number less than <span class="math inline">\(b\)</span> that he has cast. Therefore, priest <span class="math inline">\(p\)</span> cannot respond.</li><li>If <span class="math inline">\(b \le \operatorname{nextBal}(p)\)</span>, then priest <span class="math inline">\(p\)</span> will not vote due to his promise. Therefore, it is meaningless for priest <span class="math inline">\(p\)</span> to respond with a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message.</li><li>Before priest <span class="math inline">\(p\)</span> votes for ballot <span class="math inline">\(b\)</span> and updates <span class="math inline">\(\operatorname{preVote}(p)\)</span> to <span class="math inline">\(b\)</span>, priest <span class="math inline">\(p\)</span> must have sent a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message to priest <span class="math inline">\(q\)</span> and updated <span class="math inline">\(\operatorname{nextBal}(p)\)</span> to <span class="math inline">\(b\)</span>. Therefore, we have <span class="math inline">\(\operatorname{nextBal}(p) \ge \operatorname{preVote}(p)\)</span>.</li><li>By <span class="math inline">\(\eqref{the-basic-protocol:prev-vote}\)</span>, the following statements by the author make sense:<ul><li>Upon receipt of a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message from <span class="math inline">\(q\)</span> with <span class="math inline">\(b &gt; \operatorname{nextBal}(p)\)</span>, priest <span class="math inline">\(p\)</span> sets <span class="math inline">\(\operatorname{nextBal}(p)\)</span> to <span class="math inline">\(b\)</span> and sends a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message to <span class="math inline">\(q\)</span>, where <span class="math inline">\(v\)</span> equals <span class="math inline">\(\operatorname{prevVote}(p)\)</span>.</li><li>A <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message is ignored if <span class="math inline">\(b \le \operatorname{nextBal}(p)\)</span>.</li></ul></li></ul></li><li><span class="math inline">\(\operatorname{nextBal}(p)\)</span>: The largest value of <span class="math inline">\(b\)</span> for which <span class="math inline">\(p\)</span> has sent a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message, or <span class="math inline">\(-\infty\)</span> if he has never sent such a message.<ul><li>In the preliminary protocol, each <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message sent by a priest <span class="math inline">\(q\)</span> represents a promise not to vote in any ballot numbered between <span class="math inline">\(v_{bal}\)</span> and <span class="math inline">\(b\)</span>.</li><li>In the basic protocol, it represents the <strong>stronger</strong> promise not to cast a new vote in any ballot numbered less than <span class="math inline">\(b\)</span>.</li></ul></li></ul><p><span class="math display">\[\begin{align}\label{the-basic-protocol:prev-vote}    &amp;\quad\quad\left(        \left(            \left(b &gt; \operatorname{prevVote}(p)_{bal}\right)          \wedge            \left(b &gt; \operatorname{nextBal}(p)\right)        \right) \nonumber      \right.             \\      &amp;\quad\left.      \wedge        \left(          \operatorname{nextBal}(p) \ge \operatorname{preVote}(p)        \right)    \right)     \nonumber \\  &amp;\Rightarrow    \left(      b &gt; \operatorname{nextBal}(p)    \right)\end{align}\]</span></p><p>Steps 1–6 of the preliminary protocol become the following six steps for conducting a ballot in the basic protocol:</p><ol type="1"><li>Priest <span class="math inline">\(p\)</span> chooses a new ballot number <span class="math inline">\(b\)</span> greater than <span class="math inline">\(\operatorname{lastTried}(p)\)</span>,sets <span class="math inline">\(\operatorname{lastTried}(p)\)</span> to <span class="math inline">\(b\)</span>, and sends a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message to some set of priests. Please notice that the quorum <span class="math inline">\(Q\)</span> has not yet been determined.</li><li>Upon receipt of a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message from <span class="math inline">\(p\)</span> with <span class="math inline">\(b &gt; \operatorname{nextBal}(q)\)</span>, priest <span class="math inline">\(q\)</span> sets <span class="math inline">\(\operatorname{nextBal}(q)\)</span> to <span class="math inline">\(b\)</span> and sends a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message to <span class="math inline">\(p\)</span>, where <span class="math inline">\(v\)</span> equals <span class="math inline">\(\operatorname{prevVote}(q)\)</span>. A <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message is ignored if <span class="math inline">\(b \le \operatorname{nextBal}(q)\)</span>.</li><li>After receiving a <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message from every priest in <strong>some majority set</strong> <span class="math inline">\(Q\)</span>, where <span class="math inline">\(b = \operatorname{lastTried}(p)\)</span>, priest <span class="math inline">\(p\)</span> initiates a new ballot with number <span class="math inline">\(b\)</span>, quorum <span class="math inline">\(Q\)</span>, and decree <span class="math inline">\(d\)</span>, where <span class="math inline">\(d\)</span> is chosen to satisfy <span class="math inline">\(\operatorname{B3}\)</span>. He then sends a <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message to <strong>every</strong> priest in <span class="math inline">\(Q\)</span>. (If <span class="math inline">\(b \neq \operatorname{lastTried}(p)\)</span>, the <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message is a response to a <strong>previous</strong> <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> conducted by priest <span class="math inline">\(p\)</span>; so, priest <span class="math inline">\(p\)</span> just ignores it.)</li><li>Upon receipt of a <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message with <span class="math inline">\(b = \operatorname{nextBal}(q)\)</span>, priest <span class="math inline">\(q\)</span> casts his vote in ballot number <span class="math inline">\(b\)</span>, sets <span class="math inline">\(\operatorname{prevVote}(q)\)</span> to this vote, and sends a <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message to <span class="math inline">\(p\)</span>. (A <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message is ignored if <span class="math inline">\(b \neq \operatorname{nextBal}(q)\)</span>.)<ol type="1"><li>We first prove that <span class="math inline">\(\operatorname{nextBal}(q)\)</span> is greater than or equal to the ballot number <span class="math inline">\(b\)</span> in the <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message from priest <span class="math inline">\(p\)</span> to priest <span class="math inline">\(q\)</span>. The proof is as follows: If priest <span class="math inline">\(p\)</span> sends an <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message to priest <span class="math inline">\(q\)</span>, it means priest <span class="math inline">\(p\)</span> has received an <span class="math inline">\(\operatorname{LastVote}(b, v)\)</span> message from priest <span class="math inline">\(q\)</span> and chosen priest <span class="math inline">\(q\)</span> as a member of the majority quorum set <span class="math inline">\(Q\)</span>. Then, priest <span class="math inline">\(q\)</span> must have set <span class="math inline">\(\operatorname{nextBal}(q)\)</span> to <span class="math inline">\(b\)</span>. In addition, we already know <span class="math inline">\(\operatorname{nextBal}(q)\)</span> increases monotonically. Therefore, we can conclude that <span class="math inline">\(\operatorname{nextBal}(q)\)</span> is greater than or equal to the ballot number <span class="math inline">\(b\)</span> in the <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message from priest <span class="math inline">\(p\)</span> to priest <span class="math inline">\(q\)</span>.</li><li>Then, we can say <span class="math inline">\(b \neq \operatorname{nextBal}(q)\)</span> if and only if <span class="math inline">\(b &lt; \operatorname{nextBal}(q)\)</span>. By the requirement that <span class="math inline">\(\operatorname{nextBal}(q)\)</span> represents that priest <span class="math inline">\(q\)</span> cannot cast a new vote in any ballot numbered less than <span class="math inline">\(\operatorname{nextBal}(q)\)</span>, priest <span class="math inline">\(q\)</span> should not cast a vote. In conclusion, priest <span class="math inline">\(q\)</span> ignores an <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message with <span class="math inline">\(b \neq \operatorname{nextBal}(q)\)</span>.</li></ol></li><li>If <span class="math inline">\(p\)</span> has received a <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message from <strong>every</strong> priest <span class="math inline">\(q\)</span> in <span class="math inline">\(Q\)</span> (the quorum for ballot number <span class="math inline">\(b\)</span>), where <span class="math inline">\(b = \operatorname{lastTried}(p)\)</span>, then he writes <span class="math inline">\(d\)</span> (the decree of that ballot) in his ledger and sends a <span class="math inline">\(\operatorname{Success}(d)\)</span> message to <strong>every</strong> priest.<ol type="1"><li>We first prove that <span class="math inline">\(\operatorname{lastTried}(p)\)</span> is greater than or equal to the ballot number <span class="math inline">\(b\)</span> in the <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message. This is because priest <span class="math inline">\(p\)</span> sets <span class="math inline">\(\operatorname{lastTried}(p)\)</span> to a new ballot number <span class="math inline">\(b^{\prime}\)</span> before performing all the following steps.</li><li>Then, we can say <span class="math inline">\(b \neq \operatorname{lastTried}(p)\)</span> if and only if <span class="math inline">\(b &lt; \operatorname{lastTried}(p)\)</span>, where <span class="math inline">\(b\)</span> comes from the <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> message. Though the author does not explicitly state this, I believe that when priest <span class="math inline">\(p\)</span> initiates a new ballot, all information about the progress of the old ballot (e.g., quorum <span class="math inline">\(Q\)</span>) on a slip of paper is forgotten. So, <span class="math inline">\(\operatorname{Voted}(b, q)\)</span> messages where <span class="math inline">\(b &lt; \operatorname{lastTried}(p)\)</span> are ignored by priest <span class="math inline">\(p\)</span>.</li></ol></li><li>Upon receiving a <span class="math inline">\(\operatorname{Success}(d)\)</span> message, a priest enters decree <span class="math inline">\(d\)</span> in his ledger.</li></ol><h4 id="proof-of-consistency-of-the-basic-synodic-protocol">Proof of Consistency of the Basic Synodic Protocol</h4><h3 id="the-complete-synod-protocol">The Complete Synod Protocol</h3><p>To help achieve progress, the complete protocol includes the obvious additional requirement that priests perform steps 2–6 of the protocol as soon as possible. The key to the complete protocol lay in determining <strong>when</strong> a priest should initiate a ballot. Achieving the progress condition requires that new ballots be initiated until one succeeds, but that they not be initiated too frequently.</p><ul><li>Never initiating a ballot will certainly prevent progress.</li><li>However, initiating too may ballots can also prevent progress. This can be best illustrated with a potential livelock scenario:<ul><li>Priest <span class="math inline">\(p1\)</span> executes step 1, sends out <span class="math inline">\(\operatorname{NextBallot}(b1)\)</span> msgs to other priests.</li><li>Priest <span class="math inline">\(p2\)</span> executes step 1, sends out <span class="math inline">\(\operatorname{NextBallot}(b2)\)</span> msgs to other priests, and <span class="math inline">\(b2 &gt; b1\)</span>.</li><li>Priests which received <span class="math inline">\(\operatorname{NextBallot}(b2)\)</span> msgs cannot vote for <span class="math inline">\(b1\)</span> anymore. So <span class="math inline">\(b1\)</span> fails.</li><li>Priest <span class="math inline">\(p1\)</span> xecutes step 1 again, but with a larger ballot ID.</li></ul></li></ul><h4 id="liveness-t-99min">Liveness: T + 99min</h4><p>The preceding sections have discussed the safety aspects of the Synod protocol. This section, however, delves into its liveness. Liveness, in the context of the Synod protocol, signifies that under certain conditions, the protocol can execute to completion within a finite timeframe.</p><p>By extending the protocol to require that if a priest <span class="math inline">\(q\)</span> received a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> or a <span class="math inline">\(\operatorname{BeginBallot}(b, d)\)</span> message from <span class="math inline">\(p\)</span> with <span class="math inline">\(b &lt; \operatorname{nextBal}(q)\)</span>, then he sent <span class="math inline">\(p\)</span> a message containing <span class="math inline">\(\operatorname{nextBal}(q)\)</span>. Priest <span class="math inline">\(p\)</span> would then initiate a new ballot with a larger ballot number.</p><p>Let's assume that the following condition is met starting from time T:</p><ul><li>A messenger who did not leave the Chamber would always deliver a message within 4 minutes, and a priest who remained in the Chamber would always perform an action within 7 minutes of the event that caused the action.</li><li>No priest or message exits.</li><li><span class="math inline">\(p\)</span> is the only priest initiating ballots.</li></ul><table><thead><tr class="header"><th style="text-align: left;">Time</th><th style="text-align: left;">Event</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">T</td><td style="text-align: left;"><span class="math inline">\(p\)</span> starts executing step 1.</td></tr><tr class="even"><td style="text-align: left;">T + 7m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> sends a <span class="math inline">\(\operatorname{NextBallot}(b1)\)</span> message to some set of priests.</td></tr><tr class="odd"><td style="text-align: left;">T + 11m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> receives a <span class="math inline">\(\operatorname{NextBallot}(b1)\)</span> message from <span class="math inline">\(p\)</span>.</td></tr><tr class="even"><td style="text-align: left;">T + 18m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> sends a <span class="math inline">\(\operatorname{LastVote}(b1, v)\)</span> message to <span class="math inline">\(p\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">T + 22m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> receives a <span class="math inline">\(\operatorname{LastVote}(b1, v)\)</span> message from <span class="math inline">\(q\)</span>.</td></tr><tr class="even"><td style="text-align: left;">T + 29m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> sends a <span class="math inline">\(\operatorname{BeginBallot}(b1, d)\)</span> message to <span class="math inline">\(q\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">T + 33m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> receives a <span class="math inline">\(\operatorname{BeginBallot}(b1, d)\)</span> message from <span class="math inline">\(p\)</span>.</td></tr><tr class="even"><td style="text-align: left;">T + 40m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> sends a message containing <span class="math inline">\(\operatorname{nextBal}(q)\)</span> to <span class="math inline">\(p\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">T + 44m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> receives a message containing <span class="math inline">\(\operatorname{nextBal}(q)\)</span> from <span class="math inline">\(q\)</span>.</td></tr><tr class="even"><td style="text-align: left;">T + 51m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> initiates a new ballot with a larger ballot number <span class="math inline">\(b2\)</span>.</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;"><span class="math inline">\(p\)</span> sends a <span class="math inline">\(\operatorname{NextBallot}(b2)\)</span> message.</td></tr><tr class="even"><td style="text-align: left;">T + 55m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> receives a <span class="math inline">\(\operatorname{NextBallot}(b2)\)</span> message from <span class="math inline">\(p\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">T + 62m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> sends a <span class="math inline">\(\operatorname{LastVote}(b2, v)\)</span> message to <span class="math inline">\(p\)</span>.</td></tr><tr class="even"><td style="text-align: left;">T + 66m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> receives a <span class="math inline">\(\operatorname{LastVote}(b2, v)\)</span> message from <span class="math inline">\(q\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">T + 73m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> sends a <span class="math inline">\(\operatorname{BeginBallot}(b2, d)\)</span> message to <span class="math inline">\(q\)</span>.</td></tr><tr class="even"><td style="text-align: left;">T + 77m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> receives a <span class="math inline">\(\operatorname{BeginBallot}(b2, d)\)</span> message from <span class="math inline">\(p\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">T + 84m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> sends a <span class="math inline">\(\operatorname{Voted}(b2, q)\)</span> message to <span class="math inline">\(p\)</span>.</td></tr><tr class="even"><td style="text-align: left;">T + 88m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> receives a <span class="math inline">\(\operatorname{Voted}(b2, q)\)</span> message from <span class="math inline">\(q\)</span>.</td></tr><tr class="odd"><td style="text-align: left;">T + 95m</td><td style="text-align: left;"><span class="math inline">\(p\)</span> writes <span class="math inline">\(d\)</span> in his ledger.</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;"><span class="math inline">\(p\)</span> sends a <span class="math inline">\(\operatorname{Success}(d)\)</span> message to every priest.</td></tr><tr class="odd"><td style="text-align: left;">T + 99m</td><td style="text-align: left;"><span class="math inline">\(q\)</span> receives a <span class="math inline">\(\operatorname{Success}(d)\)</span> message.</td></tr></tbody></table><h4 id="presidential-selection-requirement">Presidential Selection Requirement</h4><p>Presidential selection requirement: If no one entered or left the Chamber, then after T minutes exactly one priest in the Chamber would consider himself to be the president.</p><p>The Paxons chose as president the priest whose name was last in alphabetical order among the names of all priests in the Chamber, though we don't know exactly how this was done. The presidential selection requirement would have been satisfied if a priest in the Chamber sent a message containing his name to every other priest at least once every T − 11 minutes, and a priest considered himself to be president iff he received no message from a "higher-named" priest for T minutes.</p><h2 id="the-multi-decree-parliament">The Multi-Decree Parliament</h2><p>Logically, the parliamentary protocol used a separate instance of the complete Synod protocol for each decree number. This raises two questions:</p><ul><li>What criteria should be used to determine the unique number for every Synod instance?<ul><li>The number are assigned in a monotonically increasing order, incrementing by one with each new instance.</li><li>When a priest is selected as president, he carries out the first two steps of the Synod protocol for all instances.</li><li>Subsequently, he chooses the decree with the lowest number that he is still free to choose, and he performs step 3 for that decree number (instance of the Synod protocol) to try to pass the decree.</li></ul></li><li>How to to establish the sequence of various Synod instances?<ul><li>For further details, please refer to the 'Ordering of Decrees' section.</li></ul></li></ul><h3 id="the-protocol">The Protocol</h3><p>The following modifications to this simple protocol lead to the actual Paxon Parliament’s protocol:</p><ul><li>A single president was selected for all these instances, and he performed the first two steps of the protocol just once. The key to deriving the parliamentary protocol is the observation that, in the Synod protocol, the president does not choose the decree or the quorum until step 3. A newly elected president <span class="math inline">\(p\)</span> can send to some set of legislators a single message that serves as the <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message for all instances of the Synod protocol. (There are an infinite number of instances - one for each decree number.) A legislator <span class="math inline">\(q\)</span> can reply with a single message that serves as the <span class="math inline">\(\operatorname{LastVote}\)</span> messages for step 2 of all instances of the Synod protocol. This message contains only a finite amount of information, since <span class="math inline">\(q\)</span> can have voted in only a finite number of instances.</li><li>There is no reason to go through the Synod protocol for a decree number whose outcome is already known. Therefore, if a newly elected president <span class="math inline">\(p\)</span> has all decrees with numbers less than or equal to <span class="math inline">\(n\)</span> written in his ledger, then he sends a <span class="math inline">\(\operatorname{NextBallot}(b, n)\)</span> message that serves as a <span class="math inline">\(\operatorname{NextBallot}(b)\)</span> message in all instances of the Synod protocol for decree numbers larger than <span class="math inline">\(n\)</span>. In his response to this message, legislator <span class="math inline">\(q\)</span> informs <span class="math inline">\(p\)</span> of all decrees numbered greater than <span class="math inline">\(n\)</span> that already appear in <span class="math inline">\(q\)</span>'s ledger (in addition to sending the usual <span class="math inline">\(\operatorname{LastVote}\)</span> information for decrees not in his ledger), and he asks <span class="math inline">\(p\)</span> to send him any decrees numbered <span class="math inline">\(n\)</span> or less that are not in his ledger.</li><li>Suppose decrees 125 and 126 are introduced late Friday afternoon, decree 126 is passed and is written in one or two ledgers, but before anything else happens, the legislators all go home for the weekend. Suppose also that the following Monday, <span class="math inline">\(\Delta \phi \omega \rho \kappa\)</span> is elected the new president and learns about decree 126, but she has no knowledge of decree 125 because the previous president and all legislators who had voted for it are still out of the Chamber. She will hold a ballot that passes decree 126, which leaves a gap in the ledgers. Assigning number 125 to a new decree would cause it to appear earlier in the ledger than decree 126, which had been passed the previous week. Passing decrees out of order in this way might cause confusion - for example, if the citizen who proposed the new decree did so because he knew decree 126 had already passed. Instead, <span class="math inline">\(\Delta \phi \omega \rho \kappa\)</span> would attempt to pass a traditional decree that made absolutely no difference to anyone in Paxos. In general, a new president would fill any gaps in his ledger by passing the "olive-day" decree (The ides of February is national olive day).</li></ul><p>You can find the specification in my other post <a href="https://clcanny.github.io/2023/07/24/computer-science/programming-language/tla+/implementing-multi-decree-parliament-in-tla/">Implementing Multi-Decree Parliament In TLA+</a>.</p><h3 id="properties-of-the-protocol">Properties of the Protocol</h3><h4 id="the-ordering-of-decrees">The Ordering of Decrees</h4><p>Balloting could take place concurrently for many different decree numbers, with ballots initiated by different legislators - each thinking he was president when he initiated the ballot. We cannot say precisely in what order decrees would be passed, especially without knowing how a president was selected.</p><ul><li>A decree was said to to be proposed when it was chosen by the president in <strong>step 3</strong> of the corresponding instance of the Synod protocol.</li><li>The decree was said to be <strong>passed</strong> when it was written for the <strong>first time</strong> in a ledger.</li></ul><p>If decrees <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are important and decree <span class="math inline">\(A\)</span> was passed before decree <span class="math inline">\(B\)</span> was proposed, then <span class="math inline">\(A\)</span> has a lower decree number than <span class="math inline">\(B\)</span>.</p><ul><li>Before a president could propose any new decrees, he had to learn from all the members of a majority set what decrees they had voted for.</li><li>Any decree that had already been passed must have been voted for by at least one legislator in the majority set.</li><li>Therefore, the president must have learned about all previously passed decrees before initiating any new decree.</li><li>The president would not fill a gap in the ledgers with an important decree—that is, with any decree other than the "olive-day" decree.</li><li>He would also not propose decrees out of order.</li></ul><h4 id="behind-closed-doors">Behind Closed Doors</h4><h3 id="further-developments">Further Developments</h3><h4 id="picking-a-president">Picking a President</h4><h4 id="long-ledgers">Long Ledgers</h4><h4 id="bureaucrats">Bureaucrats</h4><p>As Paxos prospered, legislators became very busy. Parlia- ment could no longer handle all details of government, so a bureaucracy was established.</p><ul><li>To prevent such confusion, the Paxons had to guarantee that a position could be held by at most one bureaucrat at any time. To do this, a president included as part of each decree the time and date when it was proposed.</li><li>A bureaucrat was appointed for a short term, so he could be replaced quickly — for example, if he left the island. Parliament would pass a decree to extend the bureaucrat's term if he was doing a satisfactory job.</li><li>The following out-of-order proposal times are easily prevented because the parliamentary protocol satisfies this property: If two decrees are passed by different presidents, then one of the presidents proposed his decree after learning that the other decree had been proposed.</li></ul><p>2854: 9:45 9 Apr 78 - <span class="math inline">\(\Phi \rho \alpha \nu \sigma \epsilon \zeta\)</span> is wine taster for 2 months.</p><p>2855: 9:20 9 Apr 78 - <span class="math inline">\(\Pi \nu v \epsilon \lambda \breve{l}\)</span> is wine taster for 1 month.</p><h4 id="learning-the-law">Learning the Law</h4><p>Monotonicity condition: If one inquiry precedes a second inquiry, then the second inquiry cannot reveal an earlier state of the law than the first.</p><p>Initially, the monotonicity condition was achieved by passing a decree for each inquiry. If <span class="math inline">\(\Sigma \partial \nu \breve{\iota} \delta \epsilon \rho\)</span> wanted to know the current tax on olives, he would get Parlia- ment to pass a decree such as "87: Citizen <span class="math inline">\(\Sigma \partial \nu \breve{\iota} \delta \epsilon \rho\)</span> is reading the law". He would then read any ledger complete at least through decree 86 to learn the olive tax as of that decree. If citizen <span class="math inline">\(\Gamma \rho \epsilon \epsilon \varsigma\)</span> then inquired about the olive tax, the decree for his inquiry was proposed after decree 87 was passed, so the decree-ordering property implies that it received a decree number greater than 87.</p><h4 id="dishonest-legislators-and-honest-mistakes">Dishonest Legislators and Honest Mistakes</h4><h4 id="choosing-new-legislators">Choosing New Legislators</h4><h2 id="reference">Reference</h2><ul><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/The-Part-Time-Parliament.pdf">The Part-Time Parliament</a></li><li><a href="https://lamport.azurewebsites.net/pubs/paxos-simple.pdf">Paxos Made Simple</a></li><li><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf">Fast Paxos</a></li><li><a href="https://lamport.azurewebsites.net/tla/paxos-algorithm.html">The Paxos Algorithm or How to Win a Turing Award</a></li><li><a href="https://clcanny.github.io/2023/07/24/computer-science/programming-language/tla+/implementing-multi-decree-parliament-in-tla/">Implementing Multi-Decree Parliament In TLA+</a></li><li><a href="https://www.usenix.org/system/files/conference/atc14/atc14-paper-ongaro.pdf">In Search of an Understandable Consensus Algorithm</a></li><li><a href="https://matklad.github.io/2020/11/01/notes-on-paxos.html">matklad: Notes on Paxos</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Consensus</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Explore C++20 Coroutine</title>
    <link href="/2022/07/30/computer-science/programming-language/c++/explore-c++-20-coroutine/"/>
    <url>/2022/07/30/computer-science/programming-language/c++/explore-c++-20-coroutine/</url>
    
    <content type="html"><![CDATA[<h1 id="测试环境">测试环境</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker run -it gcc:12.2.0-bullseye g++ --version</span><br>g++ (GCC) 12.2.0<br><span class="hljs-comment"># docker run -it gcc:12.2.0-bullseye cat /etc/os-release</span><br>PRETTY_NAME=<span class="hljs-string">&quot;Debian GNU/Linux 11 (bullseye)&quot;</span><br>NAME=<span class="hljs-string">&quot;Debian GNU/Linux&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;11&quot;</span><br>VERSION=<span class="hljs-string">&quot;11 (bullseye)&quot;</span><br>VERSION_CODENAME=bullseye<br>ID=debian<br>HOME_URL=<span class="hljs-string">&quot;https://www.debian.org/&quot;</span><br>SUPPORT_URL=<span class="hljs-string">&quot;https://www.debian.org/support&quot;</span><br>BUG_REPORT_URL=<span class="hljs-string">&quot;https://bugs.debian.org/&quot;</span><br></code></pre></td></tr></table></figure><h1 id="用状态机实现-coroutine">用状态机实现 Coroutine</h1><h2 id="概述">概述</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ -std=c++20 -fcoroutines -fno-exceptions -fno-asynchronous-unwind-tables -ggdb -O0 main.cc -o main.o</span><br><span class="hljs-comment">// objdump -M intel,intel-mnemonic --demangle=auto --no-recurse-limit --no-show-raw-insn -d main.o</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ReturnObject</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">InitialSuspendNever</span> : <span class="hljs-keyword">public</span> std::suspend_never &#123; <span class="hljs-type">char</span> c; &#125;;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">YieldSuspendAlways</span> : <span class="hljs-keyword">public</span> std::suspend_always &#123; <span class="hljs-type">char</span> c; &#125;;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">FinalSuspendAlways</span> : <span class="hljs-keyword">public</span> std::suspend_always &#123; <span class="hljs-type">char</span> c; &#125;;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span> &#123;<br>    <span class="hljs-function">ReturnObject <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        .h_ = std::coroutine_handle&lt;promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-function">InitialSuspendNever <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>    <span class="hljs-function">YieldSuspendAlways <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span> </span>&#123;<br>      value_ = value;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span> </span>&#123;<br>      value_ = value;<br>    &#125;<br>    <span class="hljs-function">FinalSuspendAlways <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_;<br>  &#125;;<br>  std::coroutine_handle&lt;promise_type&gt; h_;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CoAwaitSuspendAlways</span> : <span class="hljs-keyword">public</span> std::suspend_always &#123; <span class="hljs-type">char</span> c; &#125;;<br><span class="hljs-function">ReturnObject <span class="hljs-title">counter</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">CoAwaitSuspendAlways</span><span class="hljs-params">()</span></span>;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_a = <span class="hljs-number">0x12345678</span>;<br>  <span class="hljs-keyword">co_yield</span> value_a;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_b = <span class="hljs-number">0x90ABCDEF</span>;<br>  <span class="hljs-keyword">co_yield</span> value_b;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_c = <span class="hljs-number">0x98765432</span>;<br>  <span class="hljs-keyword">co_return</span> value_c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> h = <span class="hljs-built_in">counter</span>().h_;<br>  <span class="hljs-keyword">auto</span>&amp; promise = h.<span class="hljs-built_in">promise</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  <span class="hljs-built_in">h</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  <span class="hljs-built_in">h</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  <span class="hljs-built_in">h</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  h.<span class="hljs-built_in">destroy</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --symbols --wide main.o | grep -E &quot;Frame&quot; | awk &#x27;&#123;print $NF&#125;&#x27; | sort | uniq</span><br>_Z7counterPZ7countervE17_Z7counterv.Frame.actor<br>_Z7counterPZ7countervE17_Z7counterv.Frame.destroy<br><br>(gdb) b _Z7counterPZ7countervE17_Z7counterv.Frame.actor<br>(gdb) r<br>(gdb) ptype *frame_ptr<br>// sizeof(*frame_ptr) = 56 = 0x38<br><span class="hljs-built_in">type</span> = struct _Z7counterv.Frame &#123;<br>  // offset = 0 = 0x0<br>  void (*_Coro_resume_fn)(_Z7counterv.Frame *);<br>  // offset = 8 = 0x8<br>  void (*_Coro_destroy_fn)(_Z7counterv.Frame *);<br>  // offset = 16 = 0x10<br>  // ReturnObject::promise_type<br>  std::__n4861::__coroutine_traits_impl&lt;ReturnObject, void&gt;::promise_type _Coro_promise;<br>  // offset = 24 = 0x18<br>  std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt; _Coro_self_handle;<br>  // offset = 32 = 0x20<br>  // The index represents the progress of the coroutine through its <span class="hljs-keyword">function</span> body.<br>  unsigned short _Coro_resume_index;<br>  // offset = 34 = 0x22<br>  bool _Coro_frame_needs_free;<br>  // offset = 35 = 0x23<br>  ReturnObject::InitialSuspendNever Is_1_1;<br>  // offset = 36 = 0x24<br>  unsigned int value_a_1_2;<br>  // offset = 40 = 0x28<br>  unsigned int value_b_1_2;<br>  // offset = 44 = 0x2c<br>  unsigned int value_c_1_2;<br>  // offset = 48 = 0x30<br>  CoAwaitSuspendAlways Aw0_2_3;<br>  // offset = 49 = 0x31<br>  ReturnObject::YieldSuspendAlways Yd1_2_4;<br>  // offset = 50 = 0x32<br>  ReturnObject::YieldSuspendAlways Yd2_2_5;<br>  // offset = 51 = 0x33<br>  ReturnObject::FinalSuspendAlways Fs_1_6;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401196 &lt;counter()&gt;:<br>  ; Save address of previous stack frame.<br>  401196:   push   rbp<br>  ; RBP/EBP is extended base pointer,<br>  ; it points to the bottom of current stack frame.<br>  401197:   mov    rbp,rsp<br>  ; RBX is a callee-saved register.<br>  40119a:   push   rbx<br>  ; RSP/ESP is extended stack pointer,<br>  ; it points to the top of current stack frame.<br>  ; Notice stack frame grows from higher address to lower address.<br>  ; Reserve 40 bytes for local variables.<br>  40119b:   sub    rsp,0x18<br>  40119f:   mov    QWORD PTR [rbp-0x18],0x0<br>  4011a7:   mov    BYTE PTR [rbp-0x19],0x0<br>  4011ab:   mov    BYTE PTR [rbp-0x1a],0x0<br><br>  ; The co_await operator ensures the current state of a function<br>  ; is bundled up somewhere on the heap and creates a callable object<br>  ; whose invocation continues execution of the current function.<br>  ; The current state is coroutine frame.<br>  ; The callable object is of type std::coroutine_handle&lt;&gt;.<br>  ; Init coroutine frame:<br>  ; Allocate 56 bytes.<br>  4011af:   mov    eax,0x38<br>  ; RDI is the first argument of operator new.<br>  4011b4:   mov    rdi,rax<br>  4011b7:   call   401060 &lt;operator new(unsigned long)@plt&gt;<br>  ; RAX is the result of operator new.<br>  4011bc:   mov    QWORD PTR [rbp-0x18],rax<br>  ; Set Frame::_Coro_frame_needs_free to true.<br>  4011c0:   mov    rax,QWORD PTR [rbp-0x18]<br>  4011c4:   mov    BYTE PTR [rax+0x22],0x1<br>  ; Set Frame::_Coro_resume_fn to &lt;counter(_Z7counterv.Frame *)&gt;.<br>  4011c8:   mov    rax,QWORD PTR [rbp-0x18]<br>  4011cc:   mov    QWORD PTR [rax],0x401212<br>  ; Set Frame::_Coro_destroy_fn to &lt;counter(_Z7counterv.Frame *)&gt;.<br>  4011d3:   mov    rax,QWORD PTR [rbp-0x18]<br>  4011d7:   mov    QWORD PTR [rax+0x8],0x401534<br>  ; Prepare return value.<br>  ; Call promise_type::get_return_object() with this = &amp;Frame::_Coro_promise.<br>  4011df:   mov    rax,QWORD PTR [rbp-0x18]<br>  4011e3:   add    rax,0x10<br>  4011e7:   mov    rdi,rax<br>  4011ea:   call   401708 &lt;ReturnObject::promise_type::get_return_object()&gt;<br>  4011ef:   mov    rbx,rax<br>  ; Set Frame::_Coro_resume_index to 0x0.<br>  4011f2:   mov    rax,QWORD PTR [rbp-0x18]<br>  4011f6:   mov    WORD PTR [rax+0x20],0x0<br>  ; Call actor.<br>  4011fc:   mov    rax,QWORD PTR [rbp-0x18]<br>  401200:   mov    rdi,rax<br>  401203:   call   401212 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]&gt;<br>  401208:   nop<br>  ; Put return value into RAX.<br>  401209:   mov    rax,rbx<br>  40120c:   mov    rbx,QWORD PTR [rbp-0x8]<br>  401210:   leave<br>  401211:   ret<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401212 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]&gt;:<br>  ; Save address of previous stack frame.<br>  401212:   push   rbp<br>  ; RBP/EBP is extended base pointer,<br>  ; it points to the bottom of current stack frame.<br>  401213:   mov    rbp,rsp<br>  ; RBX is a callee-saved register.<br>  401216:   push   rbx<br>  ; RSP/ESP is extended stack pointer,<br>  ; it points to the top of current stack frame.<br>  ; Notice stack frame grows from higher address to lower address.<br>  ; Reserve 40 bytes for local variables.<br>  401217:   sub    rsp,0x28<br><br>  ; RDI is the first argument of function actor,<br>  ; which is coroutine frame.<br>  40121b:   mov    QWORD PTR [rbp-0x28],rdi<br><br>  40121f:   mov    rax,QWORD PTR [rbp-0x28]<br>  ; Test if Frame::_Coro_resume_index is an even number.<br>  401223:   movzx  eax,WORD PTR [rax+0x20]<br>  ; If Frame::_Coro_resume_index is an even number,<br>  ; then jump to 0x40124d.<br>  401227:   and    eax,0x1<br>  40122a:   test   ax,ax<br>  40122d:   je     40124d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x3b&gt;<br><br>  ; Else if Frame::_Coro_resume_index is an odd number.<br>  ; Please notice Frame::_Coro_frame_needs_free is always true.<br>  40122f:   mov    rax,QWORD PTR [rbp-0x28]<br>  401233:   movzx  eax,WORD PTR [rax+0x20]<br>  ; Throw exception if Frame::_Coro_resume_index &gt; 0xb.<br>  401237:   movzx  eax,ax<br>  40123a:   cmp    eax,0xb<br>  40123d:   ja     40124b &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x39&gt;<br>  ; Jump to a table entry if Frame::_Coro_resume_index &lt;= 0xb.<br>  ;           [useless] [useful]<br>  ; 0x402008: 40124b    40150f<br>  ; 0x402018: 40124b    4012e1<br>  ; 0x402028: 40124b    401347<br>  ; 0x402038: 40124b    4013d0<br>  ; 0x402048: 40124b    401459<br>  ; 0x402058: 40124b    4014fb<br>  40123f:   mov    eax,eax<br>  401241:   mov    rax,QWORD PTR [rax*8+0x402008]<br>  401249:   jmp    rax<br>  ; Otherwise, raise invalid opcode exception.<br>  40124b:   ud2<br><br>  ; If Frame::_Coro_resume_index is an even number.<br>  40124d:   mov    rax,QWORD PTR [rbp-0x28]<br>  ; Throw exception if Frame::_Coro_resume_index &gt; 0xa.<br>  401251:   movzx  eax,WORD PTR [rax+0x20]<br>  401255:   movzx  eax,ax<br>  401258:   cmp    eax,0xa<br>  40125b:   ja     4012ad &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x9b&gt;<br>  ; Jump to a table entry if Frame::_Coro_resume_index &lt;= 0xa.<br>  ;           [useful] [useless]<br>  ; 0x402068: 401269   4012ad<br>  ; 0x402078: 4012e6   4012ad<br>  ; 0x402088: 40134c   4012ad<br>  ; 0x402098: 4013d5   4012ad<br>  ; 0x4020a8: 40145e   4012ad<br>  ; 0x4020b8: 4014fd<br>  40125d:   mov    eax,eax<br>  40125f:   mov    rax,QWORD PTR [rax*8+0x402068]<br>  401267:   jmp    rax<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x0.<br>  401269:   mov    rbx,QWORD PTR [rbp-0x28]<br>  ; Call std::coroutine_handle&lt;Promise&gt;::from_address(void* addr)<br>  ; with addr = &amp;Frame.<br>  ; frame_address creates a coroutine_handle from a null pointer value or<br>  ; an underlying address of another coroutine_handle.<br>  ; Return type of from_address is std::coroutine_handle&lt;Promise&gt;.<br>  ; The underlying address of return value is addr.<br>  40126d:   mov    rax,QWORD PTR [rbp-0x28]<br>  401271:   mov    rdi,rax<br>  401274:   call   4017ba &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::from_address(void*)&gt;<br>  ; RAX is return value of func<br>  ; std::coroutine_handle&lt;Promise&gt;::from_address(void* addr),<br>  ; which is equal to addr, which is equal to &amp;Frame.<br>  ; RBX is set to &amp;Frame at 0x401269.<br>  ; Set Frame::_Coro_self_handle::_M_fr_ptr to &amp;Frame.<br>  401279:   mov    QWORD PTR [rbx+0x18],rax<br>  ; Call ReturnObject::promise_type::initial_suspend() with<br>  ; this = &amp;Frame::_Coro_promise.<br>  40127d:   mov    rax,QWORD PTR [rbp-0x28]<br>  401281:   add    rax,0x10<br>  401285:   mov    rbx,QWORD PTR [rbp-0x28]<br>  401289:   mov    rdi,rax<br>  40128c:   call   401722 &lt;ReturnObject::promise_type::initial_suspend()&gt;<br>  ; RBX is set to &amp;Frame at 0x401285.<br>  ; AL is RAX&#x27;s 8 low bits, which is the return value of initial_suspend().<br>  ; Set Frame::Is_1_1 to return value of initial_suspend().<br>  401291:   mov    BYTE PTR [rbx+0x23],al<br>  ; Call std::__n4861::suspend_never::await_ready() with this = &amp;Frame::Is_1_1.<br>  401294:   mov    rax,QWORD PTR [rbp-0x28]<br>  401298:   add    rax,0x23<br>  40129c:   mov    rdi,rax<br>  40129f:   call   4016dc &lt;std::__n4861::suspend_never::await_ready() const&gt;<br>  ; Test if return value is true.<br>  ; await_ready is an optimization.<br>  ; If it returns true, then co_await does not suspend the function.<br>  ; In this example, suspend_never::await_ready() will always return true.<br>  4012a4:   xor    eax,0x1<br>  4012a7:   test   al,al<br>  ; Always skip this branch.<br>  4012a9:   jne    4012af &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x9d&gt;<br>  ; Always execute this branch.<br>  4012ab:   jmp    4012e6 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0xd4&gt;<br>  ; Raise invalid opcode exception.<br>  4012ad:   ud2<br><br>  ; Always skip the following code.<br>  ; Set Frame::_Coro_resume_index to 0x2.<br>  4012af:   mov    rax,QWORD PTR [rbp-0x28]<br>  4012b3:   mov    WORD PTR [rax+0x20],0x2<br>  4012b9:   mov    rax,QWORD PTR [rbp-0x28]<br>  ; Set RBX to &amp;Frame::Is_1_1.<br>  4012bd:   lea    rbx,[rax+0x23]<br>  ; Call coroutine_handle::operator()() with this = &amp;Frame::_Coro_self_handle.<br>  4012c1:   mov    rax,QWORD PTR [rbp-0x28]<br>  4012c5:   add    rax,0x18<br>  4012c9:   mov    rdi,rax<br>  4012cc:   call   401798 &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::operator std::__n4861::coroutine_handle&lt;void&gt;() const&gt;<br>  4012d1:   mov    rsi,rax<br>  ; Call suspend_never::await_suspend(handle) with this = &amp;Frame::Is_1_1<br>  ; and handle = return value of coroutine_handle::operator()(&amp;Frame::_Coro_self_handle).<br>  4012d4:   mov    rdi,rbx<br>  4012d7:   call   4016ec &lt;std::__n4861::suspend_never::await_suspend(std::__n4861::coroutine_handle&lt;void&gt;) const&gt;<br>  4012dc:   jmp    40152d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x31b&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x3.<br>  4012e1:   jmp    401510 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x2fe&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x2.<br>  ; Call suspend_never::await_resume() with this = &amp;Frame::Is_1_1.<br>  4012e6:   mov    rax,QWORD PTR [rbp-0x28]<br>  4012ea:   add    rax,0x23<br>  4012ee:   mov    rdi,rax<br>  4012f1:   call   4016fc &lt;std::__n4861::suspend_never::await_resume() const&gt;<br>  ; Set Frame::Aw0_2_3 to 0x0.<br>  4012f6:   mov    rax,QWORD PTR [rbp-0x28]<br>  4012fa:   mov    BYTE PTR [rax+0x30],0x0<br>  ; Call suspend_always::await_ready() with this = &amp;Frame::Aw0_2_3.<br>  4012fe:   mov    rax,QWORD PTR [rbp-0x28]<br>  401302:   add    rax,0x30<br>  401306:   mov    rdi,rax<br>  401309:   call   4016b0 &lt;std::__n4861::suspend_always::await_ready() const&gt;<br>  ; Test if return value is true.<br>  40130e:   xor    eax,0x1<br>  401311:   test   al,al<br>  ; Always skip this branch.<br>  401313:   je     40134c &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x13a&gt;<br>  ; Always execute this branch.<br>  ; Set Frame::_Coro_resume_index to 0x4.<br>  401315:   mov    rax,QWORD PTR [rbp-0x28]<br>  401319:   mov    WORD PTR [rax+0x20],0x4<br>  ; Set RBX to &amp;Frame::Aw0_2_3.<br>  40131f:   mov    rax,QWORD PTR [rbp-0x28]<br>  401323:   lea    rbx,[rax+0x30]<br>  ; Call coroutine_handle::operator()() with this = &amp;Frame::_Coro_self_handle.<br>  401327:   mov    rax,QWORD PTR [rbp-0x28]<br>  40132b:   add    rax,0x18<br>  40132f:   mov    rdi,rax<br>  401332:   call   401798 &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::operator std::__n4861::coroutine_handle&lt;void&gt;() const&gt;<br>  ; Call suspend_always::await_suspend(handle) with this = &amp;Frame::Aw0_2_3<br>  ; and handle = return value of coroutine_handle::operator()(&amp;Frame::_Coro_self_handle).<br>  401337:   mov    rsi,rax<br>  40133a:   mov    rdi,rbx<br>  40133d:   call   4016c0 &lt;std::__n4861::suspend_always::await_suspend(std::__n4861::coroutine_handle&lt;void&gt;) const&gt;<br>  401342:   jmp    40152d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x31b&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x5.<br>  401347:   jmp    401510 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x2fe&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x4.<br>  ; Call suspend_always::await_resume() with this = &amp;Frame::Aw0_2_3.<br>  40134c:   mov    rax,QWORD PTR [rbp-0x28]<br>  401350:   add    rax,0x30<br>  401354:   mov    rdi,rax<br>  401357:   call   4016d0 &lt;std::__n4861::suspend_always::await_resume() const&gt;<br>  ; Set value_a_1_2 to 0x12345678.<br>  40135c:   mov    rax,QWORD PTR [rbp-0x28]<br>  401360:   mov    DWORD PTR [rax+0x24],0x12345678<br>  ; Call promise_type::yield_value(value) with this = &amp;Frame::_Coro_promise<br>  ; and value = value_a_1_2.<br>  401367:   mov    rax,QWORD PTR [rbp-0x28]<br>  40136b:   lea    rdx,[rax+0x10]<br>  40136f:   mov    rax,QWORD PTR [rbp-0x28]<br>  401373:   mov    eax,DWORD PTR [rax+0x24]<br>  401376:   mov    rbx,QWORD PTR [rbp-0x28]<br>  40137a:   mov    esi,eax<br>  40137c:   mov    rdi,rdx<br>  40137f:   call   401732 &lt;ReturnObject::promise_type::yield_value(unsigned int)&gt;<br>  ; RBX is set to &amp;Frame at 0x401376.<br>  ; Set Frame::Yd1_2_4 to return value of yield_value(unsigned int).<br>  401384:   mov    BYTE PTR [rbx+0x31],al<br>  ; Call suspend_always::await_ready() with this = &amp;Frame::Yd1_2_4.<br>  401387:   mov    rax,QWORD PTR [rbp-0x28]<br>  40138b:   add    rax,0x31<br>  40138f:   mov    rdi,rax<br>  401392:   call   4016b0 &lt;std::__n4861::suspend_always::await_ready() const&gt;<br>  ; Test if return value is true.<br>  401397:   xor    eax,0x1<br>  40139a:   test   al,al<br>  ; Always skip this branch.<br>  40139c:   je     4013d5 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x1c3&gt;<br>  ; Always execute this branch.<br>  ; Set Frame::_Coro_resume_index to 0x6.<br>  40139e:   mov    rax,QWORD PTR [rbp-0x28]<br>  4013a2:   mov    WORD PTR [rax+0x20],0x6<br>  ; Call suspend_always::await_suspend(handle) with this = &amp;Frame::Yd1_2_4<br>  ; and handle = return value of coroutine_handle::operator()(&amp;Frame::_Coro_self_handle).<br>  4013a8:   mov    rax,QWORD PTR [rbp-0x28]<br>  4013ac:   lea    rbx,[rax+0x31]<br>  4013b0:   mov    rax,QWORD PTR [rbp-0x28]<br>  4013b4:   add    rax,0x18<br>  4013b8:   mov    rdi,rax<br>  4013bb:   call   401798 &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::operator std::__n4861::coroutine_handle&lt;void&gt;() const&gt;<br>  4013c0:   mov    rsi,rax<br>  4013c3:   mov    rdi,rbx<br>  4013c6:   call   4016c0 &lt;std::__n4861::suspend_always::await_suspend(std::__n4861::coroutine_handle&lt;void&gt;) const&gt;<br>  4013cb:   jmp    40152d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x31b&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x7.<br>  4013d0:   jmp    401510 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x2fe&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x6.<br>  ; Call suspend_always::await_resume() with this = &amp;Frame::Yd1_2_4.<br>  4013d5:   mov    rax,QWORD PTR [rbp-0x28]<br>  4013d9:   add    rax,0x31<br>  4013dd:   mov    rdi,rax<br>  4013e0:   call   4016d0 &lt;std::__n4861::suspend_always::await_resume() const&gt;<br>  ; Set value_b_1_2 to 0x90abcdef.<br>  4013e5:   mov    rax,QWORD PTR [rbp-0x28]<br>  4013e9:   mov    DWORD PTR [rax+0x28],0x90abcdef<br>  ; Call promise_type::yield_value(value) with this = &amp;Frame::_Coro_promise<br>  ; and value_b_1_2.<br>  4013f0:   mov    rax,QWORD PTR [rbp-0x28]<br>  4013f4:   lea    rdx,[rax+0x10]<br>  4013f8:   mov    rax,QWORD PTR [rbp-0x28]<br>  4013fc:   mov    eax,DWORD PTR [rax+0x28]<br>  4013ff:   mov    rbx,QWORD PTR [rbp-0x28]<br>  401403:   mov    esi,eax<br>  401405:   mov    rdi,rdx<br>  401408:   call   401732 &lt;ReturnObject::promise_type::yield_value(unsigned int)&gt;<br>  ; Set Frame::Yd2_2_5 to return value of yield_value(unsigned int).<br>  40140d:   mov    BYTE PTR [rbx+0x32],al<br>  ; Call suspend_always::await_ready() with this = &amp;Frame::Yd2_2_5.<br>  401410:   mov    rax,QWORD PTR [rbp-0x28]<br>  401414:   add    rax,0x32<br>  401418:   mov    rdi,rax<br>  40141b:   call   4016b0 &lt;std::__n4861::suspend_always::await_ready() const&gt;<br>  ; Test if return value is true.<br>  401420:   xor    eax,0x1<br>  401423:   test   al,al<br>  ; Always skip this branch.<br>  401425:   je     40145e &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x24c&gt;<br>  ; Always execute this branch.<br>  ; Call suspend_always::await_suspend(handle) with this = &amp;Frame::Yd2_2_5<br>  ; and handle = return value of coroutine_handle::operator()(&amp;Frame::_Coro_self_handle).<br>  401427:   mov    rax,QWORD PTR [rbp-0x28]<br>  40142b:   mov    WORD PTR [rax+0x20],0x8<br>  401431:   mov    rax,QWORD PTR [rbp-0x28]<br>  401435:   lea    rbx,[rax+0x32]<br>  401439:   mov    rax,QWORD PTR [rbp-0x28]<br>  40143d:   add    rax,0x18<br>  401441:   mov    rdi,rax<br>  401444:   call   401798 &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::operator std::__n4861::coroutine_handle&lt;void&gt;() const&gt;<br>  401449:   mov    rsi,rax<br>  40144c:   mov    rdi,rbx<br>  40144f:   call   4016c0 &lt;std::__n4861::suspend_always::await_suspend(std::__n4861::coroutine_handle&lt;void&gt;) const&gt;<br>  401454:   jmp    40152d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x31b&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x9.<br>  401459:   jmp    401510 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x2fe&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x8.<br>  ; Call suspend_always::await_resume() with this = &amp;Frame::Yd2_2_5.<br>  40145e:   mov    rax,QWORD PTR [rbp-0x28]<br>  401462:   add    rax,0x32<br>  401466:   mov    rdi,rax<br>  401469:   call   4016d0 &lt;std::__n4861::suspend_always::await_resume() const&gt;<br>  ; Set value_c_1_2 to 0x98765432.<br>  40146e:   mov    rax,QWORD PTR [rbp-0x28]<br>  401472:   mov    DWORD PTR [rax+0x2c],0x98765432<br>  ; Call promise_type::return_value(value) with this = &amp;Frame::_Coro_promise<br>  ; and value = value_c_1_2.<br>  401479:   mov    rax,QWORD PTR [rbp-0x28]<br>  40147d:   lea    rdx,[rax+0x10]<br>  401481:   mov    rax,QWORD PTR [rbp-0x28]<br>  401485:   mov    eax,DWORD PTR [rax+0x2c]<br>  401488:   mov    esi,eax<br>  40148a:   mov    rdi,rdx<br>  40148d:   call   40174e &lt;ReturnObject::promise_type::return_value(unsigned int)&gt;<br>  401492:   nop<br>  ; Set Frame::_Coro_resume_fn to nullptr.<br>  401493:   mov    rax,QWORD PTR [rbp-0x28]<br>  401497:   mov    QWORD PTR [rax],0x0<br>  ; Call promise_type::final_suspend() with this = &amp;Frame::_Coro_promise.<br>  40149e:   mov    rax,QWORD PTR [rbp-0x28]<br>  4014a2:   add    rax,0x10<br>  4014a6:   mov    rbx,QWORD PTR [rbp-0x28]<br>  4014aa:   mov    rdi,rax<br>  4014ad:   call   401766 &lt;ReturnObject::promise_type::final_suspend()&gt;<br>  ; RBX is set to &amp;Frame at 0x4014a6.<br>  ; Set Frame::Fs_1_6 to return value of final_suspend().<br>  4014b2:   mov    BYTE PTR [rbx+0x33],al<br>  ; Call suspend_always::await_ready() with this = &amp;Frame::Fs_1_6.<br>  4014b5:   mov    rax,QWORD PTR [rbp-0x28]<br>  4014b9:   add    rax,0x33<br>  4014bd:   mov    rdi,rax<br>  4014c0:   call   4016b0 &lt;std::__n4861::suspend_always::await_ready() const&gt;<br>  ; Test if return value is true.<br>  4014c5:   xor    eax,0x1<br>  4014c8:   test   al,al<br>  ; Always skip this branch.<br>  4014ca:   je     4014fd &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x2eb&gt;<br>  ; Always execute this branch.<br>  ; Set Frame::_Coro_resume_index to 0xa.<br>  4014cc:   mov    rax,QWORD PTR [rbp-0x28]<br>  4014d0:   mov    WORD PTR [rax+0x20],0xa<br>  ; Call suspend_always::await_suspend(handle) with this = &amp;Frame::Fs_1_6<br>  ; and handle = return value of coroutine_handle::operator()(&amp;Frame::_Coro_self_handle).<br>  4014d6:   mov    rax,QWORD PTR [rbp-0x28]<br>  4014da:   lea    rbx,[rax+0x33]<br>  4014de:   mov    rax,QWORD PTR [rbp-0x28]<br>  4014e2:   add    rax,0x18<br>  4014e6:   mov    rdi,rax<br>  4014e9:   call   401798 &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::operator std::__n4861::coroutine_handle&lt;void&gt;() const&gt;<br>  4014ee:   mov    rsi,rax<br>  4014f1:   mov    rdi,rbx<br>  4014f4:   call   4016c0 &lt;std::__n4861::suspend_always::await_suspend(std::__n4861::coroutine_handle&lt;void&gt;) const&gt;<br>  4014f9:   jmp    40152d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x31b&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0xb.<br>  4014fb:   jmp    401510 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x2fe&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0xa.<br>  ; Call suspend_always::await_resume() with this = &amp;Frame::Fs_1_6.<br>  4014fd:   mov    rax,QWORD PTR [rbp-0x28]<br>  401501:   add    rax,0x33<br>  401505:   mov    rdi,rax<br>  401508:   call   4016d0 &lt;std::__n4861::suspend_always::await_resume() const&gt;<br>  40150d:   jmp    401510 &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x2fe&gt;<br><br>  ; Execute the following code when Frame::_Coro_resume_index == 0x1.<br>  40150f:   nop<br>  ; Execute the following code when Frame::_Coro_resume_index == 0x3/0x5/0x7/0x9/0xb.<br>  ; Test if Frame::_Coro_frame_needs_free is true.<br>  401510:   mov    rax,QWORD PTR [rbp-0x28]<br>  401514:   movzx  eax,BYTE PTR [rax+0x22]<br>  401518:   movzx  eax,al<br>  40151b:   test   eax,eax<br>  ; Jump to 0x40152d if Frame::_Coro_frame_needs_free is false.<br>  40151d:   je     40152d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x31b&gt;<br>  ; Delete coroutine frame.<br>  40151f:   mov    rax,QWORD PTR [rbp-0x28]<br>  401523:   mov    rdi,rax<br>  401526:   call   401050 &lt;operator delete(void*)@plt&gt;<br>  40152b:   jmp    40152d &lt;counter(counter()::_Z7counterv.Frame*) [clone .actor]+0x31b&gt;<br>  40152d:   nop<br>  40152e:   mov    rbx,QWORD PTR [rbp-0x8]<br>  401532:   leave<br>  401533:   ret<br></code></pre></td></tr></table></figure><p>等价上述汇编代码的伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>  promise-type promise promise-constructor-arguments;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">co_await</span> promise.<span class="hljs-built_in">initial_suspend</span>();<br>    function-body<br>  &#125; <span class="hljs-built_in">catch</span> (...) &#123;<br>    <span class="hljs-keyword">if</span> (!initial-await-resume-called) &#123;<br>      <span class="hljs-keyword">throw</span>;<br>    &#125;<br>    promise.<span class="hljs-built_in">unhandled_exception</span>();<br>  &#125;<br><span class="hljs-keyword">final</span>-suspend:<br>  <span class="hljs-keyword">co_await</span> promise.<span class="hljs-built_in">final_suspend</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="coroutine-frame-是一个保存-coroutine-状态的栈">coroutine frame 是一个保存 coroutine 状态的栈</h2><p>C++20 的 coroutine 是无栈协程，相较于有栈协程，无栈协程不会在堆内存上开一块空间来伪装成调用栈，而是让编译器用一个结构体将参数和本地变量保存下来。<a href="https://github.com/gcc-mirror/gcc/blob/2fa8c4a659a19ec971c80704f48f96c13aae9ac3/gcc/cp/coroutines.cc#L4336">gcc-mirror/gcc: coroutines.cc</a> 有一段注释描述了 coroutine frame 的大致结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// We do something like this:</span><br><span class="hljs-comment">// declare a dummy coro frame.</span><br><span class="hljs-comment">// struct _R_frame &#123;</span><br><span class="hljs-comment">//  using handle_type = coro::coroutine_handle&lt;coro1::promise_type&gt;;</span><br><span class="hljs-comment">//  void (*_Coro_resume_fn)(_R_frame *);</span><br><span class="hljs-comment">//  void (*_Coro_destroy_fn)(_R_frame *);</span><br><span class="hljs-comment">//  coro1::promise_type _Coro_promise;</span><br><span class="hljs-comment">//  bool _Coro_frame_needs_free; free the coro frame mem if set.</span><br><span class="hljs-comment">//  bool _Coro_i_a_r_c; [dcl.fct.def.coroutine] / 5.3</span><br><span class="hljs-comment">//  short _Coro_resume_index;</span><br><span class="hljs-comment">//  handle_type _Coro_self_handle;</span><br><span class="hljs-comment">//  parameter copies (were required).</span><br><span class="hljs-comment">//  local variables saved (including awaitables)</span><br><span class="hljs-comment">//  (maybe) trailing space.</span><br></code></pre></td></tr></table></figure><h2 id="promise-是一个-coroutine-向-caller-传递数据的对象">promise 是一个 coroutine 向 caller 传递数据的对象</h2><ul><li><code>co_yield</code> 使 coroutine 调用 <code>promise_type::yield_value</code> 。</li><li><code>co_return</code> 使 coroutine 调用 <code>promise_type::return_value</code> 。</li><li><code>initial_suspend</code> / <code>final_suspend</code> 分别控制 coroutine 开始和结束时是否额外暂停一次。</li></ul><h2 id="coroutine_handle-是一个指向-coroutine-frame-的指针"><code>coroutine_handle</code> 是一个指向 coroutine frame 的指针</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">(gdb) b _Z7counterPZ7countervE17_Z7counterv.Frame.actor<br>(gdb) r<br>(gdb) ptype frame_ptr-&gt;_Coro_self_handle<br>struct std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;<br>[with _Promise = ReturnObject::promise_type] &#123;<br>  void *_M_fr_ptr;<br>&#125;;<br>(gdb) watch frame_ptr-&gt;_Coro_self_handle<br>Hardware watchpoint 2: frame_ptr-&gt;_Coro_self_handle<br>(gdb) c<br>Hardware watchpoint 2: frame_ptr-&gt;_Coro_self_handle<br>Old value = &#123;_M_fr_ptr = 0x0&#125;<br>New value = &#123;_M_fr_ptr = 0x1ab6eb0&#125;<br>(gdb) print frame_ptr<br>$1 = (_Z7counterv.Frame *) 0x1ab6eb0<br>(gdb) print &amp;frame_ptr-&gt;_Coro_resume_fn<br>$2 = (void (**)(_Z7counterv.Frame *)) 0x1ab6eb0<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">(gdb) b main.cc:47<br>(gdb) c<br>Breakpoint 3, main () at /usr/local/include/c++/12.2.0/main.cc:47<br>47    auto&amp; promise = h.promise();<br>(gdb) print h<br>$3 = &#123;_M_fr_ptr = 0x1ab6eb0&#125;<br></code></pre></td></tr></table></figure><p>通过 GDB 跟踪 <code>frame_ptr-&gt;_Coro_self_handle</code> ，可以看到它是一个指向 <code>Frame</code> / <code>Frame::_Coro_resume_fn</code> 的指针，从而说明 <code>coroutine_handle</code> 也是一个指向 <code>Frame</code> / <code>Frame::_Coro_resume_fn</code> 的指针。</p><h2 id="awaiter-是一个控制-coroutine-切换行为的对象"><code>awaiter</code> 是一个控制 coroutine 切换行为的对象</h2><ul><li><code>awaiter.await_ready()</code> 决定继续执行当前 coroutine 还是暂停执行当前 coroutine 。</li><li><code>awaiter.await_suspend(handle)</code> 决定暂停执行当前 coroutine 之后应该干什么。</li></ul><p><a href="https://en.cppreference.com/w/cpp/language/coroutines">C++ reference: Coroutines</a> 提到了 <code>Awaiter</code> 的作用：</p><blockquote><p><code>co_await expr</code>:</p><p>First, expr is converted to an awaitable as follows...</p><p>Then, the awaiter object is obtained, as follows...</p><p>Then, <code>awaiter.await_ready()</code> is called (this is a short-cut to avoid the cost of suspension if it's known that the result is ready or can be completed synchronously). If its result, contextually-converted to bool is <code>false</code> then</p><ul><li>The coroutine is suspended (its coroutine state is populated with local variables and current suspension point).</li><li><code>awaiter.await_suspend(handle)</code> is called, where handle is the coroutine handle representing the current coroutine. Inside that function, the suspended coroutine state is observable via that handle, and it's this function's responsibility to schedule it to resume on some executor, or to be destroyed (returning <code>false</code> counts as scheduling)<ul><li>if <code>await_suspend</code> returns <code>void</code>, control is immediately returned to the caller/resumer of the current coroutine (this coroutine remains suspended).</li><li>if <code>await_suspend</code> returns <code>bool</code>,<ul><li>the value <code>true</code> returns control to the caller/resumer of the current coroutine.</li><li>the value <code>false</code> resumes the current coroutine.</li></ul></li><li>if <code>await_suspend</code> returns a coroutine handle for some other coroutine, that handle is resumed (by a call to <code>handle.resume()</code>) (note this may chain to eventually cause the current coroutine to resume).</li><li>if <code>await_suspend</code> throws an exception, the exception is caught, the coroutine is resumed, and the exception is immediately re-thrown.</li></ul></li></ul><p>Finally, <code>awaiter.await_resume()</code> is called (whether the coroutine was suspended or not), and its result is the result of the whole <code>co_await expr</code> expression.</p></blockquote><h1 id="co_yield-co_await-promise.yield_valuevalue"><code>co_yield</code> = <code>co_await promise.yield_value(value)</code></h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ -std=c++20 -fcoroutines -fno-exceptions -fno-asynchronous-unwind-tables -ggdb -O0 main.cc -o main.o</span><br><span class="hljs-comment">// objdump -M intel,intel-mnemonic --demangle=auto --no-recurse-limit --no-show-raw-insn -d main.o</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;coroutine&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ReturnObject</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">promise_type</span> &#123;<br>    <span class="hljs-function">ReturnObject <span class="hljs-title">get_return_object</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        .h_ = std::coroutine_handle&lt;promise_type&gt;::<span class="hljs-built_in">from_promise</span>(*<span class="hljs-keyword">this</span>)<br>      &#125;;<br>    &#125;<br>    <span class="hljs-function">std::suspend_never <span class="hljs-title">initial_suspend</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>    <span class="hljs-function">std::suspend_always <span class="hljs-title">yield_value</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span> </span>&#123;<br>      value_ = value;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">return_value</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span> </span>&#123;<br>      value_ = value;<br>    &#125;<br>    <span class="hljs-function">std::suspend_always <span class="hljs-title">final_suspend</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-keyword">return</span> &#123;&#125;; &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unhandled_exception</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_;<br>  &#125;;<br>  std::coroutine_handle&lt;promise_type&gt; h_;<br>&#125;;<br><br><span class="hljs-function">ReturnObject <span class="hljs-title">counter</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">co_await</span> std::suspend_always&#123;&#125;;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_a = <span class="hljs-number">0x12345678</span>;<br>  <span class="hljs-keyword">co_yield</span> value_a;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_b = <span class="hljs-number">0x90ABCDEF</span>;<br>  <span class="hljs-type">uint64_t</span> rbp = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;movq %%rbp, %0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span> (rbp));<br>  <span class="hljs-type">uint64_t</span>* frame_ptr = *(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">uint64_t</span>**&gt;(rbp - <span class="hljs-number">0x28</span>));<br>  <span class="hljs-keyword">auto</span> h = std::coroutine_handle&lt;ReturnObject::promise_type&gt;::<span class="hljs-built_in">from_address</span>(frame_ptr);<br>  <span class="hljs-keyword">auto</span>&amp; p = h.<span class="hljs-built_in">promise</span>();<br>  <span class="hljs-keyword">co_await</span> p.<span class="hljs-built_in">yield_value</span>(value_b);<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_c = <span class="hljs-number">0x98765432</span>;<br>  <span class="hljs-keyword">co_return</span> value_c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">auto</span> h = <span class="hljs-built_in">counter</span>().h_;<br>  <span class="hljs-keyword">auto</span>&amp; promise = h.<span class="hljs-built_in">promise</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  <span class="hljs-built_in">h</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  <span class="hljs-built_in">h</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  <span class="hljs-built_in">h</span>();<br>  std::cout &lt;&lt; promise.value_ &lt;&lt; std::endl;<br>  h.<span class="hljs-built_in">destroy</span>();<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="解密-stdcoroutine_handlefrom_promise">解密 std::coroutine_handle<Promise>::from_promise</h1><p><code>std::coroutine_handle&lt;Promise&gt;::from_promise</code> 看上去很像“魔法”，从一个没有任何相关字段的对象（比如 <code>ReturnObject::promise_type</code> ）里凭空变出了 <code>coroutine_handle</code> 。<a href="https://stackoverflow.com/questions/58632651/how-coroutine-handlepromisefrom-promise-works-in-c">Stack Overflow: How coroutine_handle<Promise>::from_promise() works in C++</a> 解释了这个魔法：</p><blockquote><p>It works by fiat. That is, it works because the standard says that it works, and implementations must therefore find a way to implement coroutines in such a way that it is possible.</p><p>When creating a coroutine, the implementation creates two things: the <code>coroutine_handle</code> and the <code>promise</code> object. The location of both of these things is controlled entirely by the compiler. So, the compiler could very easily allocate them contiguously with each other, such that a coroutine's stack would essentially start with a <code>struct &#123;coroutine_handle&lt;Promise&gt; handle; Promise promise&#125;;</code>.</p><p>Given that knowledge, you know that the handle for any promise type lives <code>sizeof(coroutine_handle&lt;Promise&gt;)</code> bytes before any <code>promise</code> object's address (alignment requirements of the <code>Promise</code> type can adjust this, but such things can be queried from the type). And since <code>from_promise</code> takes a promise object, you can just offset the pointer and cast it to a <code>coroutine_handle&lt;Promise&gt;</code>.</p><p>Now, that is just one way of doing it; an implementation doesn't have to do it this way. What matters is that the implementation has control over where the promise object lives relative to the coroutine internal data. Or more specifically, the promise lives inside of that internal data. Regardless of how you look at it, the compiler knows everything it needs to in order to convert the address of a promise into the internal data needed to fill in a <code>coroutine_handle</code>.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">type = <span class="hljs-keyword">struct</span> _Z7counterv.Frame &#123;<br>  <span class="hljs-built_in">void</span> (*_Coro_resume_fn)(_Z7counterv.Frame *);<br>  <span class="hljs-built_in">void</span> (*_Coro_destroy_fn)(_Z7counterv.Frame *);<br>  std::__n4861::__coroutine_traits_impl&lt;ReturnObject, <span class="hljs-type">void</span>&gt;::promise_type _Coro_promise;<br>  std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt; _Coro_self_handle;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> _Coro_resume_index;<br>  <span class="hljs-type">bool</span> _Coro_frame_needs_free;<br>  ReturnObject::InitialSuspendNever Is_1_1;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_a_1_2;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_b_1_2;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value_c_1_2;<br>  CoAwaitSuspendAlways Aw0_2_3;<br>  ReturnObject::YieldSuspendAlways Yd1_2_4;<br>  ReturnObject::YieldSuspendAlways Yd2_2_5;<br>  ReturnObject::FinalSuspendAlways Fs_1_6;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401708 &lt;ReturnObject::promise_type::get_return_object()&gt;:<br>  401708:       push   rbp<br>  401709:       mov    rbp,rsp<br>  40170c:       sub    rsp,0x10<br>  ; RDI = this = &amp;Frame::_Coro_promise;<br>  401710:       mov    QWORD PTR [rbp-0x8],rdi<br>  401714:       mov    rax,QWORD PTR [rbp-0x8]<br>  401718:       mov    rdi,rax<br>  40171b:       call   401775 &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::from_promise(ReturnObject::promise_type&amp;)&gt;<br>  401720:       leave<br>  401721:       ret<br><br>0000000000401775 &lt;std::__n4861::coroutine_handle&lt;ReturnObject::promise_type&gt;::from_promise(ReturnObject::promise_type&amp;)&gt;:<br>  401775:       push   rbp<br>  401776:       mov    rbp,rsp<br>  ; RDI = &amp;Frame::_Coro_promise.<br>  401779:       mov    QWORD PTR [rbp-0x18],rdi<br>  40177d:       mov    QWORD PTR [rbp-0x8],0x0<br>  401785:       mov    rax,QWORD PTR [rbp-0x18]<br>  ; RAX = RDI - 0x10 = &amp;Frame::_Coro_promise - 0x10 = &amp;Frame.<br>  401789:       sub    rax,0x10<br>  40178d:       mov    QWORD PTR [rbp-0x8],rax<br>  401791:       mov    rax,QWORD PTR [rbp-0x8]<br>  401795:       pop    rbp<br>  ; Return value is &amp;Frame, which is coroutine handle.<br>  401796:       ret<br>  401797:       nop<br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><p>Assembly Language:</p><ul><li><a href="https://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.html">Intel 64 and IA-32 Architectures Software Developer's Manual: Volume 2</a></li><li><a href="https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf">The 64 bit x86 C Calling Convention</a></li><li><a href="https://libdl.so/articles/x86_calling_conventions.html">x86 calling conventions</a></li><li><a href="https://wiki.osdev.org/CPU_Registers_x86">OSDev.org: CPU Registers x86</a></li><li><a href="https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers">Stack Overflow: What are the ESP and the EBP registers?</a></li><li><a href="https://stackoverflow.com/questions/4560720/why-does-the-stack-address-grow-towards-decreasing-memory-addresses">Stack Overflow: Why does the stack address grow towards decreasing memory addresses?</a></li><li><a href="https://stackoverflow.com/questions/1582960/assembly-language-je-jump-function">Stack Overflow: Assembly language je jump function</a></li></ul><p>Coroutine proposals:</p><ul><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4775.pdf">Open Standards: Working Draft, C++ Extensions for Coroutines</a></li><li><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1492r0.pdf">Open Standards: Coroutines: Language and Implementation Impact</a></li><li><a href="https://eel.is/c++draft/dcl.fct.def.coroutine">Working Draft, Standard for Programming Language C++: Coroutine definitions</a></li></ul><p>Coroutine Overview:</p><ul><li><a href="https://www.scs.stanford.edu/~dm/blog/c++-coroutines.html">David Mazières: My tutorial and take on C++20 coroutines</a></li><li><a href="https://devblogs.microsoft.com/oldnewthing/20211007-00/?p=105777">Mircosoft, The Old New Thing, Debugging coroutine handles: The Microsoft Visual C++ compiler, clang, and gcc</a></li><li><a href="https://devblogs.microsoft.com/oldnewthing/20210329-00/?p=105015">Mircosoft, The Old New Thing, C++ coroutines: The mental model for coroutine promises</a></li><li><a href="https://devblogs.microsoft.com/oldnewthing/20210330-00/?p=105019">Mircosoft, The Old New Thing, C++ coroutines: Basic implementation of a promise type</a></li><li><a href="https://devblogs.microsoft.com/oldnewthing/20210331-00/?p=105028">Microsoft, The Old New Thing, C++ coroutines: The initial and final suspend, and improving our return_value method</a></li><li><a href="https://devblogs.microsoft.com/oldnewthing/20210401-00/?p=105043">Microsoft, The Old New Thing, C++ coroutines: What happens if an exception occurs in my return_value?</a></li><li><a href="https://www.youtube.com/watch?v=ZNttI_WswMU">ACCU 2022, Jim Pascoe: How to Use C++20 Coroutines for Networking</a></li><li><a href="https://itnext.io/c-20-coroutines-complete-guide-7c3fc08db89d">ITNEXT, Šimon Tóth: C++20 Coroutines — Complete* Guide</a></li><li><a href="https://stackoverflow.com/questions/58632651/how-coroutine-handlepromisefrom-promise-works-in-c">Stack Overflow: How coroutine_handle&lt;Promise&gt;::from_promise() works in C++</a></li><li><a href="https://en.cppreference.com/w/cpp/language/coroutines">C++ reference: Coroutines</a></li></ul><p>Coroutine Frame:</p><ul><li><a href="https://clang.llvm.org/docs/DebuggingCoroutines.html#coroutine-frame">Clang 16.0.0: Debugging C++ Coroutines, coroutine frame</a></li><li><a href="https://github.com/gcc-mirror/gcc/commit/49789fd08378e3ff7a6efd7c4f72b72654259b89">gcc-mirror/gcc: C++ coroutines Initial implementation.</a></li><li><a href="https://github.com/gcc-mirror/gcc/blob/2fa8c4a659a19ec971c80704f48f96c13aae9ac3/gcc/cp/coroutines.cc#L4336">gcc-mirror/gcc: coroutines.cc</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jemalloc Size Classes</title>
    <link href="/2022/01/15/computer-science/memory-analysis/jemalloc-size-classes/"/>
    <url>/2022/01/15/computer-science/memory-analysis/jemalloc-size-classes/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>如下图所示：</p><ul><li>jemalloc 有三种类型的 size class groups 。</li><li>regular group 有多组。</li><li>每组 size class group 又包含多个 size classes 。</li></ul><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/jemalloc-size-classes/size-class.png" /></p><table><thead><tr class="header"><th style="text-align: center;">var</th><th style="text-align: center;">expression</th><th style="text-align: center;">value</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">SC_NTINY</td><td style="text-align: center;">LG_QUANTUM - SC_LG_TINY_MIN</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">SC_NPSEUDO</td><td style="text-align: center;">SC_NGROUP</td><td style="text-align: center;">4</td></tr><tr class="odd"><td style="text-align: center;">SC_NREGULAR</td><td style="text-align: center;">SC_NGROUP * (SC_LG_BASE_MAX - SC_LG_FIRST_REGULAR_BASE + 1) - 1</td><td style="text-align: center;">227</td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;">group</th><th style="text-align: center;">index</th><th style="text-align: center;">lg_base</th><th style="text-align: center;">lg_delta</th><th style="text-align: center;">ndelta</th><th style="text-align: center;">psz</th><th style="text-align: center;">bin</th><th style="text-align: center;">pgs</th><th style="text-align: center;">lg_delta_lookup</th><th style="text-align: center;">size</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Tiny size classes</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">0</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">3</td><td style="text-align: center;">8</td></tr><tr class="odd"><td style="text-align: center;">Initial pseudo-group</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">1</td><td style="text-align: center;">3</td><td style="text-align: center;">3</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">3</td><td style="text-align: center;">16</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">2</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">32</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">48</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">64</td></tr><tr class="even"><td style="text-align: center;">Regular group 0</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">80</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">6</td><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">4</td><td style="text-align: center;">96</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">7</td><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">7</td><td style="text-align: center;">4</td><td style="text-align: center;">112</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;">4</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">4</td><td style="text-align: center;">128</td></tr><tr class="odd"><td style="text-align: center;">Regular group 1</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">9</td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">5</td><td style="text-align: center;">5</td><td style="text-align: center;">160</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">10</td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">5</td><td style="text-align: center;">192</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">11</td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">224</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">12</td><td style="text-align: center;">7</td><td style="text-align: center;">5</td><td style="text-align: center;">4</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">5</td><td style="text-align: center;">256</td></tr><tr class="even"><td style="text-align: center;">Regular group 2</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">13</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">5</td><td style="text-align: center;">6</td><td style="text-align: center;">320</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">14</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">6</td><td style="text-align: center;">384</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">15</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">7</td><td style="text-align: center;">6</td><td style="text-align: center;">448</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">16</td><td style="text-align: center;">8</td><td style="text-align: center;">6</td><td style="text-align: center;">4</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">6</td><td style="text-align: center;">512</td></tr><tr class="odd"><td style="text-align: center;">Regular group 3</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">17</td><td style="text-align: center;">9</td><td style="text-align: center;">7</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">5</td><td style="text-align: center;">7</td><td style="text-align: center;">640</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">18</td><td style="text-align: center;">9</td><td style="text-align: center;">7</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">7</td><td style="text-align: center;">768</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">19</td><td style="text-align: center;">9</td><td style="text-align: center;">7</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">7</td><td style="text-align: center;">7</td><td style="text-align: center;">896</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">20</td><td style="text-align: center;">9</td><td style="text-align: center;">7</td><td style="text-align: center;">4</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">7</td><td style="text-align: center;">1024</td></tr><tr class="even"><td style="text-align: center;">Regular group 4</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">21</td><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">5</td><td style="text-align: center;">8</td><td style="text-align: center;">1280</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">22</td><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">8</td><td style="text-align: center;">1536</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">23</td><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">7</td><td style="text-align: center;">8</td><td style="text-align: center;">1792</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">24</td><td style="text-align: center;">10</td><td style="text-align: center;">8</td><td style="text-align: center;">4</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">8</td><td style="text-align: center;">2048</td></tr><tr class="odd"><td style="text-align: center;">Regular group 5</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">25</td><td style="text-align: center;">11</td><td style="text-align: center;">9</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">5</td><td style="text-align: center;">9</td><td style="text-align: center;">2560</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">26</td><td style="text-align: center;">11</td><td style="text-align: center;">9</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">9</td><td style="text-align: center;">3072</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">27</td><td style="text-align: center;">11</td><td style="text-align: center;">9</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">7</td><td style="text-align: center;">9</td><td style="text-align: center;">3584</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">28</td><td style="text-align: center;">11</td><td style="text-align: center;">9</td><td style="text-align: center;">4</td><td style="text-align: center;">true</td><td style="text-align: center;">true</td><td style="text-align: center;">1</td><td style="text-align: center;">9</td><td style="text-align: center;">4096</td></tr><tr class="even"><td style="text-align: center;">Regular group 6</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">29</td><td style="text-align: center;">12</td><td style="text-align: center;">10</td><td style="text-align: center;">1</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">5</td><td style="text-align: center;">0</td><td style="text-align: center;">5120</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">30</td><td style="text-align: center;">12</td><td style="text-align: center;">10</td><td style="text-align: center;">2</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">3</td><td style="text-align: center;">0</td><td style="text-align: center;">6144</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">31</td><td style="text-align: center;">12</td><td style="text-align: center;">10</td><td style="text-align: center;">3</td><td style="text-align: center;">false</td><td style="text-align: center;">true</td><td style="text-align: center;">7</td><td style="text-align: center;">0</td><td style="text-align: center;">7168</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">32</td><td style="text-align: center;">12</td><td style="text-align: center;">10</td><td style="text-align: center;">4</td><td style="text-align: center;">true</td><td style="text-align: center;">true</td><td style="text-align: center;">2</td><td style="text-align: center;">0</td><td style="text-align: center;">8192</td></tr><tr class="odd"><td style="text-align: center;">...</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">Regular group 55</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">225</td><td style="text-align: center;">61</td><td style="text-align: center;">59</td><td style="text-align: center;">1</td><td style="text-align: center;">true</td><td style="text-align: center;">false</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">2882303761517117440</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">226</td><td style="text-align: center;">61</td><td style="text-align: center;">59</td><td style="text-align: center;">2</td><td style="text-align: center;">true</td><td style="text-align: center;">false</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">3458764513820540928</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">227</td><td style="text-align: center;">61</td><td style="text-align: center;">59</td><td style="text-align: center;">3</td><td style="text-align: center;">true</td><td style="text-align: center;">false</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">4035225266123964416</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">228</td><td style="text-align: center;">61</td><td style="text-align: center;">59</td><td style="text-align: center;">4</td><td style="text-align: center;">true</td><td style="text-align: center;">false</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">4611686018427387904</td></tr><tr class="odd"><td style="text-align: center;">Regular group 56</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">229</td><td style="text-align: center;">62</td><td style="text-align: center;">60</td><td style="text-align: center;">1</td><td style="text-align: center;">true</td><td style="text-align: center;">false</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">5764607523034234880</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">230</td><td style="text-align: center;">62</td><td style="text-align: center;">60</td><td style="text-align: center;">2</td><td style="text-align: center;">true</td><td style="text-align: center;">false</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">6917529027641081856</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">231</td><td style="text-align: center;">62</td><td style="text-align: center;">60</td><td style="text-align: center;">3</td><td style="text-align: center;">true</td><td style="text-align: center;">false</td><td style="text-align: center;">0</td><td style="text-align: center;">0</td><td style="text-align: center;">8070450532247928832</td></tr></tbody></table><p><a href="https://github.com/jemalloc/jemalloc/blob/ea6b3e973b477b8061e0076bb257dbd7f3faa756/include/jemalloc/internal/sc.h#L6">jemalloc/include/jemalloc/internal/sc.h</a> 的注释详细地描述了三种类型的 size class group 是如何产生的：</p><ul><li>regular group 的产生非常简单，每一组 regular group 都覆盖一个左开右闭区间 (base, base * 2] ，这个区间会被划分为 <code>pow(2, SC_LG_NGROUP)</code> 个等宽区间。</li><li>对于 base = 16 的情况，将 (16, 32] 分成 <code>pow(2, SC_LG_NGROUP) = 4</code> 个等宽区间，得到 (16, 20] / (20, 24] / (24, 28] / (28, 32] 。如果我们将一个内存页切分成多个连续的、大小相同的 objects ，那么部分大小为 20 bytes 的 objects 的起始地址不能对齐到 <code>pow(2, LG_QUANTUM) = 16</code> 个字节。所以对这部分区间要做特殊处理，从而产生 initial pseudo-group ，initial pseudo-group 内的每两个相邻的 size classes 相距 <code>pow(2, LG_QUANTUM) = 16</code> 个字节。</li><li>对于「大小」小于「对齐要求」（即 <code>pow(2, LG_QUANTUM) = 16</code> 字节）的 objects ，jemalloc 在分配它们时不会考虑对齐，从而产生 tiny size classes 。Tiny size classes 中任意两个连续的 size classes 是两倍的关系。</li></ul><h1 id="size-class-的数学性质">size class 的数学性质</h1><p>通过对 <code>SC_LG_NGROUP</code> 等参数的巧妙限制，jemalloc 保证「size class」的大小等于 <code>(ZU(1) &lt;&lt; sc-&gt;lg_base) + (ZU(sc-&gt;ndelta) &lt;&lt; sc-&gt;lg_delta)</code> 。</p><h1 id="初始化-size-class">初始化 size class</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">size_class</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-comment">// Output.</span></span><br><span class="hljs-params">    <span class="hljs-type">sc_t</span> *sc,</span><br><span class="hljs-params">    <span class="hljs-comment">// pow(2, lg_max_lookup) 是 object 的大小上限，默认值是 4KiB 。</span></span><br><span class="hljs-params">    <span class="hljs-comment">// 更大的 malloc 请求会直接分配整页内存页？</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> lg_max_lookup,</span><br><span class="hljs-params">    <span class="hljs-comment">// pow(2, lg_page) 是一页内存的大小，默认值是 4KiB 。</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> lg_page,</span><br><span class="hljs-params">    <span class="hljs-comment">// pow(2, lg_ngroup) 是一组 regular group 分成的区间数，默认值是 4 。</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> lg_ngroup,</span><br><span class="hljs-params">    <span class="hljs-comment">// size class 的序号，从 0 开始自增。</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> index,</span><br><span class="hljs-params">    <span class="hljs-comment">// object size = (1 &lt;&lt; lg_base) + ndelta * (1 &lt;&lt; lg_delta)</span></span><br><span class="hljs-params">    <span class="hljs-type">int</span> lg_base,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lg_delta,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> ndelta)</span> &#123;<br>    <span class="hljs-comment">// Trivial assignments.</span><br>    sc-&gt;index = index;<br>    sc-&gt;lg_base = lg_base;<br>    sc-&gt;lg_delta = lg_delta;<br>    sc-&gt;ndelta = ndelta;<br>    <span class="hljs-comment">// reg_size_compute(lg_base, lg_delta, ndelta) = object size</span><br>    <span class="hljs-comment">// True if the size class is a multiple of the page size,</span><br>    <span class="hljs-comment">// false otherwise.</span><br>    sc-&gt;psz = (reg_size_compute(lg_base, lg_delta, ndelta)<br>        % (ZU(<span class="hljs-number">1</span>) &lt;&lt; lg_page) == <span class="hljs-number">0</span>);<br>    <span class="hljs-type">size_t</span> size = (ZU(<span class="hljs-number">1</span>) &lt;&lt; lg_base) + (ZU(ndelta) &lt;&lt; lg_delta);<br>    <span class="hljs-comment">// 为什么 small size class 的定义这么奇怪？</span><br>    <span class="hljs-comment">// We declare a size class is binnable if size &lt; page size * group.</span><br>    <span class="hljs-comment">// https://github.com/jemalloc/jemalloc/blob/ea6b3e973b477b8061e0076bb257dbd7f3faa756/include/jemalloc/internal/sc.h#L229</span><br>    <span class="hljs-keyword">if</span> (size &lt; (ZU(<span class="hljs-number">1</span>) &lt;&lt; (lg_page + lg_ngroup))) &#123;<br>        <span class="hljs-comment">// True if the size class is a small, bin, size class.</span><br>        <span class="hljs-comment">// False otherwise.</span><br>        sc-&gt;bin = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// The slab page count if a small bin size class, 0 otherwise.</span><br>        <span class="hljs-comment">// 为了避免内存浪费，(pgs * pow(2, lg_page)) % size == 0 。</span><br>        sc-&gt;pgs = slab_size(lg_page, lg_base, lg_delta, ndelta);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        sc-&gt;bin = <span class="hljs-literal">false</span>;<br>        sc-&gt;pgs = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (size &lt;= (ZU(<span class="hljs-number">1</span>) &lt;&lt; lg_max_lookup)) &#123;<br>        <span class="hljs-comment">// Same as lg_delta if a lookup table size class, 0 otherwise.</span><br>        sc-&gt;lg_delta_lookup = lg_delta;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        sc-&gt;lg_delta_lookup = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="查找-size-class">查找 size class</h1><p><code>sz_size2index_tab</code> 是一张 lookup table ，能加速从「request size」到 size class 的查找过程：</p><ul><li><code>sz_size2index_lookup</code> 是查找函数。</li><li><code>sz_boot_size2index_tab</code> 是初始化 lookup table 的函数。</li></ul><table><thead><tr class="header"><th style="text-align: center;">size range</th><th style="text-align: center;">id = (size + the tiny min size - 1) / the tiny min size (8)</th><th style="text-align: center;">size class</th><th style="text-align: center;">size class size</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">[0, 0]</td><td style="text-align: center;">0</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">(0, 8]</td><td style="text-align: center;">1</td><td style="text-align: center;">0</td><td style="text-align: center;">8</td></tr><tr class="odd"><td style="text-align: center;">(8, 16]</td><td style="text-align: center;">2</td><td style="text-align: center;">1</td><td style="text-align: center;">16</td></tr><tr class="even"><td style="text-align: center;">(16, 24]</td><td style="text-align: center;">3</td><td style="text-align: center;">2</td><td style="text-align: center;">32</td></tr><tr class="odd"><td style="text-align: center;">(24, 32]</td><td style="text-align: center;">4</td><td style="text-align: center;">2</td><td style="text-align: center;">32</td></tr><tr class="even"><td style="text-align: center;">(32, 40]</td><td style="text-align: center;">5</td><td style="text-align: center;">3</td><td style="text-align: center;">48</td></tr><tr class="odd"><td style="text-align: center;">(40, 48]</td><td style="text-align: center;">6</td><td style="text-align: center;">3</td><td style="text-align: center;">48</td></tr><tr class="even"><td style="text-align: center;">(48, 56]</td><td style="text-align: center;">7</td><td style="text-align: center;">4</td><td style="text-align: center;">64</td></tr><tr class="odd"><td style="text-align: center;">(56, 64]</td><td style="text-align: center;">8</td><td style="text-align: center;">4</td><td style="text-align: center;">64</td></tr><tr class="even"><td style="text-align: center;">(64, 72]</td><td style="text-align: center;">9</td><td style="text-align: center;">5</td><td style="text-align: center;">80</td></tr><tr class="odd"><td style="text-align: center;">(72, 80]</td><td style="text-align: center;">10</td><td style="text-align: center;">5</td><td style="text-align: center;">80</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * To keep this table small, we divide sizes by the tiny min size, which gives</span><br><span class="hljs-comment"> * the smallest interval for which the result can change.</span><br><span class="hljs-comment"> */</span><br>JEMALLOC_ALIGNED(CACHELINE)<br><span class="hljs-type">uint8_t</span> sz_size2index_tab[(SC_LOOKUP_MAXCLASS &gt;&gt; SC_LG_TINY_MIN) + <span class="hljs-number">1</span>];<br><br>JEMALLOC_ALWAYS_INLINE <span class="hljs-type">szind_t</span><br><span class="hljs-title function_">sz_size2index_lookup</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    assert(size &lt;= SC_LOOKUP_MAXCLASS);<br>    <span class="hljs-type">szind_t</span> ret = (sz_size2index_tab[(size + (ZU(<span class="hljs-number">1</span>) &lt;&lt; SC_LG_TINY_MIN) - <span class="hljs-number">1</span>)<br>                     &gt;&gt; SC_LG_TINY_MIN]);<br>    assert(ret == sz_size2index_compute(size));<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span><br><span class="hljs-title function_">sz_boot_size2index_tab</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sc_data_t</span> *sc_data)</span> &#123;<br>    <span class="hljs-type">size_t</span> dst_max = (SC_LOOKUP_MAXCLASS &gt;&gt; SC_LG_TINY_MIN) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">size_t</span> dst_ind = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> sc_ind = <span class="hljs-number">0</span>; sc_ind &lt; SC_NSIZES &amp;&amp; dst_ind &lt; dst_max;<br>        sc_ind++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">sc_t</span> *sc = &amp;sc_data-&gt;sc[sc_ind];<br>        <span class="hljs-type">size_t</span> sz = (ZU(<span class="hljs-number">1</span>) &lt;&lt; sc-&gt;lg_base)<br>            + (ZU(sc-&gt;ndelta) &lt;&lt; sc-&gt;lg_delta);<br>        <span class="hljs-comment">// index = sc_ind 的 size class 能覆盖的最大 size 就是 sz 。</span><br>        <span class="hljs-type">size_t</span> max_ind = ((sz + (ZU(<span class="hljs-number">1</span>) &lt;&lt; SC_LG_TINY_MIN) - <span class="hljs-number">1</span>)<br>                   &gt;&gt; SC_LG_TINY_MIN);<br>        <span class="hljs-keyword">for</span> (; dst_ind &lt;= max_ind &amp;&amp; dst_ind &lt; dst_max; dst_ind++) &#123;<br>            sz_size2index_tab[dst_ind] = sc_ind;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Memory Analysis</category>
      
      <category>Jemalloc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Iptables And K8S</title>
    <link href="/2021/07/04/computer-science/tools/iptables-and-k8s/"/>
    <url>/2021/07/04/computer-science/tools/iptables-and-k8s/</url>
    
    <content type="html"><![CDATA[<h1 id="iptables">Iptables</h1><p><a href="https://wiki.centos.org/HowTos/Network/IPTables">CentOS: Iptables</a> 说 Netfilter 是工作在内核的模块，Iptables 是工作在用户空间、负责定义规则的命令行工具：</p><blockquote><p>Iptables is the userspace module, the bit that you, the user, interact with at the command line to enter firewall rules into predefined tables. Netfilter is a kernel module, built into the kernel, that actually does the filtering.</p></blockquote><h2 id="基本概念">基本概念</h2><h3 id="tables"><a href="https://ipset.netfilter.org/iptables.man.html">Tables</a></h3><blockquote><p>There are currently five independent tables (which tables are present at any time depends on the kernel configuration options and which modules are present).</p><ul><li>filter</li><li>nat: This table is consulted when a packet that creates a new connection is encountered.</li><li>mangle: This table is used for specialized packet alteration. Until kernel 2.4.17 it had two built-in chains: <strong>PREROUTING</strong> (for altering incoming packets before routing) and <strong>OUTPUT</strong> (for altering locally-generated packets before routing). Since kernel <strong>2.4.18</strong>, three other built-in chains are also supported: <strong>INPUT</strong> (for packets coming into the box itself), <strong>FORWARD</strong> (for altering packets being routed through the box), and <strong>POSTROUTING</strong> (for altering packets as they are about to go out).</li><li>raw: This table is used mainly for configuring exemptions from connection tracking in combination with the NOTRACK target.</li><li>security</li></ul></blockquote><h3 id="chains"><a href="https://wiki.archlinux.org/title/Iptables#Chains">Chains</a></h3><blockquote><p>Tables consist of chains, which are lists of rules which are followed in order.</p></blockquote><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/iptables-and-k8s/tables_traverse.jpg" /></p><h3 id="traversing-chains"><a href="https://wiki.archlinux.org/title/Iptables#Traversing_Chains">Traversing Chains</a></h3><blockquote><p>A network packet received on any interface traverses the traffic control chains of tables in the order shown in the flow chart. The 3 most commonly used targets are ACCEPT, DROP, and jump to a user-defined chain.</p></blockquote><h2 id="安装">安装</h2><p>安装 iptables ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># apt-get install iptables</span><br><span class="hljs-comment"># iptables --version</span><br>iptables v1.6.0<br></code></pre></td></tr></table></figure><p>打开 iptable_nat 内核模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># lsmod | grep iptable</span><br>iptable_filter         16384  0<br>ip_tables              24576  1 iptable_filter<br>x_tables               36864  2 ip_tables,iptable_filter<br><span class="hljs-comment"># modprobe iptable_nat</span><br><span class="hljs-comment"># lsmod | grep iptable</span><br>iptable_nat            16384  0<br>nf_nat_ipv4            16384  1 iptable_nat<br>iptable_filter         16384  0<br>ip_tables              24576  2 iptable_filter,iptable_nat<br>x_tables               36864  2 ip_tables,iptable_filter<br></code></pre></td></tr></table></figure><h2 id="使用">使用</h2><h1 id="k8s">K8S</h1><p><a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables">Kubernetes: iptables proxy mode</a> 提到 kube-proxy 在 iptables proxy 模式下会利用 iptable 工作：</p><blockquote><p>For each Service, it installs iptables rules, which capture traffic to the Service's clusterIP and port, and redirect that traffic to one of the Service's backend sets. For each Endpoint object, it installs iptables rules which select a backend Pod.</p></blockquote><p>本文会探索 Kubernetes 如何利用 iptables 以达到路由流量的目的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables -L</span><br>Chain INPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br><br>Chain FORWARD (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br><br>Chain OUTPUT (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination<br></code></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ul><li><a href="https://wiki.centos.org/HowTos/Network/IPTables">CentOS: Iptables</a></li><li><a href="https://ipset.netfilter.org/iptables.man.html"></a></li><li><a href="https://wiki.archlinux.org/title/Iptables">Arch Linux Wiki: iptables</a></li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#proxy-mode-iptables">Kubernetes: iptables proxy mode</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Tools</category>
      
      <category>Network</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Delta Lake</title>
    <link href="/2021/05/23/computer-science/big-data/data-lake/delta-lake/"/>
    <url>/2021/05/23/computer-science/big-data/data-lake/delta-lake/</url>
    
    <content type="html"><![CDATA[<h1 id="概述">概述</h1><p>大数据领域掀起了数据湖浪潮，<a href="https://aws.amazon.com/solutions/implementations/data-lake-solution/">AWS</a> 、<a href="https://azure.microsoft.com/en-us/solutions/data-lake/">Azure</a> 、<a href="https://cloud.tencent.com/solution/datalake_storage">腾讯</a>、<a href="https://cn.aliyun.com/solution/doc/datalake">阿里</a>等云计算厂商都推出了数据湖解决方案。数据湖使用对象存储替代传统 HDFS 作为存储层，获得了低成本、开放等优势。Databricks 融合数据仓库和数据湖，提出了 Lakehouse 的概念，并依次实现了 <a href="https://github.com/delta-io">Delta Lake</a> 。本文会分析 Lakehouse 和 Delta Lake ，探寻业界动态。</p><p>笔者认为数据的开放性和对数据的掌控能力是一对矛盾，它们是大数据系统这块跷跷板的两端：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">数据仓库</th><th style="text-align: center;">数据湖</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">开放性</td><td style="text-align: center;">最差（ lock in 厂商，读写数据一定要经过数据仓库）</td><td style="text-align: center;">最好</td></tr><tr class="even"><td style="text-align: center;">掌控能力</td><td style="text-align: center;">最好（随意变换数据文件格式、调整数据分布）</td><td style="text-align: center;">最差</td></tr></tbody></table><p>Lakehouse 的贡献是找到了跷跷板的一个平衡点：</p><ol type="1"><li>既通过对象存储和开源的列存格式提供了开放性；</li><li>又通过自研的数据访问协议保留了一定的数据掌控能力，从而为上层引擎优化（数据文件裁剪、Zorder 等）留下空间。</li></ol><p>Delta Lake 的贡献是实现了一个开放的元数据系统、设计了一套访问元数据和数据的协议。</p><h1 id="delta-lake-的目标">Delta Lake 的目标</h1><p>Delta Lake 的目标是在开放性和对数据的掌控能力上取平衡点，兼得数据仓库和数据湖的优势，详细可查看<a href="https://share.mubu.com/doc/7RYdZfE818f">幕布</a>：</p><ol type="1"><li>数据仓库凭借对数据的掌控能力能获得更多优化机会，理论上 SQL 性能比数据湖更好；由于其封闭性，更容易在存储层上架设元数据层，由元数据层提供 management 特性和 governance 特性。</li><li>数据湖则在成本和开放性上有优势。</li></ol><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/big-data-delta-lake/what-is-lakehouse.png" /></p><h1 id="delta-lake-的架构">Delta Lake 的架构</h1><p>Delta Lake 的架构相较于 HDFS 有以下几点变化，详细可查看<a href="https://share.mubu.com/doc/6qkt1FAt8of">幕布</a>：</p><ol type="1"><li>由于对象存储不支持低成本的 rename 操作，需要由计算引擎配合存储层一起规避掉 rename 操作。</li><li>元数据以 transaction log 的形式存放在对象存储上，并依据对象存储的一些特性做适配；笔者认为用 RDS 存储元数据会在性能和易用性上都取得更好的成绩，也一一反驳了 Lakehouse 论文提出的、不将元数据存储到一个强一致系统的理由。</li><li>性能优化：并行读写数据和元数据、合理规划单个文件的大小、合并流式写入的小文件等。</li></ol><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/big-data-delta-lake/delta-lake-implementation.png" /></p><p>Delta Lake 的目录结构：</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/big-data-delta-lake/objects-stored-in-a-sample-delta-table.png" /></p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://delta.io/">Build Lakehouses with Delta Lake</a></li><li><a href="http://cidrdb.org/cidr2021/papers/cidr2021_paper17.pdf">Lakehouse: A New Generation of Open Platforms that Unify Data Warehousing and Advanced Analytics</a></li><li><a href="https://databricks.com/wp-content/uploads/2020/08/p975-armbrust.pdf">Delta Lake: High-Performance ACID Table Storage over Cloud Object Stores</a></li><li><a href="https://docs.cloudera.com/HDPDocuments/HDP3/HDP-3.0.1/bk_cloud-data-access/content/ch03s08s01.html">Cloudera Documentation: Introducing the S3A Committers</a></li><li><a href="https://mp.weixin.qq.com/s/j7ja_pzHsT519u-maP4T-A">飞总聊 IT ：DataBricks 新项目 Delta Lake 的深度分析和解读</a></li><li><a href="https://zhuanlan.zhihu.com/p/110748218">知乎：深度对比 delta 、iceberg 和 hudi 三大开源数据湖方案</a></li><li><a href="https://zhuanlan.zhihu.com/p/265003182">知乎：数据湖 VS 数据仓库之争？阿里提出大数据架构新概念：湖仓一体</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>Data Lake</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Get Started With Parquet</title>
    <link href="/2021/03/31/computer-science/columnar-storage/get-started-with-parquet/"/>
    <url>/2021/03/31/computer-science/columnar-storage/get-started-with-parquet/</url>
    
    <content type="html"><![CDATA[<h1 id="环境">环境</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> ubuntu:groovy<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y curl wget git</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y openjdk-15-jdk</span><br><span class="hljs-keyword">ENV</span> JAVA_HOME=/usr/lib/jvm/java-<span class="hljs-number">1.15</span>.<span class="hljs-number">0</span>-openjdk-amd64<br><span class="hljs-keyword">ENV</span> PATH=<span class="hljs-string">&quot;$PATH:$JAVA_HOME/bin&quot;</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> java --version</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y python3 python3-distutils python3-apt</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> python3 get-pip.py</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget https://mirror-hk.koddos.net/apache/spark/spark-3.1.1/spark-3.1.1-bin-hadoop2.7.tgz</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xzvf spark-3.1.1-bin-hadoop2.7.tgz</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install parquet-cli</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential cmake make gcc g++</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> git <span class="hljs-built_in">clone</span> https://github.com/apache/arrow.git</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root/arrow</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> git checkout 76d3c36006162766ec598442a0c0d2192f5e0d0b</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">cd</span> cpp &amp;&amp; <span class="hljs-built_in">mkdir</span> -p debug &amp;&amp; <span class="hljs-built_in">cd</span> debug</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root/arrow/cpp/debug</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> cmake -DCMAKE_BUILD_TYPE=Debug -DARROW_PARQUET=ON -DARROW_WITH_SNAPPY=ON ..</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make -j8</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make install</span><br><span class="hljs-keyword">ENV</span> LD_LIBRARY_PATH=<span class="hljs-string">&quot;$LD_LIBRARY_PATH:/usr/local/lib&quot;</span><br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root</span><br></code></pre></td></tr></table></figure><h1 id="文件格式">文件格式</h1><h1 id="读写-parquet-文件">读写 Parquet 文件</h1><h2 id="使用-pyspark-读写-parquet-文件">使用 PySpark 读写 Parquet 文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ./spark-3.1.1-bin-hadoop2.7/bin/pyspark --master local[4]</span><br>Spark context available as <span class="hljs-string">&#x27;sc&#x27;</span> (master = <span class="hljs-built_in">local</span>[4], app <span class="hljs-built_in">id</span> = local-1617201523606).<br>SparkSession available as <span class="hljs-string">&#x27;spark&#x27;</span>.<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python3">from pyspark.sql.types import *<br>schema = StructType([<br>    StructField(&quot;DocId&quot;, LongType(), nullable=False),<br>    StructField(&quot;Links&quot;, StructType([<br>        StructField(&quot;Backward&quot;, ArrayType(LongType()), nullable=True),<br>        StructField(&quot;Forward&quot;, ArrayType(LongType()), nullable=True)<br>    ]), nullable=True),<br>    StructField(&quot;Name&quot;, ArrayType(StructType([<br>        StructField(&quot;Language&quot;, ArrayType(StructType([<br>            StructField(&quot;Code&quot;, StringType(), nullable=False),<br>            StructField(&quot;Country&quot;, StringType(), nullable=True)<br>        ])), nullable=True),<br>        StructField(&quot;Url&quot;, StringType(), nullable=True)<br>    ])), nullable=True)<br>])<br>r1 = &#123;<br>    &quot;DocId&quot;: 10,<br>    &quot;Links&quot;: &#123;&quot;Forward&quot;: [20, 40, 60]&#125;,<br>    &quot;Name&quot;: [<br>        &#123;<br>            &quot;Language&quot;: [&#123;&quot;Code&quot;: &quot;en-us&quot;, &quot;Country&quot;: &quot;us&quot;&#125;, &#123;&quot;Code&quot;: &quot;en&quot;&#125;],<br>            &quot;Url&quot;: &quot;http://A&quot;<br>        &#125;,<br>        &#123;&quot;Url&quot;: &quot;http://B&quot;&#125;,<br>        &#123;&quot;Language&quot;: [&#123;&quot;Code&quot;: &quot;en-gb&quot;, &quot;Country&quot;: &quot;gb&quot;&#125;]&#125;<br>    ]<br>&#125;<br>r2 = &#123;<br>    &quot;DocId&quot;: 20,<br>    &quot;Links&quot;: &#123;&quot;Backward&quot;: [10, 30, 80]&#125;,<br>    &quot;Name&quot;: [&#123;&quot;Url&quot;: &quot;http://C&quot;&#125;]<br>&#125;<br>df = spark.createDataFrame([r1, r2], schema)<br>df.repartition(1).write.mode(&#x27;overwrite&#x27;).parquet(&quot;/root/dremel-records-pyspark.parquet&quot;)<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python3">df = spark.read.parquet(&quot;/root/dremel-records-pyspark.parquet&quot;)<br>df.createOrReplaceTempView(&quot;DremelRecords&quot;)<br>spark.sql(&quot;SELECT * FROM DremelRecords&quot;).show(truncate=False)<br></code></pre></td></tr></table></figure><h2 id="使用-c-读写-parquet-文件">使用 C++ 读写 Parquet 文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Refer arrow/cpp/examples/parquet/low-level-api/reader-writer.cc</span><br><span class="hljs-comment">// g++ -std=c++11 write_dremel_records.cpp -lparquet -larrow -o write_dremel_records.out</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arrow/io/file.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;parquet/api/writer.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> parquet::schema::GroupNode;<br><span class="hljs-keyword">using</span> parquet::schema::NodeVector;<br><span class="hljs-keyword">using</span> parquet::schema::PrimitiveNode;<br><br><span class="hljs-keyword">auto</span> NONE = parquet::ConvertedType::NONE;<br><span class="hljs-keyword">auto</span> OPTIONAL = parquet::Repetition::OPTIONAL;<br><span class="hljs-keyword">auto</span> REPEATED = parquet::Repetition::REPEATED;<br><span class="hljs-keyword">auto</span> REQUIRED = parquet::Repetition::REQUIRED;<br><span class="hljs-keyword">auto</span> INT64 = parquet::Type::INT64;<br><span class="hljs-keyword">auto</span> BYTE_ARRAY = parquet::Type::BYTE_ARRAY;<br><span class="hljs-keyword">auto</span> UTF8 = parquet::ConvertedType::UTF8;<br><br><span class="hljs-function">std::shared_ptr&lt;GroupNode&gt; <span class="hljs-title">SetUpSchema</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> doc_id = PrimitiveNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;DocId&quot;</span>, REQUIRED, INT64, NONE);<br><br>    <span class="hljs-keyword">auto</span> links = GroupNode::<span class="hljs-built_in">Make</span>(<br>        <span class="hljs-string">&quot;Links&quot;</span>,<br>        OPTIONAL,<br>        NodeVector&#123;PrimitiveNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;Backward&quot;</span>, REPEATED, INT64, NONE),<br>                   PrimitiveNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;Forward&quot;</span>, REPEATED, INT64, NONE)&#125;);<br><br>    <span class="hljs-keyword">auto</span> code = PrimitiveNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;Code&quot;</span>, REQUIRED, BYTE_ARRAY, UTF8);<br>    <span class="hljs-keyword">auto</span> country = PrimitiveNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;Country&quot;</span>, OPTIONAL, BYTE_ARRAY, UTF8);<br>    <span class="hljs-keyword">auto</span> name = GroupNode::<span class="hljs-built_in">Make</span>(<br>        <span class="hljs-string">&quot;Name&quot;</span>,<br>        REPEATED,<br>        NodeVector&#123;<br>            GroupNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;Language&quot;</span>, REPEATED, NodeVector&#123;code, country&#125;),<br>            PrimitiveNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;Url&quot;</span>, OPTIONAL, BYTE_ARRAY, UTF8)&#125;);<br><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">static_pointer_cast</span>&lt;GroupNode&gt;(<br>        GroupNode::<span class="hljs-built_in">Make</span>(<span class="hljs-string">&quot;schema&quot;</span>, REQUIRED, NodeVector&#123;doc_id, links, name&#125;));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">WriteRecords</span><span class="hljs-params">(parquet::RowGroupWriter* rg_writer)</span> </span>&#123;<br>    parquet::Int64Writer* doc_id_writer =<br>        <span class="hljs-built_in">static_cast</span>&lt;parquet::Int64Writer*&gt;(rg_writer-&gt;<span class="hljs-built_in">NextColumn</span>());<br>    doc_id_writer-&gt;<span class="hljs-built_in">WriteBatch</span>(<span class="hljs-number">2</span>,<br>                              std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">2</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;.<span class="hljs-built_in">data</span>(),<br>                              std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">2</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;.<span class="hljs-built_in">data</span>(),<br>                              std::array&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-number">2</span>&gt;&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;.<span class="hljs-built_in">data</span>());<br><br>    parquet::Int64Writer* backward_writer =<br>        <span class="hljs-built_in">static_cast</span>&lt;parquet::Int64Writer*&gt;(rg_writer-&gt;<span class="hljs-built_in">NextColumn</span>());<br>    backward_writer-&gt;<span class="hljs-built_in">WriteBatch</span>(<span class="hljs-number">3</span>,<br>                                std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">3</span>&gt;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;.<span class="hljs-built_in">data</span>(),<br>                                std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">3</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;.<span class="hljs-built_in">data</span>(),<br>                                std::array&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-number">2</span>&gt;&#123;<span class="hljs-number">10</span>, <span class="hljs-number">30</span>&#125;.<span class="hljs-built_in">data</span>());<br><br>    parquet::Int64Writer* forward_writer =<br>        <span class="hljs-built_in">static_cast</span>&lt;parquet::Int64Writer*&gt;(rg_writer-&gt;<span class="hljs-built_in">NextColumn</span>());<br>    forward_writer-&gt;<span class="hljs-built_in">WriteBatch</span>(<span class="hljs-number">4</span>,<br>                               std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">4</span>&gt;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;.<span class="hljs-built_in">data</span>(),<br>                               std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">4</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;.<span class="hljs-built_in">data</span>(),<br>                               std::array&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-number">4</span>&gt;&#123;<span class="hljs-number">20</span>, <span class="hljs-number">40</span>, <span class="hljs-number">60</span>, <span class="hljs-number">80</span>&#125;.<span class="hljs-built_in">data</span>());<br><br>    parquet::ByteArrayWriter* code_writer =<br>        <span class="hljs-built_in">static_cast</span>&lt;parquet::ByteArrayWriter*&gt;(rg_writer-&gt;<span class="hljs-built_in">NextColumn</span>());<br>    code_writer-&gt;<span class="hljs-built_in">WriteBatch</span>(<br>        <span class="hljs-number">5</span>,<br>        std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">5</span>&gt;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;.<span class="hljs-built_in">data</span>(),<br>        std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">5</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;.<span class="hljs-built_in">data</span>(),<br>        std::array&lt;parquet::ByteArray, <span class="hljs-number">3</span>&gt;&#123;parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;en-us&quot;</span>),<br>                                          parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;en&quot;</span>),<br>                                          parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;en-gb&quot;</span>)&#125;<br>            .<span class="hljs-built_in">data</span>());<br><br>    parquet::ByteArrayWriter* country_writer =<br>        <span class="hljs-built_in">static_cast</span>&lt;parquet::ByteArrayWriter*&gt;(rg_writer-&gt;<span class="hljs-built_in">NextColumn</span>());<br>    country_writer-&gt;<span class="hljs-built_in">WriteBatch</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br>    country_writer-&gt;<span class="hljs-built_in">WriteBatch</span>(<br>        <span class="hljs-number">5</span>,<br>        std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">5</span>&gt;&#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;.<span class="hljs-built_in">data</span>(),<br>        std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">5</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;.<span class="hljs-built_in">data</span>(),<br>        std::array&lt;parquet::ByteArray, <span class="hljs-number">2</span>&gt;&#123;parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;us&quot;</span>),<br>                                          parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;gb&quot;</span>)&#125;<br>            .<span class="hljs-built_in">data</span>());<br><br>    parquet::ByteArrayWriter* url_writer =<br>        <span class="hljs-built_in">static_cast</span>&lt;parquet::ByteArrayWriter*&gt;(rg_writer-&gt;<span class="hljs-built_in">NextColumn</span>());<br>    url_writer-&gt;<span class="hljs-built_in">WriteBatch</span>(<br>        <span class="hljs-number">4</span>,<br>        std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">4</span>&gt;&#123;<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.<span class="hljs-built_in">data</span>(),<br>        std::array&lt;<span class="hljs-type">int16_t</span>, <span class="hljs-number">4</span>&gt;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;.<span class="hljs-built_in">data</span>(),<br>        std::array&lt;parquet::ByteArray, <span class="hljs-number">3</span>&gt;&#123;parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;http://A&quot;</span>),<br>                                          parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;http://B&quot;</span>),<br>                                          parquet::<span class="hljs-built_in">ByteArray</span>(<span class="hljs-string">&quot;http://C&quot;</span>)&#125;<br>            .<span class="hljs-built_in">data</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// Create a local file output stream instance.</span><br>        <span class="hljs-keyword">using</span> FileClass = ::arrow::io::FileOutputStream;<br>        std::shared_ptr&lt;FileClass&gt; out_file;<br>        <span class="hljs-built_in">PARQUET_ASSIGN_OR_THROW</span>(<br>            out_file, FileClass::<span class="hljs-built_in">Open</span>(<span class="hljs-string">&quot;/root/dremel-records-cpp.parquet&quot;</span>));<br><br>        <span class="hljs-comment">// Setup the parquet schema.</span><br>        <span class="hljs-keyword">auto</span> schema = <span class="hljs-built_in">SetUpSchema</span>();<br><br>        <span class="hljs-comment">// Add writer properties.</span><br>        parquet::WriterProperties::Builder builder;<br>        builder.<span class="hljs-built_in">compression</span>(parquet::Compression::SNAPPY);<br>        std::shared_ptr&lt;parquet::WriterProperties&gt; props = builder.<span class="hljs-built_in">build</span>();<br><br>        <span class="hljs-comment">// Create a ParquetFileWriter instance.</span><br>        std::shared_ptr&lt;parquet::ParquetFileWriter&gt; file_writer =<br>            parquet::ParquetFileWriter::<span class="hljs-built_in">Open</span>(out_file, schema, props);<br><br>        <span class="hljs-comment">// Append a RowGroup with a specific number of rows.</span><br>        parquet::RowGroupWriter* rg_writer = file_writer-&gt;<span class="hljs-built_in">AppendRowGroup</span>();<br>        <span class="hljs-built_in">WriteRecords</span>(rg_writer);<br><br>        <span class="hljs-comment">// Close the ParquetFileWriter.</span><br>        file_writer-&gt;<span class="hljs-built_in">Close</span>();<br><br>        <span class="hljs-comment">// Write the bytes to file.</span><br>        <span class="hljs-built_in">assert</span>(out_file-&gt;<span class="hljs-built_in">Close</span>().<span class="hljs-built_in">ok</span>());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::exception&amp; e) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;Parquet write error: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用-chhantyalparquet-cli-读-parquet-文件">使用 <a href="https://github.com/chhantyal/parquet-cli">chhantyal/parquet-cli</a> 读 Parquet 文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># parq /root/dremel-records.parquet/part-00000-14a09068-9f6d-4515-a176-dccf6836ee11-c000.snappy.parquet</span><br><span class="hljs-comment"># parq /root/dremel-records.parquet/part-00000-14a09068-9f6d-4515-a176-dccf6836ee11-c000.snappy.parquet --schema</span><br></code></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ul><li><a href="https://spark.apache.org/docs/2.1.1/programming-guide.html#using-the-shell">Spark Programming Guide</a></li><li><a href="https://sparkbyexamples.com/pyspark/pyspark-read-and-write-parquet-file/">Spark By Examples: PySpark Read and Write Parquet File</a></li><li><a href="https://sparkbyexamples.com/pyspark/pyspark-structtype-and-structfield/">Spark By Examples: PySpark StructType &amp; StructField Explained with Examples</a></li><li><a href="http://apache-spark-user-list.1001560.n3.nabble.com/dremel-paper-example-schema-td33817.html">Apache Spark User List: dremel paper example schema</a></li><li><a href="https://medium.com/@sivachaitanya/install-apache-spark-pyspark-standalone-mode-70d3c2dd8924">Medium: Install Apache Spark (pyspark) — Standalone mode</a></li><li><a href="https://techoral.com/blog/java/install-openjdk-15-ubuntu.html">Techoral: OpenJDK 15 Download and Installation on Ubuntu</a></li><li><a href="https://arrow.apache.org/docs/developers/cpp/building.html">Apache Arrow: Building Arrow C++</a></li><li><a href="https://arrow.apache.org/docs/cpp/parquet.html">Apache Arrow: Reading and writing Parquet files</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>Columnar Storage</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dremel</title>
    <link href="/2021/03/29/computer-science/columnar-storage/dremel/"/>
    <url>/2021/03/29/computer-science/columnar-storage/dremel/</url>
    
    <content type="html"><![CDATA[<h1 id="repetition-and-definition-levels">Repetition and Definition Levels</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gRPC">message Document &#123;<br>    required int64 DocId;<br>    optional group Links &#123;<br>        repeated int64 Backward;<br>        repeated int64 Forward;<br>    &#125;<br>    repeated group Name &#123;<br>        repeated group Language &#123;<br>            required string Code;<br>            optional string Country;<br>        &#125;<br>        optional string Url;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs text"># r1<br>DocId: 10<br>Links<br>    Forward: 20<br>    Forward: 40<br>    Forward: 60<br>Name<br>    Language<br>        Code: &#x27;en-us&#x27;<br>        Country: &#x27;us&#x27;<br>    Language<br>        Code: &#x27;en&#x27;<br>    Url: &#x27;http://A&#x27;<br>Name<br>    Url: &#x27;http://B&#x27;<br>Name<br>    Language<br>        Code: &#x27;en-gb&#x27;<br>        Country: &#x27;gb&#x27;<br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1.png" /></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text"># r2<br>DocId: 20<br>Links<br>    Backward: 10<br>    Backward: 30<br>    Backward: 80<br>Name<br>    Url: &#x27;http://C&#x27;<br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r2.png" /></p><h2 id="repetition-level">Repetition Level</h2><blockquote><p>It tells us at what repeated field in the field’s path the value has repeated.</p></blockquote><p>在 Repetition Level 小节，我们会使用 [] 和矩形表达 repeated 字段，<strong>不包括</strong> optional 字段（注意与 Definition Level 小节区分）。</p><h3 id="name.language.code">Name.Language.Code</h3><p>论文以 Name.Language.Code 为例子解释了 repetition level ：</p><blockquote><p>Now suppose we are scanning record r1 top down.</p><p>When we encounter 'en-us', we have not seen any repeated fields, i.e., the repetition level is 0.</p><p>When we see 'en', field Language has repeated, so the repetition level is 2.</p><p>Finally, when we encounter 'en-gb', Name has repeated most recently (Language occurred only once after Name), so the repetition level is 1.</p></blockquote><p>笔者认为论文的解释有点模糊，按照以下步骤计算 repetition level 更为准确，深度优先遍历整棵树：</p><ol type="1"><li>若字段是第一次出现，repetition level 记为 0 ；</li><li>若字段不是第一次出现：<ol type="1"><li>找到上一次出现的同名字段；</li><li>找到最近公共祖先；</li><li>找到最近公共祖先的子节点；</li><li>计算最近公共祖先的子节点在路径上是第几个 repeated （不包括 optional ）字段。</li></ol></li></ol><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1-code-repetition-level-1.png" /></p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1-code-repetition-level-2.png" /></p><table><thead><tr class="header"><th style="text-align: center;">value of Document.[Name].[Language].Code</th><th style="text-align: center;">repeated with</th><th style="text-align: center;">repeated at</th><th style="text-align: center;">common father of 'repeated at'</th><th style="text-align: center;">repetition level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">en-us</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">en</td><td style="text-align: center;">en-us</td><td style="text-align: center;">Language</td><td style="text-align: center;">Name</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">en-gb</td><td style="text-align: center;">en</td><td style="text-align: center;">Name</td><td style="text-align: center;">Document</td><td style="text-align: center;">1</td></tr></tbody></table><h3 id="others">Others</h3><table><thead><tr class="header"><th style="text-align: center;">value of Document.DocId</th><th style="text-align: center;">repeated with</th><th style="text-align: center;">repeated at</th><th style="text-align: center;">common father of 'repeated at'</th><th style="text-align: center;">repetition level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">10</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">0</td></tr></tbody></table><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1-forward-repetition-level.png" /></p><table><thead><tr class="header"><th style="text-align: center;">value of Document.[Links].[Forward]</th><th style="text-align: center;">repeated with</th><th style="text-align: center;">repeated at</th><th style="text-align: center;">common father of 'repeated at'</th><th style="text-align: center;">repetition level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">20</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">40</td><td style="text-align: center;">20</td><td style="text-align: center;">Forward</td><td style="text-align: center;">Links</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">60</td><td style="text-align: center;">40</td><td style="text-align: center;">Forward</td><td style="text-align: center;">Links</td><td style="text-align: center;">1</td></tr></tbody></table><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1-country-repetition-level.png" /></p><table><thead><tr class="header"><th style="text-align: center;">value of Document.[Name].[Language].Country</th><th style="text-align: center;">repeated with</th><th style="text-align: center;">repeated at</th><th style="text-align: center;">common father of 'repeated at'</th><th style="text-align: center;">repetition level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">us</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">gb</td><td style="text-align: center;">us</td><td style="text-align: center;">Name</td><td style="text-align: center;">Document</td><td style="text-align: center;">1</td></tr></tbody></table><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1-url-repetition-level.png" /></p><table><thead><tr class="header"><th style="text-align: center;">value of Document.[Name].Url</th><th style="text-align: center;">repeated with</th><th style="text-align: center;">repeated at</th><th style="text-align: center;">common father of 'repeated at'</th><th style="text-align: center;">repetition level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">http://A</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">http://B</td><td style="text-align: center;">http://A</td><td style="text-align: center;">Name</td><td style="text-align: center;">Document</td><td style="text-align: center;">1</td></tr></tbody></table><h2 id="definition-level">Definition Level</h2><blockquote><p>Each value of a field with path p, <strong>esp. every NULL</strong>, has a definition level specifying how many fields in p that <strong>could be undefined</strong> (because they are optional or repeated) are <strong>actually present</strong> in the record.</p></blockquote><p>在 Definition Level 小节，我们会使用 [] 和矩形表达 optional 字段<strong>和</strong> repeated 字段（注意与 Repetition Level 小节区分）。</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1-url-definition-level.png" /></p><table><thead><tr class="header"><th style="text-align: center;">value of Document.[Name].[Url]</th><th style="text-align: center;">definition level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">http://A</td><td style="text-align: center;">2</td></tr><tr class="even"><td style="text-align: center;">http://B</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">null</td><td style="text-align: center;">1</td></tr></tbody></table><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/r1-country-definition-level.png" /></p><table><thead><tr class="header"><th style="text-align: center;">value of Document.[Name].[Language].[Country]</th><th style="text-align: center;">definition level</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">us</td><td style="text-align: center;">3</td></tr><tr class="even"><td style="text-align: center;">null</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">null</td><td style="text-align: center;"><strong>1</strong></td></tr><tr class="even"><td style="text-align: center;">gb</td><td style="text-align: center;">3</td></tr></tbody></table><p>为什么使用 definition level 而不是 bool 值来表达叶子节点是否出现？因为 definition level 能携带更多信息：</p><blockquote><p>We use integer definition levels as opposed to is-null bits so that the data for a leaf field (e.g., Name.Language.Country) contains the information about the occurrences of its parent fields.</p></blockquote><h2 id="encoding">Encoding</h2><p>论文主要介绍了工程上优化存储的方法，对原理没有实质性影响，可忽略不看。</p><h1 id="splitting-records-into-columns">Splitting Records into Columns</h1><ol type="1"><li>深度优先遍历树；</li><li>计算 repetition level ：<ol type="1"><li>如果字段在本层重复，repetition level = tree depth ；</li><li>如果字段未在本层重复，repetition level = repetition level of father ；</li></ol></li><li>计算 definition level （略）。</li></ol><h1 id="record-assembly">Record Assembly</h1><blockquote><p>Given a subset of fields, our goal is to reconstruct the original records as if they contained just the selected fields, with all other fields stripped away.</p><p>The key idea is this: we create a finite state machine (FSM) that reads the field values and levels for each field, and appends the values sequentially to the output records. An FSM state corresponds to a field reader for each selected field. State transitions are labeled with repetition levels. Once a reader fetches a value, we look at the next repetition level to decide what next reader to use. The FSM is traversed from the start to end state once for each record.</p></blockquote><p>组装算法分为两部分：</p><ol type="1"><li>创建有限状态机：用 repetition level 判断当前 column 读完之后跳到哪一个祖先节点。</li><li>运行有限状态机。</li></ol><h2 id="运行有限状态机">运行有限状态机</h2><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/columnar-storage-dremel/dfa.png" /></p><p>有限状态机只能依次读入 column （否则不知道 record 边界），有没有并行化的算法？</p><h2 id="创建有限状态机">创建有限状态机</h2><blockquote><p>To sketch how FSM transitions are constructed, let <code>l</code> be the next repetition level returned by the current field reader for field <code>f</code>. Starting at <code>f</code> in the schema tree, we find its ancestor that repeats at level <code>l</code> and select the first leaf field <code>n</code> inside that ancestor. This gives us an FSM transition (<code>f</code>, <code>l</code>) -&gt; <code>n</code>. For example, let <code>l</code> = 1 be the next repetition level read by <code>f</code> = Name.Language.Country. Its ancestor with repetition level 1 is Name, whose first leaf field is <code>n</code> = Name.Url.</p></blockquote><p>repetition level 告诉我们：当前节点读完之后，应该返回到哪一个祖先节点。</p><h2 id="definition-level-提供的信息用在哪里">Definition Level 提供的信息用在哪里？</h2><p>判断在路径的哪一个层次上插入 null ？</p><h1 id="问题汇总">问题汇总</h1><ol type="1"><li>分割和组装算法是否可以并行化？</li><li>是否允许变更 schema ？比如：Document 下新增 Description 字段。</li><li>definition level 提供的信息用在哪里？</li></ol><h1 id="参考资料">参考资料</h1><p>Dremel:</p><ul><li><a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36632.pdf">Dremel: Interactive Analysis of Web-Scale Datasets</a></li><li><a href="https://blog.twitter.com/engineering/en_us/a/2013/dremel-made-simple-with-parquet.html">Twitter Engineering: Dremel made simple with Parquet</a></li></ul><p>Graphviz:</p><ul><li><a href="https://graphviz.org/doc/info/lang.html">Graphviz - Graph Visualization Software: The DOT Language</a></li><li><a href="https://stackoverflow.com/questions/17252630/why-doesnt-fillcolor-work-with-graphviz">Stack Overflow: Why doesn't fill color work with graphviz?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>Columnar Storage</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>About Global Strings</title>
    <link href="/2021/03/12/computer-science/dynamic-linking/about-global-strings/"/>
    <url>/2021/03/12/computer-science/dynamic-linking/about-global-strings/</url>
    
    <content type="html"><![CDATA[<h1 id="环境">环境</h1><p>本文使用的环境与 <a href="https://clcanny.github.io/2020/11/24/dynamic-linking-introduction-to-elf-file/">Dynamic Linking: Introduction To Elf File</a> 使用的环境一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># cat /etc/os-release | head -n 1</span><br>PRETTY_NAME=<span class="hljs-string">&quot;Debian GNU/Linux bullseye/sid&quot;</span><br><span class="hljs-comment"># g++ --version | head -n 1</span><br>g++ (Debian 10.2.1-6) 10.2.1 20210110<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -fPIC -ggdb -O0 -shared                                                 \<br>    -Wl,--dynamic-linker=/root/glibc/build/install/lib/ld-linux-x86-64.so.2 \<br>    foo.cpp -o libfoo.so<br>g++ main.cpp                                                                \<br>    -L<span class="hljs-variable">$PWD</span> -Wl,-rpath=<span class="hljs-variable">$PWD</span>                                                  \<br>    -Wl,--dynamic-linker=/root/glibc/build/install/lib/ld-linux-x86-64.so.2 \<br>    -lfoo -o main<br><span class="hljs-built_in">export</span> LD_LIBRARY_PATH=/usr/lib/x86_64-linux-gnu:/lib/x86_64-linux-gnu<br></code></pre></td></tr></table></figure><h1 id="global-raw-string">Global Raw String</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* var = <span class="hljs-string">&quot;var&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; var &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-about-global-strings/global-raw-string.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers libfoo.so | grep -E -w &quot;Nr|.got|.data|.rodata&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [14] .rodata           PROGBITS         0000000000002000  00002000<br>       0000000000000005  0000000000000000   A       0     0     1<br>  [20] .got              PROGBITS         0000000000003fc0  00002fc0<br>       0000000000000040  0000000000000008  WA       0     0     8<br>  [22] .data             PROGBITS         0000000000004038  00003038<br>       0000000000000010  0000000000000000  WA       0     0     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># objdump -d -j .text libfoo.so | grep &quot;&lt;_Z3foov&gt;:&quot; -A16</span><br>0000000000001135 &lt;_Z3foov&gt;:<br>    1135:       55                      push   %rbp<br>    1136:       48 89 e5                mov    %rsp,%rbp<br>    1139:       48 8b 05 b0 2e 00 00    mov    0x2eb0(%rip),%rax        <span class="hljs-comment"># 3ff0 &lt;var@@Base-0x50&gt;</span><br>    1140:       48 8b 00                mov    (%rax),%rax<br>    1143:       48 89 c6                mov    %rax,%rsi<br>    1146:       48 8b 05 9b 2e 00 00    mov    0x2e9b(%rip),%rax        <span class="hljs-comment"># 3fe8 &lt;_ZSt4cout@GLIBCXX_3.4&gt;</span><br>    114d:       48 89 c7                mov    %rax,%rdi<br>    1150:       e8 fb fe ff ff          callq  1050 &lt;_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt&gt;<br>    1155:       48 89 c2                mov    %rax,%rdx<br>    1158:       48 8b 05 99 2e 00 00    mov    0x2e99(%rip),%rax        <span class="hljs-comment"># 3ff8 &lt;_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GLIBCXX_3.4&gt;</span><br>    115f:       48 89 c6                mov    %rax,%rsi<br>    1162:       48 89 d7                mov    %rdx,%rdi<br>    1165:       e8 f6 fe ff ff          callq  1060 &lt;_ZNSolsEPFRSoS_E@plt&gt;<br>    116a:       90                      nop<br>    116b:       5d                      pop    %rbp<br>    116c:       c3                      retq<br><span class="hljs-comment"># od --skip-bytes=$((0x4040 - 0x4038 + 0x3038)) --read-bytes=8 --format=xL libfoo.so</span><br>0030100 0000000000002001<br><span class="hljs-comment"># od --skip-bytes=$((0x2001 - 0x2000 + 0x2000)) --read-bytes=4 --format=xC -c libfoo.so</span><br>0020001  76  61  72  00<br>          v   a   r  \0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --wide --relocs libfoo.so</span><br>Relocation section <span class="hljs-string">&#x27;.rela.dyn&#x27;</span> at offset 0x598 contains 13 entries:<br>    Offset             Info             Type               Symbol<span class="hljs-string">&#x27;s Value  Symbol&#x27;</span>s Name + Addend<br>0000000000004040  0000000000000008 R_X86_64_RELATIVE                         2001<br>0000000000003ff0  0000000c00000006 R_X86_64_GLOB_DAT      0000000000004040 var + 0<br></code></pre></td></tr></table></figure><h1 id="global-string">Global String</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;iostream&gt;</span><br>const std::string var = <span class="hljs-string">&quot;var&quot;</span>;<br>void <span class="hljs-function"><span class="hljs-title">foo</span></span>() &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">var &lt;&lt; std::endl;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-about-global-strings/global-string.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) bt<br><span class="hljs-comment">#0  0x00007ffff7f3304b in std::__cxx11::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;::basic_string(char const*, std::allocator&lt;char&gt; const&amp;) ()</span><br>   from /usr/lib/x86_64-linux-gnu/libstdc++.so.6<br><span class="hljs-comment">#1  0x00007ffff7fcb21c in __static_initialization_and_destruction_0 (__initialize_p=1, __priority=65535) at foo.cpp:2</span><br><span class="hljs-comment">#2  0x00007ffff7fcb27a in _GLOBAL__sub_I_foo.cpp(void) () at foo.cpp:5</span><br><span class="hljs-comment">#3  0x00007ffff7fe3d4c in call_init (l=&lt;optimized out&gt;, argc=argc@entry=1, argv=argv@entry=0x7fffffffece8, env=env@entry=0x7fffffffecf8) at dl-init.c:72</span><br><span class="hljs-comment">#4  0x00007ffff7fe3e32 in _dl_init (main_map=0x7ffff7ffe1a0, argc=1, argv=0x7fffffffece8, env=0x7fffffffecf8) at dl-init.c:119</span><br><span class="hljs-comment">#5  0x00007ffff7fd60ca in _dl_start_user () from /root/glibc/build/install/lib/ld-linux-x86-64.so.2</span><br></code></pre></td></tr></table></figure><ol type="1"><li>glibc 会负责调用 .init 函数和 .init_array 指定的函数；</li><li>gcc 使用 .init_array 指定初始化函数，.init 函数只是一个空壳。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">call_init</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> link_map* l, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv, <span class="hljs-type">char</span>** env)</span> </span>&#123;<br>    <span class="hljs-comment">// Now run the local constructors.  There are two forms of them:</span><br>    <span class="hljs-comment">// - the one named by DT_INIT</span><br>    <span class="hljs-comment">// - the others in the DT_INIT_ARRAY.</span><br>    <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_INIT] != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">DL_CALL_DT_INIT</span>(<br>            l, l-&gt;l_addr + l-&gt;l_info[DT_INIT]-&gt;d_un.d_ptr, argc, argv, env);<br>    &#125;<br><br>    <span class="hljs-comment">// Next see whether there is an array with initialization functions.</span><br>    <span class="hljs-built_in">ElfW</span>(Dyn)* init_array = l-&gt;l_info[DT_INIT_ARRAY];<br>    <span class="hljs-keyword">if</span> (init_array != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> jm =<br>            l-&gt;l_info[DT_INIT_ARRAYSZ]-&gt;d_un.d_val / <span class="hljs-built_in">sizeof</span>(<span class="hljs-built_in">ElfW</span>(Addr));<br>        <span class="hljs-built_in">ElfW</span>(Addr)* addrs = (<span class="hljs-built_in">ElfW</span>(Addr)*)(init_array-&gt;d_un.d_ptr + l-&gt;l_addr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; jm; ++j) &#123;<br>            ((<span class="hljs-type">init_t</span>)addrs[j])(argc, argv, env);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="thread-local-raw-string">Thread Local Raw String</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">thread_local</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tbss_var = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">thread_local</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* tdata_var = <span class="hljs-string">&quot;tdata_var&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    tbss_var = <span class="hljs-string">&quot;tbss_var&quot;</span>;<br>    std::cout &lt;&lt; tbss_var &lt;&lt; std::endl;<br>    std::cout &lt;&lt; tdata_var &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-about-global-strings/thread-local-raw-string.png" /></p><ol type="1"><li>为了保证 thread local 语义，ld 会将 .tbss section 和 .tdata section 中的数据拷贝到线程私有区域，详细信息请参考 <a href="https://chao-tic.github.io/blog/2018/12/25/tls">Chao-tic: A Deep dive into (implicit) Thread Local Storage</a> ；</li><li><code>__tls_get_addr</code> 是访问线程私有变量的两种方式之一，访问方式可以通过编译选项（<code>-ftls-model=initial-exec</code>）控制，详细信息请参考 <a href="https://stackoverflow.com/questions/13106049/what-is-the-performance-penalty-of-c11-thread-local-variables-in-gcc-4-8">Stack Overflow: What is the performance penalty of C++11 thread_local variables in GCC 4.8?</a> ；</li><li>使用选项 <code>-ftls-model=initial-exec</code> 编译的库带有 <code>STATIC_TLS</code> flag ，可以通过命令 <code>readelf --dynamic &lt;lib&gt; | grep FLAGS</code> 识别。</li></ol><h1 id="thread-local-string">Thread Local String</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">thread_local</span> std::string var = <span class="hljs-string">&quot;var&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; var &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-about-global-strings/thread-local-string.png" /></p><p>TLS init funtion 负责调用 thread local string 的构造函数，它使用一个 thread local bool 变量来记录构造函数是否已经被调用过，避免重复调用。</p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://chao-tic.github.io/blog/2018/12/25/tls">Chao-tic: A Deep dive into (implicit) Thread Local Storage</a></li><li><a href="https://uclibc.org/docs/tls.pdf">ELF Handling For Thread-Local Storage</a></li><li><a href="https://docs.oracle.com/cd/E19683-01/817-3677/chapter8-1/index.html">Oracle: Thread-Local Storage</a></li><li><a href="https://stackoverflow.com/questions/13106049/what-is-the-performance-penalty-of-c11-thread-local-variables-in-gcc-4-8">Stack Overflow: What is the performance penalty of C++11 thread_local variables in GCC 4.8?</a></li><li><a href="https://maskray.me/blog/2021-02-14-all-about-thread-local-storage">MaskRay: All about thread-local storage</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>The First Three Items Of GOT</title>
    <link href="/2021/01/30/computer-science/dynamic-linking/the-first-three-items-of-got/"/>
    <url>/2021/01/30/computer-science/dynamic-linking/the-first-three-items-of-got/</url>
    
    <content type="html"><![CDATA[<h1 id="导读">导读</h1><ol type="1"><li>本篇文章提及的 Global Offset Table 是 .got.plt section ，不是 .got section ，<a href="https://stackoverflow.com/questions/49812485/where-is-the-got0-global-offset-table-used">Dynamic Linking: Introduction To Elf File</a> 介绍了两者的差异；</li><li>GOT[0] 是 .dynamic section 的首地址，ld.so 自加载的过程会依赖于它；</li><li>GOT[1] 指向 <code>link_map</code> ；</li><li>GOT[2] 指向 <code>_dl_runtime_resolve_xsave</code> 。</li></ol><h1 id="环境-例子">环境 &amp; 例子</h1><p>本文使用的环境与 <a href="https://clcanny.github.io/2020/11/24/dynamic-linking-introduction-to-elf-file/#%E7%8E%AF%E5%A2%83">Dynamic Linking: Introduction To Elf File</a> 使用的环境一致。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// gcc -fPIC -ggdb -O0 -shared -Wl,--dynamic-linker=/root/glibc/build/install/lib/ld-linux-x86-64.so.2 foo.cpp -o libfoo.so</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// gcc main.cpp -L$PWD -Wl,-rpath=$PWD -Wl,--dynamic-linker=/root/glibc/build/install/lib/ld-linux-x86-64.so.2 -lfoo -o main</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="got0">GOT[0]</h1><p>摘抄自 <a href="https://stackoverflow.com/questions/49812485/where-is-the-got0-global-offset-table">Stack Overflow: Where is the GOT[0] (global offset table) used?</a> ：</p><blockquote><p>The tables first entry (number zero) is reserved to hold the address of the dynamic structure, referenced with the symbol _DYNAMIC.</p></blockquote><p>摘抄自 <a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf">System V Application Binary Interface (Version 1.0)</a> ：</p><blockquote><p>This (GOT[0]) allows a program, such as the dynamic linker, to find its own dynamic structure without having yet processed its relocation entries. This is especially important for the dynamic linker, because it must initialize itself without relying on other programs to relocate its memory image.</p></blockquote><h2 id="有人访问-ld.so-的-got0">有人访问 ld.so 的 GOT[0]</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers /root/glibc/build/install/lib/ld-2.28.so | grep -E &quot;Nr|.got.plt|.dynamic&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [17] .dynamic          DYNAMIC          0000000000026e78  00025e78<br>       0000000000000170  0000000000000010  WA       5     0     8<br>  [19] .got.plt          PROGBITS         0000000000027000  00026000<br>       0000000000000050  0000000000000008  WA       0     0     8<br><span class="hljs-comment"># od --skip-bytes=0x26000 --read-bytes=8 --format=xL /root/glibc/build/install/lib/ld-2.28.so</span><br>0460000 0000000000026e78<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># (gdb) info proc mappings</span><br>0x7ffff7fd6000     0x7ffff7fd7000     0x1000        0x0 /root/glibc/build/install/lib/ld-2.28.so<br><span class="hljs-comment"># (gdb) rwatch *(unsigned long long*)(0x7ffff7fd6000 + 0x27000)</span><br><span class="hljs-comment"># (gdb) start</span><br>Hardware <span class="hljs-built_in">read</span> watchpoint 1: *(unsigned long long*)(0x7ffff7fd6000 + 0x27000)<br>Value = 159352<br><span class="hljs-comment"># (gdb) bt</span><br>0x00007ffff7fd7e01 <span class="hljs-keyword">in</span> _dl_start (arg=0x7fffffffed40) at ../sysdeps/x86_64/dl-machine.h:59<br>0x00007ffff7fd7098 <span class="hljs-keyword">in</span> _start () from /root/glibc/build/install/lib/ld-linux-x86-64.so.2<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /root/glibc/glibc-2.28/sysdeps/x86_64/dl-machine.h</span><br><span class="hljs-comment">// Return the link-time address of _DYNAMIC.  Conveniently, this is the</span><br><span class="hljs-comment">// first element of the GOT.  This must be inlined in a function which</span><br><span class="hljs-comment">// uses global data.</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((unused))</span> <span class="hljs-title">elf_machine_dynamic</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// This produces an IP-relative reloc which is resolved at link time.</span><br>    <span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span> _GLOBAL_OFFSET_TABLE_[] attribute_hidden</span>;<br>    <span class="hljs-keyword">return</span> _GLOBAL_OFFSET_TABLE_[<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-comment">// Return the run-time load address of the shared object.</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((unused))</span></span><br><span class="hljs-function"><span class="hljs-title">elf_machine_load_address</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// Compute the difference between the runtime address of _DYNAMIC as seen</span><br>    <span class="hljs-comment">// by an IP-relative reference, and the link-time address found in the</span><br>    <span class="hljs-comment">// special unrelocated first GOT entry.</span><br>    <span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Dyn)</span> _DYNAMIC[] attribute_hidden</span>;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">ElfW</span>(Addr)) &amp; _DYNAMIC - <span class="hljs-built_in">elf_machine_dynamic</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="无人访问其它-elf-文件的-got0">无人访问其它 ELF 文件的 GOT[0]</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|.got.plt|.dynamic&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [21] .dynamic          DYNAMIC          0000000000003dd8  00002dd8<br>       0000000000000200  0000000000000010  WA       6     0     8<br>  [23] .got.plt          PROGBITS         0000000000004000  00003000<br>       0000000000000020  0000000000000008  WA       0     0     8<br><span class="hljs-comment"># od --skip-bytes=0x3000 --read-bytes=8 --format=xL main</span><br>0030000 0000000000003dd8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># (gdb) info proc mappings</span><br>0x555555554000     0x555555555000     0x1000        0x0 /root/main<br><span class="hljs-comment"># (gdb) rwatch *(unsigned long long*)(0x555555554000 + 0x4000)</span><br><span class="hljs-comment"># (gdb) start</span><br>Temporary breakpoint 3, 0x0000555555555139 <span class="hljs-keyword">in</span> main ()<br></code></pre></td></tr></table></figure><h1 id="got1-got2">GOT[1] &amp; GOT[2]</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|.got.plt&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [23] .got.plt          PROGBITS         0000000000004000  00003000<br>       0000000000000020  0000000000000008  WA       0     0     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># (gdb) watch *(unsigned long long*)(0x555555554000 + 0x4000 + 0x8)</span><br><span class="hljs-comment"># (gdb) start</span><br>Hardware watchpoint 1: *(unsigned long long*)(0x555555554000 + 0x4000 + 0x8)<br>Old value = 0<br>New value = 140737354129808<br><span class="hljs-comment"># (gdb) bt</span><br>elf_machine_runtime_setup (profile=0, lazy=1, l=0x7ffff7ffe190) at ../sysdeps/x86_64/dl-machine.h:100<br>_dl_relocate_object (scope=0x7ffff7ffe4f0, reloc_mode=&lt;optimized out&gt;, consider_profiling=consider_profiling@entry=0) at dl-reloc.c:258<br>0x00007ffff7fdb57d <span class="hljs-keyword">in</span> dl_main (phdr=&lt;optimized out&gt;, phnum=&lt;optimized out&gt;, user_entry=&lt;optimized out&gt;, auxv=&lt;optimized out&gt;) at rtld.c:2197<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> __attribute__((unused, always_inline))<br><span class="hljs-built_in">elf_machine_runtime_setup</span>(<span class="hljs-keyword">struct</span> link_map* l, <span class="hljs-type">int</span> lazy, <span class="hljs-type">int</span> profile) &#123;<br>    <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_JMPREL] &amp;&amp; lazy) &#123;<br>        <span class="hljs-comment">// The GOT entries for functions in the PLT have not yet been filled</span><br>        <span class="hljs-comment">// in.  Their initial contents will arrange when called to push an</span><br>        <span class="hljs-comment">// offset into the .rel.plt section, push _GLOBAL_OFFSET_TABLE_[1],</span><br>        <span class="hljs-comment">// and then jump to _GLOBAL_OFFSET_TABLE_[2].</span><br>        Elf64_Addr* got = (Elf64_Addr*)<span class="hljs-built_in">D_PTR</span>(l, l_info[DT_PLTGOT]);<br><br>        <span class="hljs-comment">// Identify this shared object.</span><br>        *(<span class="hljs-built_in">ElfW</span>(Addr)*)(got + <span class="hljs-number">1</span>) = (<span class="hljs-built_in">ElfW</span>(Addr))l;<br><br>        <span class="hljs-comment">// The got[2] entry contains the address of a function which gets</span><br>        <span class="hljs-comment">// called to get the address of a so far unresolved function and</span><br>        <span class="hljs-comment">// jump to it.  The profiling extension of the dynamic linker allows</span><br>        <span class="hljs-comment">// to intercept the calls to collect information.  In this case we</span><br>        <span class="hljs-comment">// don&#x27;t store the address in the GOT so that all future calls also</span><br>        <span class="hljs-comment">// end in this function.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// This function will get called to fix up the GOT entry</span><br>        <span class="hljs-comment">// indicated by the offset on the stack, and then jump to</span><br>        <span class="hljs-comment">// the resolved address.</span><br>        *(<span class="hljs-built_in">ElfW</span>(Addr)*)(got + <span class="hljs-number">2</span>) = (<span class="hljs-built_in">ElfW</span>(Addr)) &amp; _dl_runtime_resolve_xsavec;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lazy;<br>&#125;<br></code></pre></td></tr></table></figure><p>GOT[1] 指向 <code>link_map</code> ，GOT[2] 指向 <code>_dl_runtime_resolve_xsavec</code> ，它们由 <code>elf_machine_runtime_setup</code> 函数负责填写。</p><h1 id="如何合并-elf-文件">如何合并 ELF 文件？</h1><ol type="1"><li>.got.plt section 的前三项不要参与合并；</li><li>.plt section 的跳转位置需要修正；</li><li>.rela.plt section 的 <code>r_offset</code> 字段需要修正。</li></ol><h1 id="参考资料">参考资料</h1><ul><li><a href="https://stackoverflow.com/questions/49812485/where-is-the-got0-global-offset-table-used">Stack Overflow: Where is the GOT[0] (global offset table) used?</a></li><li><a href="https://github.com/hjl-tools/x86-psABI/wiki/x86-64-psABI-1.0.pdf">System V Application Binary Interface (Version 1.0)</a></li><li><a href="https://www.ucw.cz/~hubicka/papers/abi/node22.html">System V Application Binary Interface (Draft Version 0.90): Dynamic Linking</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Compatibility Of Hash Tables</title>
    <link href="/2020/12/22/computer-science/dynamic-linking/compatibility-of-hash-tables/"/>
    <url>/2020/12/22/computer-science/dynamic-linking/compatibility-of-hash-tables/</url>
    
    <content type="html"><![CDATA[<h1 id="导读">导读</h1><ol type="1"><li>指定编译选项 <code>-Wl,--hash-style=both</code> 时，dynsym section 的符号排列顺序需要满足 gnu hash table 的要求，具体可参考 <a href="https://clcanny.github.io/2020/11/20/dynamic-linking-search-symbols-in-one-binary/">Dynamic Linking: Search Symbols In One Binary</a> ：<ol type="1"><li>LOCAL 符号排在 GLOBAL 符号之前；</li><li>导入符号排在导出符号之前；</li><li>导出符号按桶排序；</li></ol></li><li><a href="https://flapenguin.me/elf-dt-hash">ELF: symbol lookup via DT_HASH</a> 将 SysV hash table 讲得非常清楚：<ol type="1"><li>SysV hash table 的长度和 dynamic symbol table 的长度相同；</li><li>bucket 记录每个桶的起始符号；</li><li>chain 是 dynamic symbol table 的附属指针数组；</li><li>chain[id] 将 Ndx = STN_UNDEF 的符号作为结束符。</li></ol></li></ol><h1 id="sysv-hash-table-详解">SysV hash table 详解</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test_hash.cpp</span><br><span class="hljs-comment">// g++ -std=c++11 -shared -fPIC -Wl,--hash-style=both test_hash.cpp -o libtest_hash.so</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">more</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="元数据">元数据</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> _dl_setup_hash(<span class="hljs-keyword">struct</span> link_map* <span class="hljs-built_in">map</span>) &#123;<br>  <span class="hljs-keyword">if</span> (__glibc_likely(<span class="hljs-built_in">map</span>-&gt;l_info[ADDRIDX(DT_GNU_HASH)] != <span class="hljs-literal">NULL</span>)) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">map</span>-&gt;l_info[DT_HASH]) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// The entries in the .hash table always have a size of 32 bits.</span><br>  Elf_Symndx* hash = (<span class="hljs-type">void</span>*)D_PTR(<span class="hljs-built_in">map</span>, l_info[DT_HASH]);<br>  <span class="hljs-built_in">map</span>-&gt;l_nbuckets = *hash++;<br>  <span class="hljs-comment">// Skip nchain.</span><br>  hash++;<br>  <span class="hljs-built_in">map</span>-&gt;l_buckets = hash;<br>  hash += <span class="hljs-built_in">map</span>-&gt;l_nbuckets;<br>  <span class="hljs-built_in">map</span>-&gt;l_chain = hash;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">elf_hash_table</span> &#123;<br>  <span class="hljs-type">uint32_t</span> nbucket;<br>  <span class="hljs-type">uint32_t</span> nchain;<br>  <span class="hljs-type">uint32_t</span> bucket[nbucket];<br>  <span class="hljs-type">uint32_t</span> chain[nchain];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers libtest_hash.so  | grep -E &quot;Nr|hash&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 2] .<span class="hljs-built_in">hash</span>             HASH             00000000000001b8  000001b8<br>       0000000000000058  0000000000000004   A       4     0     8<br>  [ 3] .gnu.hash         GNU_HASH         0000000000000210  00000210<br>       000000000000004c  0000000000000000   A       4     0     8<br><span class="hljs-comment"># export hash_start_addr=0x1b8</span><br><span class="hljs-comment"># export hash_size=0x58</span><br><span class="hljs-comment"># od --skip-bytes=$hash_start_addr --read-bytes=$hash_size --format=xI libtest_hash.so</span><br>0000670 00000003 00000011 0000000f 0000000a<br>0000710 0000000e 00000000 00000000 00000000<br>0000730 00000002 00000009 00000004 00000008<br>0000750 00000000 00000000 00000010 00000005<br>0000770 0000000d 00000003 0000000c 00000006<br>0001010 0000000b 00000007<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">nbucket</th><th style="text-align: center;">nchain</th><th style="text-align: center;">bucket[bucket]</th><th style="text-align: center;">chain[nchain]</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0x3</td><td style="text-align: center;">0x11</td><td style="text-align: center;">[0xf, 0xa, 0xe]</td><td style="text-align: center;">[0x0, ...]</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dyn-syms libtest_hash.so</span><br>Symbol table <span class="hljs-string">&#x27;.dynsym&#x27;</span> contains 17 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>     1: 0000000000000608     0 SECTION LOCAL  DEFAULT   10<br>     2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__<br>     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses<br>     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab<br>     5: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable<br>     6: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)<br>     7: 000000000000075a     6 FUNC    GLOBAL DEFAULT   12 _Z4hahav<br>     8: 0000000000000760     6 FUNC    GLOBAL DEFAULT   12 _Z4morev<br>     9: 0000000000000754     6 FUNC    GLOBAL DEFAULT   12 _Z4testv<br>    10: 0000000000200b08     0 NOTYPE  GLOBAL DEFAULT   23 _end<br>    11: 0000000000200b00     0 NOTYPE  GLOBAL DEFAULT   22 _edata<br>    12: 000000000000074e     6 FUNC    GLOBAL DEFAULT   12 _Z3barv<br>    13: 0000000000000748     6 FUNC    GLOBAL DEFAULT   12 _Z3foov<br>    14: 0000000000200b00     0 NOTYPE  GLOBAL DEFAULT   23 __bss_start<br>    15: 0000000000000608     0 FUNC    GLOBAL DEFAULT   10 _init<br>    16: 0000000000000768     0 FUNC    GLOBAL DEFAULT   13 _fini<br></code></pre></td></tr></table></figure><p>nchain 是 17 ，chain 的长度是 17 ，dynamic symbol table 有 17 个 entries 。</p><h2 id="哈希函数">哈希函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ios&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">elf_hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> </span>&#123;<br>  <span class="hljs-type">uint32_t</span> h = <span class="hljs-number">0</span>, g;<br>  <span class="hljs-keyword">for</span> (; *name; name++) &#123;<br>    h = (h &lt;&lt; <span class="hljs-number">4</span>) + *name;<br>    <span class="hljs-keyword">if</span> (g = h &amp; <span class="hljs-number">0xf0000000</span>) &#123;<br>      h ^= g &gt;&gt; <span class="hljs-number">24</span>;<br>    &#125;<br>    h &amp;= ~g;<br>  &#125;<br>  <span class="hljs-keyword">return</span> h;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; std::hex;<br>  std::vector&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt; symbol_names&#123;<span class="hljs-string">&quot;_Z4hahav&quot;</span>,<br>                                        <span class="hljs-string">&quot;_Z4morev&quot;</span>,<br>                                        <span class="hljs-string">&quot;_Z4testv&quot;</span>,<br>                                        <span class="hljs-string">&quot;_Z3barv&quot;</span>,<br>                                        <span class="hljs-string">&quot;_Z3foov&quot;</span>,<br>                                        <span class="hljs-string">&quot;_end&quot;</span>,<br>                                        <span class="hljs-string">&quot;_edata&quot;</span>,<br>                                        <span class="hljs-string">&quot;__bss_start&quot;</span>,<br>                                        <span class="hljs-string">&quot;_init&quot;</span>,<br>                                        <span class="hljs-string">&quot;_fini&quot;</span>&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* symbol_name : symbol_names) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;0x&quot;</span> &lt;&lt; <span class="hljs-built_in">elf_hash</span>(symbol_name) &lt;&lt; std::endl;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">dynsym_id</th><th style="text-align: center;">symbol_name</th><th style="text-align: center;">hash_value</th><th style="text-align: center;">bucket_id</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">_Z4hahav</td><td style="text-align: center;">0xdae78c6</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">_Z4morev</td><td style="text-align: center;">0xdb46e86</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">9</td><td style="text-align: center;">_Z4testv</td><td style="text-align: center;">0xdbaccf6</td><td style="text-align: center;">1</td></tr><tr class="even"><td style="text-align: center;">10</td><td style="text-align: center;">_end</td><td style="text-align: center;">0x65c44</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">11</td><td style="text-align: center;">_edata</td><td style="text-align: center;">0x65ba8a1</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">12</td><td style="text-align: center;">_Z3barv</td><td style="text-align: center;">0x4d988f6</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">13</td><td style="text-align: center;">_Z3foov</td><td style="text-align: center;">0x4d9d606</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">14</td><td style="text-align: center;">__bss_start</td><td style="text-align: center;">0x90ff134</td><td style="text-align: center;">2</td></tr><tr class="odd"><td style="text-align: center;">15</td><td style="text-align: center;">_init</td><td style="text-align: center;">0x660504</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">16</td><td style="text-align: center;">_fini</td><td style="text-align: center;">0x65d049</td><td style="text-align: center;">1</td></tr></tbody></table><h2 id="哈希表">哈希表</h2><p><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-compatibility-of-hash-tables/hash-table.png" /></p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://flapenguin.me/elf-dt-hash">ELF: symbol lookup via DT_HASH</a></li><li><a href="https://elinux.org/images/1/18/C_AMOROSO_Fast_lkm_loader_ELC-E_2009.pdf">A Fast LKM loader based on SysV ELF hash table</a></li><li><a href="https://answerywj.com/2020/05/14/ld-hash-style/">AnSwEr's Blog ：--hash-style 兼容性问题</a></li><li><a href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-48031.html">Oracle: Hash Table Section</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Relocation Types</title>
    <link href="/2020/12/03/computer-science/dynamic-linking/relocation-types/"/>
    <url>/2020/12/03/computer-science/dynamic-linking/relocation-types/</url>
    
    <content type="html"><![CDATA[<h1 id="导读">导读</h1><p>下图摘自 <a href="http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi_18.html">Keith Makan: Introduction to The ELF Format (Part VI): The Symbol Table and Relocations (Part 2)</a> ，展示了 relocation entry 的格式：</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-relocation-types/relocation-table-entry-format.png" /></p><h1 id="详解">详解</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// foo.cpp</span><br><span class="hljs-comment">// g++ -std=c++11 foo.cpp -O0 -ggdb -shared -fPIC -o libfoo.so</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span>* pa = &amp;a;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b;<br><span class="hljs-type">int</span>* pb = &amp;b;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; *pa + *pb &lt;&lt; std::endl; &#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-comment">// g++ main.cpp -O0 -ggdb -Wl,--dynamic-linker=/root/glibc/build/install/lib/ld-linux-x86-64.so.2 \</span><br><span class="hljs-comment">//     -L$&#123;PWD&#125; -Wl,-rpath=$&#123;PWD&#125; -lfoo                                                           \</span><br><span class="hljs-comment">//     -Wl,-rpath=/usr/lib/x86_64-linux-gnu                                                       \</span><br><span class="hljs-comment">//     -Wl,-rpath=/lib/x86_64-linux-gnu                                                           \</span><br><span class="hljs-comment">//     -o main</span><br><span class="hljs-type">int</span> b = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --relocs libfoo.so</span><br>Relocation section <span class="hljs-string">&#x27;.rela.dyn&#x27;</span> at offset 0x5e0 contains 15 entries:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000003db0  000000000008 R_X86_64_RELATIVE                    1130<br>000000003db8  000000000008 R_X86_64_RELATIVE                    11c5<br>000000003dc0  000000000008 R_X86_64_RELATIVE                    10f0<br>000000004038  000000000008 R_X86_64_RELATIVE                    4038<br>000000003fb8  000100000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0<br>000000003fc0  000200000006 R_X86_64_GLOB_DAT 0000000000000000 _ZSt4endlIcSt11char_tr@GLIBCXX_3.4 + 0<br>000000003fc8  000500000006 R_X86_64_GLOB_DAT 0000000000000000 _ZSt4cout@GLIBCXX_3.4 + 0<br>000000003fd0  000f00000006 R_X86_64_GLOB_DAT 0000000000004048 pa + 0<br>000000003fd8  001000000006 R_X86_64_GLOB_DAT 0000000000004050 pb + 0<br>000000003fe0  000900000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0<br>000000003fe8  000a00000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0<br>000000003ff0  000b00000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0<br>000000003ff8  000c00000006 R_X86_64_GLOB_DAT 0000000000000000 _ZNSt8ios_base4InitD1E@GLIBCXX_3.4 + 0<br>000000004048  000d00000001 R_X86_64_64       0000000000004040 a + 0<br>000000004050  000700000001 R_X86_64_64       0000000000000000 b + 0<br><br>Relocation section <span class="hljs-string">&#x27;.rela.plt&#x27;</span> at offset 0x748 contains 4 entries:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000004018  000300000007 R_X86_64_JUMP_SLO 0000000000000000 __cxa_atexit@GLIBC_2.2.5 + 0<br>000000004020  000400000007 R_X86_64_JUMP_SLO 0000000000000000 _ZNSolsEPFRSoS_E@GLIBCXX_3.4 + 0<br>000000004028  000600000007 R_X86_64_JUMP_SLO 0000000000000000 _ZNSt8ios_base4InitC1E@GLIBCXX_3.4 + 0<br>000000004030  000800000007 R_X86_64_JUMP_SLO 0000000000000000 _ZNSolsEi@GLIBCXX_3.4 + 0<br></code></pre></td></tr></table></figure><p>从 <a href="https://www.ucw.cz/~hubicka/papers/abi/node19.html">United Computer Wizards: Relocation Types</a> 找到 AMD x86-64 relocation types ：</p><table><thead><tr class="header"><th style="text-align: center;">Name</th><th style="text-align: center;">Value</th><th style="text-align: center;">Field</th><th style="text-align: center;">Calculation</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">R_X86_64_NONE</td><td style="text-align: center;">0</td><td style="text-align: center;">none</td><td style="text-align: center;">none</td></tr><tr class="even"><td style="text-align: center;">R_X86_64_64</td><td style="text-align: center;">1</td><td style="text-align: center;">word64</td><td style="text-align: center;">S + A</td></tr><tr class="odd"><td style="text-align: center;">R_X86_64_COPY</td><td style="text-align: center;">5</td><td style="text-align: center;">none</td><td style="text-align: center;">none</td></tr><tr class="even"><td style="text-align: center;">R_X86_64_GLOB_DAT</td><td style="text-align: center;">6</td><td style="text-align: center;">word64</td><td style="text-align: center;">S</td></tr><tr class="odd"><td style="text-align: center;">R_X86_64_JUMP_SLOT</td><td style="text-align: center;">7</td><td style="text-align: center;">word64</td><td style="text-align: center;">S</td></tr><tr class="even"><td style="text-align: center;">R_X86_64_RELATIVE</td><td style="text-align: center;">8</td><td style="text-align: center;">word64</td><td style="text-align: center;">BaseAddressAfterLoading + Addend</td></tr></tbody></table><h2 id="r_x86_64_64">R_X86_64_64</h2><p><a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.98.pdf">System V Application Binary Interface: AMD64 Architecture Processor Supplement</a> 说 R_X86_64_64 的重定位公式是：S + A 。</p><blockquote><p>S represents the value of the symbol whose index resides in the relocation entry. A represents the addend used to compute the value of the relocatable field.</p></blockquote><ol type="1"><li>不妨将 S 理解成符号在虚存中的地址，A 理解成相对于符号的偏移量；</li><li>计算 S 需要在所有动态链接库中搜索符号，因此重定位 R_X86_64_64 表项会用到符号绑定。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># LD_DEBUG=bindings ./main 2&gt;&amp;1 | grep -E &quot;\&lt;a\&gt;|\&lt;b\&gt;&quot;</span><br>656: binding file /root/talk/relocation_types/libfoo.so [0] to /root/talk/relocation_types/libfoo.so [0]: normal symbol `a<span class="hljs-string">&#x27;</span><br><span class="hljs-string">656: binding file /root/talk/relocation_types/libfoo.so [0] to ./main [0]: normal symbol</span><br></code></pre></td></tr></table></figure><ol type="1"><li>无论符号是否在同一个动态链接库内，重定位 R_X86_64_64 表项都会发生符号绑定；</li><li>Symbol value of <code>pa</code> 是 <code>a</code> 的地址，symbol value of <code>pb</code> 是 0 ，两者对符号查找有什么影响？</li></ol><h2 id="r_x86_64_relative">R_X86_64_RELATIVE</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --relocs libfoo.so</span><br>Relocation section <span class="hljs-string">&#x27;.rela.dyn&#x27;</span> at offset 0x5e0 contains 15 entries:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000003db0  000000000008 R_X86_64_RELATIVE                    1130<br>000000003db8  000000000008 R_X86_64_RELATIVE                    11c5<br>000000003dc0  000000000008 R_X86_64_RELATIVE                    10f0<br>000000004038  000000000008 R_X86_64_RELATIVE                    4038<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># objdump -d -j .text libfoo.so | grep -E &quot;(1130|11c5|10f0|4038).*&gt;:&quot; | sort</span><br>00000000000010f0 &lt;__do_global_dtors_aux&gt;:<br>0000000000001130 &lt;frame_dummy&gt;:<br>00000000000011c5 &lt;_GLOBAL__sub_I_foo.cpp&gt;:<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) p/x 0x7ffff7fcb000 + 0x4038<br><span class="hljs-variable">$1</span> = 0x7ffff7fcf038<br>(gdb) x/a 0x7ffff7fcb000 + 0x4038<br>0x7ffff7fcf038: 0x7ffff7fcf038<br></code></pre></td></tr></table></figure><p>.rela.dyn 指导运行时链接器：</p><ol type="1"><li>将 0x3db0 填上 <code>frame_dummy</code> 的首地址；</li><li>将 0x3db8 填上 <code>_GLOBAL__sub_I_foo.cpp</code> 的首地址；</li><li>将 0x3dc0 填上 <code>__do_global_dtors_aux</code> 的首地址；</li><li>将 0x4038 指向它自己。</li></ol><h2 id="r_x86_64_glob_dat">R_X86_64_GLOB_DAT</h2><p>从 <a href="https://stevens.netmeister.org/631/elf.html">Acronyms relevant to Executable and Linkable Format (ELF)</a> 摘抄了一段概述：</p><blockquote><p>So what about R_X86_64_GLOB_DAT relocation type in ld.so? First, <code>RESOLVE_MAP</code> (a macro defined within elf/dl-reloc.c) is called (with <code>r_type</code> = <code>R_X86_64_GLOB_DAT</code>) to find out which ELF binary (could be the user's program or its dependent dynamic libraries) contains this symbol. Then R_X86_64_GLOB_DAT relocation type is calculated as Base Address + Symbol Value + Addend where Base Address is the base address of ELF binary which contains the symbol, and Symbol Value is the symbol value from the symbol table of ELF binary which contains the symbol.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// elf_machine_rela 内嵌在 _dl_relocate_object 内，因而可以使用定义于 _dl_relocate_object 作用域内的变量。</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">elf_machine_rela</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> link_map* <span class="hljs-built_in">map</span>,</span><br><span class="hljs-params">                      <span class="hljs-type">const</span> ElfW(Rela) * reloc,</span><br><span class="hljs-params">                      <span class="hljs-type">const</span> ElfW(Sym) * sym,</span><br><span class="hljs-params">                      <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> r_found_version* version,</span><br><span class="hljs-params">                      <span class="hljs-type">void</span>* <span class="hljs-type">const</span> reloc_addr_arg,</span><br><span class="hljs-params">                      <span class="hljs-type">int</span> skip_ifunc)</span> &#123;<br>  ElfW(Addr)* <span class="hljs-type">const</span> reloc_addr = reloc_addr_arg;<br>  <span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> r_type = ELFW(R_TYPE)(reloc-&gt;r_info);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">sym_map</span> =</span> RESOLVE_MAP(&amp;sym, version, r_type);<br>  <span class="hljs-comment">// The core function of `RESOLVE_MAP` macro is:</span><br>  <span class="hljs-comment">// _dl_lookup_symbol_x(strtab + sym-&gt;st_name,</span><br>  <span class="hljs-comment">//                     l,</span><br>  <span class="hljs-comment">//                     &amp;sym,</span><br>  <span class="hljs-comment">//                     scope,</span><br>  <span class="hljs-comment">//                     version,</span><br>  <span class="hljs-comment">//                     elf_machine_type_class(r_type),</span><br>  <span class="hljs-comment">//                     DL_LOOKUP_ADD_DEPENDENCY,</span><br>  <span class="hljs-comment">//                     NULL);</span><br>  ElfW(Addr) value = SYMBOL_ADDRESS(sym_map, sym, <span class="hljs-literal">true</span>);<br>  <span class="hljs-comment">// The core function of `SYMBOL_ADDRESS` macro is:</span><br>  <span class="hljs-comment">// sym_map-&gt;l_addr + sym-&gt;st_value;</span><br>  <span class="hljs-keyword">switch</span> (r_type) &#123;<br>  <span class="hljs-keyword">case</span> R_X86_64_GLOB_DAT:<br>  <span class="hljs-keyword">case</span> R_X86_64_JUMP_SLOT:<br>    *reloc_addr = value + reloc-&gt;r_addend;<br>    <span class="hljs-keyword">break</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="r_x86_64_jump_slo">R_X86_64_JUMP_SLO</h2><h1 id="debug-技巧">Debug 技巧</h1><p>通过以下步骤能迅速定位到执行重定位的函数：</p><ol type="1"><li>通过 <code>info proc mappings</code> 得到动态链接库在虚拟内存中的偏移量（通过 <code>info sharedlibrary</code> 得到的是 .text section 的地址）；</li><li>通过 <code>watch *(unsigned long long*)(&lt;l_addr&gt; + &lt;offset&gt;)</code> 得到改变值的函数栈。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) info proc mappings<br>          Start Addr           End Addr       Size     Offset objfile<br>      0x7ffff7fcb000     0x7ffff7fcc000     0x1000        0x0 /test/libfoo.so<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">(gdb) watch *(unsigned long long*)(0x7ffff7fcb000 + 0x4038)<br>Hardware watchpoint 2: *(unsigned long long*)(0x7ffff7fcb000 + 0x4038)<br>(gdb) start<br>Hardware watchpoint 2: *(unsigned long long*)(0x7ffff7fcb000 + 0x4038)<br>Old value = &lt;unreadable&gt;<br>New value = 140737353936952<br>0x00007ffff7fe159c <span class="hljs-keyword">in</span> elf_machine_rela_relative (reloc_addr_arg=0x7ffff7fcf038, reloc=0x7ffff7fcb5c8, l_addr=140737353920512) at ../sysdeps/x86_64/dl-machine.h:539<br>539           *reloc_addr = l_addr + reloc-&gt;r_addend;<br></code></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><ul><li><a href="https://stevens.netmeister.org/631/elf.html">Acronyms relevant to Executable and Linkable Format (ELF)</a></li><li><a href="https://www.ucw.cz/~hubicka/papers/abi/node19.html">United Computer Wizards: Relocation Types</a></li><li><a href="https://reverseengineering.stackexchange.com/questions/6657/why-does-ldd-and-gdb-info-sharedlibrary-show-a-different-library-base-addr">Stack Exchange: Why does ldd and (gdb) info sharedlibrary show a different library base address?</a></li><li><a href="http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi_18.html">Keith Makan: Introduction to The ELF Format (Part VI): The Symbol Table and Relocations (Part 2)</a></li><li><a href="https://refspecs.linuxbase.org/elf/x86_64-abi-0.98.pdf">System V Application Binary Interface: AMD64 Architecture Processor Supplement</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Introduction To Elf File</title>
    <link href="/2020/11/24/computer-science/dynamic-linking/introduction-to-elf-file/"/>
    <url>/2020/11/24/computer-science/dynamic-linking/introduction-to-elf-file/</url>
    
    <content type="html"><![CDATA[<h1 id="导读">导读</h1><blockquote><p>“工欲善其事，必先利其器。”</p></blockquote><p>本文会介绍 ELF 文件以及阅读 ELF 文件的工具，熟悉 ELF 文件对探索动态链接是很有好处的。</p><h1 id="环境">环境</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> debian:buster<br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;837940593@qq.com&quot;</span></span><br><br><span class="hljs-keyword">ENV</span> DEBIAN_FRONTEND noninteractive<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y build-essential bear make gcc g++ gdb</span><br><br><span class="hljs-comment"># Compile linker.</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /root/glibc</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root/glibc</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y wget</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y gawk bison texinfo gettext</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> wget http://ftp.gnu.org/gnu/libc/glibc-2.28.tar.gz</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -xzvf glibc-2.28.tar.gz</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> build</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /root/glibc/build</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> ../glibc-2.28/configure CFLAGS=<span class="hljs-string">&quot;-O1 -ggdb -w&quot;</span> --with-tls --enable-add-ons=nptl --prefix=<span class="hljs-string">&quot;<span class="hljs-variable">$PWD</span>/install&quot;</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> bear make -j8</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make install -j8</span><br><br><span class="hljs-comment"># Install tools.</span><br><span class="hljs-comment"># Install hexdump.</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y bsdmainutils</span><br><span class="hljs-comment"># Install lief.</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y python3 python3-pip</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> pip3 install lief</span><br><br><span class="hljs-keyword">CMD</span><span class="language-bash"> /bin/bash</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># uname -r</span><br>4.19.76-linuxkit<br><span class="hljs-comment"># cat /etc/*-release | grep -E &quot;VERSION_ID|ID&quot;</span><br>VERSION_ID=<span class="hljs-string">&quot;10&quot;</span><br>ID=debian<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># gcc --version | head -n 1</span><br>gcc (Debian 8.3.0-6) 8.3.0<br><span class="hljs-comment"># ldd --version | head -n 1</span><br>ldd (Debian GLIBC 2.28-10) 2.28<br></code></pre></td></tr></table></figure><h1 id="一个小例子">一个小例子</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// gcc -fPIC -ggdb -O0 -shared -Wl,--dynamic-linker=/root/glibc/build/install/lib/ld-linux-x86-64.so.2 foo.cpp -o libfoo.so</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ main.cpp -L$PWD -Wl,-rpath=$PWD -Wl,--dynamic-linker=/root/glibc/build/install/lib/ld-linux-x86-64.so.2 -lfoo -o main</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="了解-elf-文件">了解 ELF 文件</h1><h2 id="工具概述">工具概述</h2><h3 id="dump-二进制">Dump 二进制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=0 --read-bytes=8 --format=xL main</span><br><span class="hljs-comment"># 64 bits</span><br>0000000 00010102464c457f<br>0000010<br><span class="hljs-comment"># od --skip-bytes=0 --read-bytes=8 --format=xI main</span><br><span class="hljs-comment"># 32 bits</span><br>0000000 464c457f 00010102<br>0000010<br><span class="hljs-comment"># od --skip-bytes=0 --read-bytes=8 --format=xS main</span><br><span class="hljs-comment"># 16 bits</span><br>0000000 457f 464c 0102 0001<br>0000010<br><span class="hljs-comment"># od --skip-bytes=0 --read-bytes=8 --format=xC main</span><br><span class="hljs-comment"># 8 bits</span><br>0000000 7f 45 4c 46 02 01 01 00<br>0000010<br><span class="hljs-comment"># od --skip-bytes=0 --read-bytes=8 --format=xC -c main</span><br><span class="hljs-comment"># 8 bits with characters</span><br>0000000  7f  45  4c  46  02  01  01  00<br>        177   E   L   F 002 001 001  \0<br>0000010<br></code></pre></td></tr></table></figure><p>阅读字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># dd if=libfoo.so of=libfoo.strtab ibs=1 obs=1 skip=$((0x3660)) count=$((0x15e))</span><br>350+0 records <span class="hljs-keyword">in</span><br>350+0 records out<br>350 bytes copied, 0.000862803 s, 406 kB/s<br><span class="hljs-comment"># strings libfoo.strtab | head -n 2</span><br>crtstuff.c<br>deregister_tm_clones<br></code></pre></td></tr></table></figure><p>查找字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># strings -t x libfoo.so | head -n 2</span><br>319 __gmon_start__<br>328 _ITM_deregisterTMCloneTable<br></code></pre></td></tr></table></figure><p><code>x</code> 表示用十六进制显示字符串的 offset 。</p><h3 id="dump-汇编代码">Dump 汇编代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># objdump -d libfoo.so --start-address=0x1020 --stop-address=$((0x1020+0x10))</span><br>0000000000001020 &lt;.plt&gt;:<br>    1020:   ff 35 e2 2f 00 00       pushq  0x2fe2(%rip)  <span class="hljs-comment"># 4008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br>    1026:   ff 25 e4 2f 00 00       jmpq   *0x2fe4(%rip) <span class="hljs-comment"># 4010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br>    102c:   0f 1f 40 00             nopl   0x0(%rax)<br><span class="hljs-comment"># objdump -d -j .text main | tail -n 2</span><br>00000000000011b0 &lt;__libc_csu_fini&gt;:<br>    11b0:       c3                      retq<br><span class="hljs-comment"># objdump -d --disassemble-zeroes -j .data main | tail -n 2</span><br>0000000000004028 &lt;__dso_handle&gt;:<br>    4028:       28 40 00 00 00 00 00 00                             (@......<br></code></pre></td></tr></table></figure><h3 id="dump-元信息">Dump 元信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --file-header main</span><br><span class="hljs-comment"># readelf --program-headers main</span><br><span class="hljs-comment"># readelf --section-headers main</span><br></code></pre></td></tr></table></figure><h3 id="解析特定-sections">解析特定 sections</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | head -n 5 | tail -n 4</span><br>Dynamic section at offset 0x2dd8 contains 28 entries:<br>  Tag        Type                         Name/Value<br> 0x0000000000000001 (NEEDED)             Shared library: [libfoo.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<br><span class="hljs-comment"># readelf --symbols main | grep &quot;Symbol&quot; -A2</span><br>Symbol table <span class="hljs-string">&#x27;.dynsym&#x27;</span> contains 7 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>--<br>Symbol table <span class="hljs-string">&#x27;.symtab&#x27;</span> contains 69 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br><span class="hljs-comment"># readelf --dyn-syms main | grep &quot;Symbol&quot; -A2</span><br>Symbol table <span class="hljs-string">&#x27;.dynsym&#x27;</span> contains 7 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br><span class="hljs-comment"># readelf --relocs main | grep &quot;Relocation&quot; -A2</span><br>Relocation section <span class="hljs-string">&#x27;.rela.dyn&#x27;</span> at offset 0x4c8 contains 8 entries:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000003dc8  000000000008 R_X86_64_RELATIVE                    1130<br>--<br>Relocation section <span class="hljs-string">&#x27;.rela.plt&#x27;</span> at offset 0x588 contains 1 entry:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000004018  000400000007 R_X86_64_JUMP_SLO 0000000000000000 _Z3foov + 0<br><span class="hljs-comment"># readelf -p .strtab main | head -n 5 | tail -n 4</span><br>String dump of section <span class="hljs-string">&#x27;.strtab&#x27;</span>:<br>  [     1]  crtstuff.c<br>  [     c]  deregister_tm_clones<br>  [    21]  __do_global_dtors_aux<br></code></pre></td></tr></table></figure><h2 id="elf-文件概述">ELF 文件概述</h2><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png" /></p><p>File Header 和 Program Header 在 ELF 文件的开头，Section Header 在 ELF 文件的结尾。</p><p>接下来我们会用 readelf 直接查看元数据，也会用 od 以二进制方式看看每一个 Header 。</p><h3 id="file-header">File Header</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --file-header main</span><br>ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>  Class:                             ELF64<br>  Data:                              2<span class="hljs-string">&#x27;s complement, little endian</span><br><span class="hljs-string">  Version:                           1 (current)</span><br><span class="hljs-string">  OS/ABI:                            UNIX - System V</span><br><span class="hljs-string">  ABI Version:                       0</span><br><span class="hljs-string">  Type:                              DYN (Shared object file)</span><br><span class="hljs-string">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="hljs-string">  Version:                           0x1</span><br><span class="hljs-string">  Entry point address:               0x1050</span><br><span class="hljs-string">  Start of program headers:          64 (bytes into file)</span><br><span class="hljs-string">  Start of section headers:          14680 (bytes into file)</span><br><span class="hljs-string">  Flags:                             0x0</span><br><span class="hljs-string">  Size of this header:               64 (bytes)</span><br><span class="hljs-string">  Size of program headers:           56 (bytes)</span><br><span class="hljs-string">  Number of program headers:         11</span><br><span class="hljs-string">  Size of section headers:           64 (bytes)</span><br><span class="hljs-string">  Number of section headers:         30</span><br><span class="hljs-string">  Section header string table index: 29</span><br></code></pre></td></tr></table></figure><p>File Header 各个字段的含义可以参考<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format#File%20header">维基百科</a> 。</p><blockquote><p>The ELF header is 52 or 64 bytes long for 32-bit and 64-bit binaries respectively.</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=0 --read-bytes=64 --format=xC main</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">位移（八进制）</th><th style="text-align: center;">内容</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0000000</td><td style="text-align: center;">7f 45 4c 46</td><td style="text-align: center;">ELF (magic number).</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">02</td><td style="text-align: center;">1 is 32-bit format, 2 is 64-bit format.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">01</td><td style="text-align: center;">1 is big endianness, 2 is litte endianness.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">01</td><td style="text-align: center;">Set to 1 for the original and current version of ELF.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">00</td><td style="text-align: center;">ABI version, it is often set to 0.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">00</td><td style="text-align: center;">Further specifies the ABI version.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">00 00 00 00 00 00 00</td><td style="text-align: center;">Padding, should be filled with zeros.</td></tr><tr class="even"><td style="text-align: center;">0000020</td><td style="text-align: center;">03 00</td><td style="text-align: center;">Identifies object file type, 0x3 is ET_DYN.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">3e 00</td><td style="text-align: center;">Specifies instruction set architecture, 0x3e is amd64.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">01 00 00 00</td><td style="text-align: center;">Set to 1 for the original version of ELF.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">50 10 00 00 00 00 00 00</td><td style="text-align: center;">Entry point address.</td></tr><tr class="even"><td style="text-align: center;">0000040</td><td style="text-align: center;">40 00 00 00 00 00 00 00</td><td style="text-align: center;">The start of the program header table. 0x40 = 64.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">58 39 00 00 00 00 00 00</td><td style="text-align: center;">The start of the section header table.</td></tr><tr class="even"><td style="text-align: center;">0000060</td><td style="text-align: center;">00 00 00 00</td><td style="text-align: center;">Interpretation depends on the target architecture.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">40 00</td><td style="text-align: center;">Size of file header.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">38 00</td><td style="text-align: center;">Size of a program header table entry.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">0b 00</td><td style="text-align: center;">Number of entries in the program header table.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">40 00</td><td style="text-align: center;">Size of a section header table entry.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">1e 00</td><td style="text-align: center;">Number of entries in the section header table.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">1d 00</td><td style="text-align: center;">Index of the section header table entry that contains the section names.</td></tr><tr class="odd"><td style="text-align: center;">0000100</td><td style="text-align: center;"></td><td style="text-align: center;"></td></tr></tbody></table><p>File Header 帮助链接器：</p><ol type="1"><li>确认是否可以装载文件，包括系统是 32 位还是 64 位、大小端、ABI 版本等；</li><li>决定如何装载文件，包括 Program Header 和 Section Header 的位置及大小、如何寻找 section 名称、entry point address 等。</li></ol><h3 id="program-header">Program Header</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --program-headers main</span><br>Program Headers:<br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040<br>                 0x0000000000000268 0x0000000000000268  R      0x8<br>  INTERP         0x00000000000002a8 0x00000000000002a8 0x00000000000002a8<br>                 0x0000000000000033 0x0000000000000033  R      0x1<br>      [Requesting program interpreter: /root/glibc/build/install/lib/ld-linux-x86-64.so.2]<br>  ...<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// /usr/include/elf.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> Elf64_Word;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint64_t</span> Elf64_Xword;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>  Elf64_Word    p_type;                 <span class="hljs-comment">/* Segment type */</span><br>  Elf64_Word    p_flags;                <span class="hljs-comment">/* Segment flags */</span><br>  Elf64_Off     p_offset;               <span class="hljs-comment">/* Segment file offset */</span><br>  Elf64_Addr    p_vaddr;                <span class="hljs-comment">/* Segment virtual address */</span><br>  Elf64_Addr    p_paddr;                <span class="hljs-comment">/* Segment physical address */</span><br>  Elf64_Xword   p_filesz;               <span class="hljs-comment">/* Segment size in file */</span><br>  Elf64_Xword   p_memsz;                <span class="hljs-comment">/* Segment size in memory */</span><br>  Elf64_Xword   p_align;                <span class="hljs-comment">/* Segment alignment */</span><br>&#125; Elf64_Phdr;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=$((0x40 + 0x38 * 1)) --read-bytes=0x38 --format=xL main</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">位移（八进制）</th><th style="text-align: center;">内容</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0000170</td><td style="text-align: center;">00000003</td><td style="text-align: center;">PT_INTERP</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">00000004</td><td style="text-align: center;">Segment flags.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">00000000000002a8</td><td style="text-align: center;">Segment file offset.</td></tr><tr class="even"><td style="text-align: center;">0000210</td><td style="text-align: center;">00000000000002a8</td><td style="text-align: center;">Segment virtual address.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">00000000000002a8</td><td style="text-align: center;">Segment physical address.</td></tr><tr class="even"><td style="text-align: center;">0000230</td><td style="text-align: center;">0000000000000033</td><td style="text-align: center;">Segment size in file.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">0000000000000033</td><td style="text-align: center;">Segment size in memory.</td></tr><tr class="even"><td style="text-align: center;">0000250</td><td style="text-align: center;">0000000000000001</td><td style="text-align: center;">Segment alignment.</td></tr></tbody></table><p>比较让人迷惑的字段是 Segment physical address ，根据 <a href="https://stackoverflow.com/questions/16812574/elf-files-what-is-a-section-and-why-do-we-need-it">What is a section and why do we need it</a> 和<a href="https://zhuanlan.zhihu.com/p/54399161">写一个工具来了解ELF文件（二）</a> 两篇文章，Segment physical address 在现代操作系统中已经没有用处了，GCC 一般将其置为 Segment virtual address 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=0x2a8 --read-bytes=0x33 --format=xC -c main</span><br>0001250  2f  72  6f  6f  74  2f  67  6c  69  62  63  2f  62  75  69  6c<br>          /   r   o   o   t   /   g   l   i   b   c   /   b   u   i   l<br>0001270  64  2f  69  6e  73  74  61  6c  6c  2f  6c  69  62  2f  6c  64<br>          d   /   i   n   s   t   a   l   l   /   l   i   b   /   l   d<br>0001310  2d  6c  69  6e  75  78  2d  78  38  36  2d  36  34  2e  73  6f<br>          -   l   i   n   u   x   -   x   8   6   -   6   4   .   s   o<br>0001330  2e  32  00<br>          .   2  \0<br>0001333<br></code></pre></td></tr></table></figure><p>根据 Program Header 的指导，从 0x2a8 开始连续读 0x33 个字节，就是 interpreter 在文件系统中的路径。</p><p>Program Header 最重要的作用是指导链接器如何装载 ELF 文件，要注意：由于对齐或者前面的某个 Segment 在文件中的大小和在内存中的大小不一致，Segment 在文件中的起始地址未必等于在内存中的起始地址，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --program-headers main</span><br>  Type           Offset             VirtAddr           PhysAddr<br>                 FileSiz            MemSiz              Flags  Align<br>  ...<br>  LOAD           0x0000000000002dc8 0x0000000000003dc8 0x0000000000003dc8<br>                 0x0000000000000268 0x0000000000000270  RW     0x1000<br></code></pre></td></tr></table></figure><p>LOAD Segment 在文件中的起始地址是 0x2dc8 ，在内存中的起始地址是 0x3dc8 ，两者并不相等。</p><h3 id="section-header">Section Header</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main</span><br>Section Headers:<br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  ...<br>  [13] .plt.got          PROGBITS         0000000000001040  00001040<br>       0000000000000008  0000000000000008  AX       0     0     8<br>  ...<br>  [28] .strtab           STRTAB           0000000000000000  00003650<br>       00000000000001fa  0000000000000000           0     0     1<br>  ...<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> Elf64_Word;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint64_t</span> Elf64_Xword;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>  Elf64_Word    sh_name;                <span class="hljs-comment">/* Section name (string tbl index) */</span><br>  Elf64_Word    sh_type;                <span class="hljs-comment">/* Section type */</span><br>  Elf64_Xword   sh_flags;               <span class="hljs-comment">/* Section flags */</span><br>  Elf64_Addr    sh_addr;                <span class="hljs-comment">/* Section virtual addr at execution */</span><br>  Elf64_Off     sh_offset;              <span class="hljs-comment">/* Section file offset */</span><br>  Elf64_Xword   sh_size;                <span class="hljs-comment">/* Section size in bytes */</span><br>  Elf64_Word    sh_link;                <span class="hljs-comment">/* Link to another section */</span><br>  Elf64_Word    sh_info;                <span class="hljs-comment">/* Additional section information */</span><br>  Elf64_Xword   sh_addralign;           <span class="hljs-comment">/* Section alignment */</span><br>  Elf64_Xword   sh_entsize;             <span class="hljs-comment">/* Entry size if section holds table */</span><br>&#125; Elf64_Shdr;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=$((0x3958 + 0x40 * 13)) --read-bytes=0x40 --format=xL main</span><br></code></pre></td></tr></table></figure><table><thead><tr class="header"><th style="text-align: center;">位移（八进制）</th><th style="text-align: center;">内容</th><th style="text-align: center;">解释</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0036230</td><td style="text-align: center;">00000094</td><td style="text-align: center;">Section name (string table index).</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">00000001</td><td style="text-align: center;">Section type, SHT_PROGBITS.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">0000000000000006</td><td style="text-align: center;">Section flags, SHF_ALLOC | SHF_EXECINSTR.</td></tr><tr class="even"><td style="text-align: center;">0036250</td><td style="text-align: center;">0000000000001040</td><td style="text-align: center;">Section virtual address.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">0000000000001040</td><td style="text-align: center;">Section file offset.</td></tr><tr class="even"><td style="text-align: center;">0036270</td><td style="text-align: center;">0000000000000008</td><td style="text-align: center;">Section size in bytes.</td></tr><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">00000000</td><td style="text-align: center;">Link to another section.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">00000000</td><td style="text-align: center;">Additional section information.</td></tr><tr class="odd"><td style="text-align: center;">0036310</td><td style="text-align: center;">0000000000000008</td><td style="text-align: center;">Section alignment.</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;">0000000000000008</td><td style="text-align: center;">Entry size if section holds table.</td></tr></tbody></table><p>根据 <a href="https://man7.org/linux/man-pages/man5/elf.5.html">man elf</a> 的描述，sh_link / sh_info 的含义都取决于 section 。</p><h2 id="plt-.got.plt-.plt.got-.got">.plt &amp; .got.plt / .plt.got &amp; .got</h2><p>Debug 技巧：先用 <code>info proc mappings</code> 获取 start address ，再用 <code>watch *(unsigned long long*)(&lt;start_addr&gt; + &lt;addr&gt;)</code> 就能看到改变特定地址的栈了。</p><ol type="1"><li>.plt.got &amp; .got 同 .plt &amp; .got.plt 一样，都是一组用于重定位的 sections ；</li><li>不同之处是：<ol type="1"><li>.plt.got &amp; .got 没有 lazy binding ，由链接器直接触发重定位；</li><li>.plt &amp; .got.plt 有 lazy binding ，在第一次调用函数时触发重定位。</li></ol></li></ol><h3 id="plt-.got.plt">.plt &amp; .got.plt</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># objdump -d -j .plt main</span><br>0000000000001020 &lt;.plt&gt;:<br>    1020:       ff 35 e2 2f 00 00       pushq  0x2fe2(%rip)        <span class="hljs-comment"># 4008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br>    1026:       ff 25 e4 2f 00 00       jmpq   *0x2fe4(%rip)        <span class="hljs-comment"># 4010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;</span><br>    102c:       0f 1f 40 00             nopl   0x0(%rax)<br><br>0000000000001030 &lt;_Z3foov@plt&gt;:<br>    1030:       ff 25 e2 2f 00 00       jmpq   *0x2fe2(%rip)        <span class="hljs-comment"># 4018 &lt;_Z3foov&gt;</span><br>    1036:       68 00 00 00 00          pushq  <span class="hljs-variable">$0x0</span><br>    103b:       e9 e0 ff ff ff          jmpq   1020 &lt;.plt&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|.got.plt&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [23] .got.plt          PROGBITS         0000000000004000  00003000<br>       0000000000000020  0000000000000008  WA       0     0     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=$((0x1036 + 0x2fe2 - 0x4000 + 0x3000)) --read-bytes=8 --format=xL main</span><br>0030030 0000000000001036<br>0030040<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --relocs main | grep &quot;$(printf &#x27;%x&#x27; $((0x1036 + 0x2fe2)))&quot; -B2</span><br>Relocation section <span class="hljs-string">&#x27;.rela.plt&#x27;</span> at offset 0x590 contains 1 entry:<br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000004018  000400000007 R_X86_64_JUMP_SLO 0000000000000000 _Z3foov + 0<br></code></pre></td></tr></table></figure><p>.got.plt 表项（虚存地址是 0x1036 + 0x2fe2）会发生两次改变：</p><ol type="1"><li>从 0x1036 变成 start address + 0x1036 ：<ol type="1"><li>由运行时链接器在 .rela.plt (R_X86_64_JUMP_SLOT) 表项的指导下完成，调用栈是 <code>dl_main -&gt; _dl_relocate_object -&gt; elf_dynamic_do_Rela</code> ；</li><li>是同文件重定位，仅仅加上了 start address ，不需要查找符号，执行速度快；</li></ol></li><li>从 start address + 0x1036 变成 <code>foo</code> 函数的首地址 ：<ol type="1"><li>由用户代码在函数 <code>foo</code> 第一次被调用时触发，调用栈是 <code>main -&gt; _dl_runtime_resolve_xsavec -&gt; _dl_fixup</code> ；</li><li>是跨文件重定位，需要查找符号，执行速度慢。</li></ol></li></ol><h3 id="plt.got-.got">.plt.got &amp; .got</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># objdump -d -j .plt.got main</span><br>0000000000001040 &lt;__cxa_finalize@plt&gt;:<br>    1040:       ff 25 b2 2f 00 00       jmpq   *0x2fb2(%rip)        <span class="hljs-comment"># 3ff8 &lt;__cxa_finalize@GLIBC_2.2.5&gt;</span><br>    1046:       66 90                   xchg   %ax,%ax<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr| .got &quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [22] .got              PROGBITS         0000000000003fd8  00002fd8<br>       0000000000000028  0000000000000008  WA       0     0     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=$((0x1046 + 0x2fb2 - 0x3fd8 + 0x2fd8)) --read-bytes=8 --format=xL main</span><br>0027770 0000000000000000<br>0030000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --relocs main | grep -E &quot;Offset|$(printf &#x27;%x&#x27; $((0x1046 + 0x2fb2)))&quot;</span><br>  Offset          Info           Type           Sym. Value    Sym. Name + Addend<br>000000003ff8  000600000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0<br></code></pre></td></tr></table></figure><p>.got 表项（虚存地址是 0x1046 + 0x2fb2）只会发生一次改变，从 0x0 变成 <code>__cxa_finalize</code> 函数的首地址：</p><ol type="1"><li>由运行时链接器在 .rela.dyn (R_X86_64_GLOB_DAT) 表项的指导下完成，调用栈是 <code>dl_main -&gt; _dl_relocate_object -&gt; elf_dynamic_do_Rela -&gt; elf_machine_rela</code> ；</li><li>是跨文件重定位，需要查找符号，执行速度慢。</li></ol><h2 id="rela.dyn-.rela.plt">.rela.dyn &amp; .rela.plt</h2><p>以 foo.cpp 为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// foo.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-type">int</span> var = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;bar&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="rela.dyn-.rela.plt-1">.rela.dyn / .rela.plt</h3><p>根据 <a href="https://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-S390/LSB-Core-S390/sections.html">Linux Foundation Referenced Specifications: Additional Special Sections</a> 的说法：</p><ol type="1"><li>.rela.plt section 负责配合 .plt section 完成<a href="https://clcanny.github.io/2020/11/21/dynamic-linking-relocation-across-files/">跨文件重定位</a> ；</li><li>.rela.dyn 负责其它类型的重定位。</li></ol><h3 id="rela.dyn-.rela.plt-与-.symtab-的关系">.rela.dyn &amp; .rela.plt 与 .symtab 的关系</h3><p>.symtab 中的 undefined symbols 都能在 relocation sections 中找到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --symbols --wide libfoo.so | grep &quot;.symtab&quot; -A 100 | grep &quot;UND&quot; | awk &#x27;&#123;print $8&#125;&#x27; | sort</span><br>__cxa_atexit@@GLIBC_2.2.5<br>__cxa_finalize@@GLIBC_2.2.5<br>__gmon_start__<br>_ITM_deregisterTMCloneTable<br>_ITM_registerTMCloneTable<br>_Jv_RegisterClasses<br>_ZNSolsEPFRSoS_E@@GLIBCXX_3.4<br>_ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4<br>_ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4<br>_ZSt4cout@@GLIBCXX_3.4<br>_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@@GLIBCXX_3.4<br>_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@@GLIBCXX_3.4<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --relocs --wide libfoo.so | grep -v &quot;\&lt;Offset\&gt;&quot; | awk &#x27;&#123;print $5&#125;&#x27; | sort | uniq</span><br>__cxa_atexit@GLIBC_2.2.5<br>__cxa_finalize@GLIBC_2.2.5<br>__gmon_start__<br>_ITM_deregisterTMCloneTable<br>_ITM_registerTMCloneTable<br>_Jv_RegisterClasses<br>offset<br>_ZNSolsEPFRSoS_E@GLIBCXX_3.4<br>_ZNSt8ios_base4InitC1Ev@GLIBCXX_3.4<br>_ZNSt8ios_base4InitD1Ev@GLIBCXX_3.4<br>_ZSt4cout@GLIBCXX_3.4<br>_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GLIBCXX_3.4<br>_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@GLIBCXX_3.4<br></code></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><p>ELF (except .plt and .got.plt and etc.):</p><ul><li><a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">Wikipedia: Executable and Linkable Format</a></li><li><a href="http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html">Keith Makan: Introduction to the ELF Format (Part VII): Dynamic Linking / Loading and the .dynamic section</a></li><li><a href="https://zhuanlan.zhihu.com/p/54399161">知乎：写一个工具来了解ELF文件（二）</a></li><li><a href="https://stackoverflow.com/questions/16812574/elf-files-what-is-a-section-and-why-do-we-need-it">Stack Overflow: What is a section and why do we need it</a></li><li><a href="https://stackoverflow.com/questions/23379880/difference-between-program-header-and-section-header-in-elf">Stack Overflow: Difference between Program header and Section Header in ELF</a></li><li><a href="https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2">Oracle Solaris Blog: GNU Hash ELF Sections</a></li><li><a href="https://docs.oracle.com/cd/E23824_01/html/819-0690/chapter6-42444.html">ORACLE: Dynamic Section</a></li></ul><p>.plt and .got.plt and etc.:</p><ul><li><a href="https://reverseengineering.stackexchange.com/questions/1992/what-is-plt-got">Stack Exchange: What is PLT/GOT?</a></li><li><a href="https://stackoverflow.com/questions/43048932/why-does-the-plt-exist-in-addition-to-the-got-instead-of-just-using-the-got">Stack Overflow: Why does the PLT exist in addition to the GOT, instead of just using the GOT?</a></li><li><a href="https://stackoverflow.com/questions/58076539/plt-plt-got-what-is-different">Stack Overflow: .plt .plt.got what is different?</a></li><li><a href="https://stackoverflow.com/questions/11676472/what-is-the-difference-between-got-and-got-plt-section">Stack Overflow: What is the difference between .got and .got.plt section?</a></li><li><a href="https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html">Technovelty: PLT and GOT - the key to code sharing and dynamic libraries</a></li><li><a href="https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html">System Overlord: GOT and PLT for pwning.</a></li><li><a href="https://lief.quarkslab.com/doc/latest/tutorials/05_elf_infect_plt_got.html">LIEF: 05 - Infecting the plt/got</a></li></ul><p>.rela.dyn and .rela.plt:</p><ul><li><a href="https://refspecs.linuxfoundation.org/LSB_4.1.0/LSB-Core-S390/LSB-Core-S390/sections.html">Linux Foundation Referenced Specifications: Additional Special Sections</a></li><li><a href="http://blog.k3170makan.com/2018/10/introduction-to-elf-format-part-vi_18.html">Keith Makan: Introduction to The ELF Format (Part VI): The Symbol Table and Relocations (Part 2)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Relocation Across Files</title>
    <link href="/2020/11/21/computer-science/dynamic-linking/relocation-across-files/"/>
    <url>/2020/11/21/computer-science/dynamic-linking/relocation-across-files/</url>
    
    <content type="html"><![CDATA[<h1 id="开始重定位.plt-.got.plt">开始重定位：.plt .got.plt</h1><p>.plt 和 .got.plt 配合完成 lazy binding ，图片摘抄自 <a href="https://lief.quarkslab.com/doc/latest/tutorials/05_elf_infect_plt_got.html">LIEF: 05 - Infecting the plt/got</a> ：</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-relocation-across-files/plt-got-mechanism-first-time-call.jpg" /></p><p><em>With lazy binding, the first time that the function is called the</em> <code>got</code> <em>entry redirects to the plt instruction.</em></p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-relocation-across-files/plt-got-mechanism-second-time-call.jpg" /></p><p><em>The Second time,</em> <code>got</code> <em>entry holds the address in the shared library.</em></p><p>以 main 调用 foo 为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># objdump -d -j .text main<br>0000000000001135 &lt;main&gt;:<br>    1135:   55                      push   %rbp<br>    1136:   48 89 e5                mov    %rsp,%rbp<br>    1139:   e8 f2 fe ff ff          callq  1030 &lt;_Z3foov@plt&gt;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly"># objdump -d -j .plt main<br>0000000000001020 &lt;.plt&gt;:<br>    1020:   ff 35 e2 2f 00 00       pushq  0x2fe2(%rip) # 4008 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;<br>    1026:   ff 25 e4 2f 00 00       jmpq   *0x2fe4(%rip) # 4010 &lt;_GLOBAL_OFFSET_TABLE_+0x10&gt;<br>    102c:   0f 1f 40 00             nopl   0x0(%rax)<br><br>0000000000001030 &lt;_Z3foov@plt&gt;:<br>    1030:   ff 25 e2 2f 00 00       jmpq   *0x2fe2(%rip) # 4018 &lt;_Z3foov&gt;<br>    1036:   68 00 00 00 00          pushq  $0x0<br>    103b:   e9 e0 ff ff ff          jmpq   1020 &lt;.plt&gt;<br></code></pre></td></tr></table></figure><p>rip + 0x2fe2 是重定位实现 lazy binding 留下的一个占位符，这个占位符的初始值指向 plt 的第二条指令（1036），第一次调用发生后，它会被链接器修改成 foo 函数的地址，从而完成重定位。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|.got.plt&quot; -A1</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>--<br>  [23] .got.plt          PROGBITS         0000000000004000  00003000<br>       0000000000000020  0000000000000008  WA       0     0     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=$((0x1036 + 0x2fe2 - 0x4000 + 0x3000)) --read-bytes=8 --format=xL main</span><br>0030030 0000000000001036<br>0030040<br></code></pre></td></tr></table></figure><p>0x1020 是所有 plt 程序共用的部分，rip + 0x2fe2 指向 link_map ，rip + 0x2fe4 指向 <code>_dl_runtime_resolve_xsave</code> ，这两个地址都由链接器负责填写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># od --skip-bytes=$((0x1026 + 0x2fe2 - 0x4000 + 0x3000)) --read-bytes=8 --format=xL main</span><br>0030010 0000000000000000<br>0030020<br><span class="hljs-comment"># od --skip-bytes=$((0x102c + 0x2fe4 - 0x4000 + 0x3000)) --read-bytes=8 --format=xL main</span><br>0030020 0000000000000000<br>0030030<br></code></pre></td></tr></table></figure><p>剩下两个未解之谜：</p><ol type="1"><li>link_map 是怎么构造出来的？</li><li><code>_dl_runtime_resolve_xsave</code> 做了些什么？</li></ol><h1 id="dl_runtime_resolve_xsave-before-_dl_fixup">_dl_runtime_resolve_xsave: before _dl_fixup</h1><p><code>_dl_runtime_resolve_xsave</code> 定义于 /root/glibc/glibc-2.28/sysdeps/x86_64/dl-trampoline.h ，不过文件内大量使用 <code>#if</code> 语句，并不适合直接阅读。</p><p>_dl_runtime_resolve_xsave 在调用 _dl_fixup 之前的主要工作是：保存寄存器。</p><h1 id="dl_fixup">_dl_fixup</h1><p><code>_dl_runtime_resolve_xsave</code> 的核心是位于 elf/dl-runtime.c 的 <code>_dl_fixup</code> ，<code>_dl_fixup</code> 的执行过程如下：</p><ol type="1"><li>用 <code>link_map</code> 访问 .dynamic ，分别取出 .rela.plt / .dynsym / .dynstr 的地址；</li><li>.rela.plt + 参数 <code>reloc_arg</code> ，求出当前函数的重定位表项 Elf64_Rela 的指针，记作 reloc ；</li><li>以 <code>ELFW(R_SYM) (reloc-&gt;r_info)</code> 作为 .dynsym 的下标，求出当前函数的符号表项 <code>Elf64_Sym</code> 的指针，记作 <code>sym</code> ；</li><li><code>.dynstr + sym-&gt;st_name</code> 得出符号名字 ；</li><li>在动态链接库中查找这个函数的地址，并且把地址赋值给 <code>*(reloc-&gt;r_offset)</code> ，即 .got.plt 表项 。</li></ol><h2 id="访问-.dynamic-表项">访问 .dynamic 表项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>  Elf64_Sxword  d_tag;                  <span class="hljs-comment">/* Dynamic entry type */</span><br>  <span class="hljs-keyword">union</span><br>    &#123;<br>      Elf64_Xword d_val;                <span class="hljs-comment">/* Integer value */</span><br>      Elf64_Addr d_ptr;                 <span class="hljs-comment">/* Address value */</span><br>    &#125; d_un;<br>&#125; Elf64_Dyn;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span><br>  &#123;<br>    <span class="hljs-comment">/* These first few members are part of the protocol with the debugger.</span><br><span class="hljs-comment">       This is the same format used in SVR4.  */</span><br><br>    <span class="hljs-built_in">ElfW</span>(Addr) l_addr;          <span class="hljs-comment">/* Difference between the address in the ELF</span><br><span class="hljs-comment">                                   file and the addresses in memory.  */</span><br>    <span class="hljs-type">char</span> *l_name;               <span class="hljs-comment">/* Absolute file name object was found in.  */</span><br>    <span class="hljs-built_in">ElfW</span>(Dyn) *l_ld;            <span class="hljs-comment">/* Dynamic section of the shared object.  */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span> *l_next, *l_prev; <span class="hljs-comment">/* Chain of loaded objects.  */</span><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Indexed pointers to dynamic section. */</span><br>    <span class="hljs-built_in">ElfW</span>(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM<br>                      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];<br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// D_PTR 的两个定义用于：完成重定位之后和完成重定位之前，区别在于有没有加上 difference 。</span><br><span class="hljs-comment">/* All references to the value of l_info[DT_PLTGOT],</span><br><span class="hljs-comment">  l_info[DT_STRTAB], l_info[DT_SYMTAB], l_info[DT_RELA],</span><br><span class="hljs-comment">  l_info[DT_REL], l_info[DT_JMPREL], and l_info[VERSYMIDX (DT_VERSYM)]</span><br><span class="hljs-comment">  have to be accessed via the D_PTR macro.  The macro is needed since for</span><br><span class="hljs-comment">  most architectures the entry is already relocated - but for some not</span><br><span class="hljs-comment">  and we need to relocate at access time.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> DL_RO_DYN_SECTION</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> D_PTR(map, i) (map)-&gt;i-&gt;d_un.d_ptr</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | head -n 8 | tail -n 6</span><br>  Tag        Type                         Name/Value<br> 0x0000000000000001 (NEEDED)             Shared library: [libfoo.so]<br> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]<br> 0x000000000000001d (RUNPATH)            Library runpath: [/root/test]<br> 0x000000000000000c (INIT)               0x1000<br> 0x000000000000000d (FINI)               0x11b4<br></code></pre></td></tr></table></figure><h2 id="对比-.dynamic-与-section-headers">对比 .dynamic 与 section headers</h2><p>初次接触 ELF 文件会被 .dynamic 和 section headers 的区别坑到，我们不禁想问：既然有 section headers 指明每个 sections 的起始地址，为什么还需要 .dynamic ？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|.symtab&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [27] .symtab           SYMTAB           0000000000000000  00003050<br>       0000000000000600  0000000000000018          28    45     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | grep -E &quot;Tag|SYMTAB&quot;</span><br>  Tag        Type                         Name/Value<br> 0x0000000000000006 (SYMTAB)             0x348<br></code></pre></td></tr></table></figure><p>Section header 说 .symtab 的起始地址是 0x3050 ，.dynamic 表说 .symtab 的起始地址是 0x348 ，两者为什么会不一致？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|348&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 5] .dynsym           DYNSYM           0000000000000348  00000348<br>       00000000000000a8  0000000000000018   A       6     1     8<br></code></pre></td></tr></table></figure><p>事实上，0x348 是 .dynsym 的起始地址，即 .dynamic 表和 section headers 都使用了 symtab 这个名字，但两者完全不是一个意思。</p><p>同样的情况也发生在 strtab 上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|.strtab&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [28] .strtab           STRTAB           0000000000000000  00003650<br>       00000000000001fa  0000000000000000           0     0     1<br>  [29] .shstrtab         STRTAB           0000000000000000  0000384a<br>       0000000000000107  0000000000000000           0     0     1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | grep -E &quot;Tag|STRTAB&quot;</span><br>  Tag        Type                         Name/Value<br> 0x0000000000000005 (STRTAB)             0x3f0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|3f0&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 6] .dynstr           STRTAB           00000000000003f0  000003f0<br>       000000000000009a  0000000000000000   A       0     0     1<br></code></pre></td></tr></table></figure><p>.dynamic 表和 section headers 都使用了 strtab 这个名字，但两者完全不是一个意思。</p><h2 id="访问-.rela.plt-表项">访问 .rela.plt 表项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// reloc_offset = reloc_arg ，是 _dl_fixup 的第二个参数。</span><br><span class="hljs-type">const</span> PLTREL *<span class="hljs-type">const</span> reloc<br>  = (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *) (<span class="hljs-built_in">D_PTR</span> (l, l_info[DT_JMPREL]) + reloc_offset);<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Relocation table entry with addend (in section of type SHT_RELA).  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>  Elf64_Addr    r_offset;               <span class="hljs-comment">/* Address */</span><br>  Elf64_Xword   r_info;                 <span class="hljs-comment">/* Relocation type and symbol index */</span><br>  Elf64_Sxword  r_addend;               <span class="hljs-comment">/* Addend */</span><br>&#125; Elf64_Rela;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | grep -E &quot;Tag|JMPREL&quot;</span><br>  Tag        Type                         Name/Value<br> 0x0000000000000017 (JMPREL)             0x578<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|578&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [10] .rela.plt         RELA             0000000000000578  00000578<br>       0000000000000018  0000000000000018  AI       5    23     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># export reloc_table_start_addr=0x578</span><br><span class="hljs-comment"># export reloc_entry_size=0x18</span><br><span class="hljs-comment"># export reloc_offset=0</span><br><span class="hljs-comment"># od --skip-bytes=$(($reloc_table_start_addr + $reloc_entry_size * $reloc_offset)) --read-bytes=$reloc_entry_size --format=xL main</span><br>0002570 0000000000004018 0000000400000007<br>0002610 0000000000000000<br></code></pre></td></tr></table></figure><p>对照 <code>Elf64_Rela</code> 的定义，<code>r_info</code> 的值是 0x4 &lt;&lt; 32 + 0x7 。</p><h2 id="访问-.dynsym-表项">访问 .dynsym 表项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* We use this macro to refer to ELF macros independent of the native</span><br><span class="hljs-comment">   wordsize.  `ELFW(R_TYPE)&#x27; is used in place of `ELF32_R_TYPE&#x27; or</span><br><span class="hljs-comment">   `ELF64_R_TYPE&#x27;.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELFW(type)      _ElfW (ELF, __ELF_NATIVE_CLASS, type)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ELF64_R_SYM(i)          ((i) &gt;&gt; 32)</span><br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Sym)</span> *<span class="hljs-type">const</span> symtab</span><br><span class="hljs-function">  </span>= (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *) <span class="hljs-built_in">D_PTR</span> (l, l_info[DT_SYMTAB]);<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Sym)</span> *sym </span>= &amp;symtab[<span class="hljs-built_in">ELFW</span>(R_SYM) (reloc-&gt;r_info)];<br></code></pre></td></tr></table></figure><p>所以 <code>ELFW(R_SYM) (reloc-&gt;r_info) == 4</code> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint32_t</span> Elf64_Word;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint64_t</span> Elf64_Xword;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">uint16_t</span> Elf64_Section;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>  Elf64_Word    st_name;                <span class="hljs-comment">/* Symbol name (string tbl index) */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info;                <span class="hljs-comment">/* Symbol type and binding */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other;               <span class="hljs-comment">/* Symbol visibility */</span><br>  Elf64_Section st_shndx;               <span class="hljs-comment">/* Section index */</span><br>  Elf64_Addr    st_value;               <span class="hljs-comment">/* Symbol value */</span><br>  Elf64_Xword   st_size;                <span class="hljs-comment">/* Symbol size */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | grep -E &quot;Tag|SYMTAB&quot;</span><br>  Tag        Type                         Name/Value<br> 0x0000000000000006 (SYMTAB)             0x348<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|348&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 5] .dynsym           DYNSYM           0000000000000348  00000348<br>       00000000000000a8  0000000000000018   A       6     1     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># export symbol_table_start_addr=0x348</span><br><span class="hljs-comment"># export symbol_table_entry_size=0x18</span><br><span class="hljs-comment"># export symbol_table_entry_index=0x4</span><br><span class="hljs-comment"># od --skip-bytes=$(($symbol_table_start_addr + $symbol_table_entry_size * $symbol_table_entry_index)) --read-bytes=$symbol_table_entry_size --format=xL main</span><br>0001650 0000001200000050 0000000000000000<br>0001670 0000000000000000<br></code></pre></td></tr></table></figure><p>对照 <code>Elf64_Sym</code> 的定义，<code>st_name</code> 的值是 0x50 。</p><h2 id="访问-.dynstr-表项">访问 .dynstr 表项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *strtab = (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *) <span class="hljs-built_in">D_PTR</span> (l, l_info[DT_STRTAB]);<br>result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,<br>                              version, ELF_RTYPE_CLASS_PLT, flags, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | grep -E &quot;Tag|STRTAB&quot;</span><br>  Tag        Type                         Name/Value<br> 0x0000000000000005 (STRTAB)             0x3f0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|3f0&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 6] .dynstr           STRTAB           00000000000003f0  000003f0<br>       000000000000009a  0000000000000000   A       0     0     1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># export string_table_start_addr=0x3f0</span><br><span class="hljs-comment"># export st_name=0x50</span><br><span class="hljs-comment"># od --skip-bytes=$(($string_table_start_addr + $st_name)) --read-bytes=0x8 --format=xC -c main</span><br>0002100  5f  5a  33  66  6f  6f  76  00<br>          _   Z   3   f   o   o   v  \0<br></code></pre></td></tr></table></figure><p>函数 <code>foo</code> 在 mangle 后的名字是 <code>_Z3fooV</code> 。</p><h2 id="查找符号">查找符号</h2><p><code>_dl_lookup_symbol_x</code> 遍历 <code>l-&gt;l_scope</code> ，对于每一个 <code>scope</code> 调用 <code>do_lookup_x</code> 函数寻找符号：</p><ol type="1"><li><a href="https://clcanny.github.io/2020/11/18/dynamic-linking-symbol-search-order/">Dynamic Linking: Symbol Search Order</a> 探讨了在多个文件间查找符号的顺序；</li><li><a href="https://clcanny.github.io/2020/11/20/dynamic-linking-search-symbols-in-one-binary/">Dynamic Linking: Search Symbols In One Binary</a> 探讨了在多个文件间查找符号的顺序。</li></ol><h3 id="l_scope">l_scope</h3><p>摘抄自 <a href="http://log.or.cz/?p=129">ld.so Scopes</a> ：</p><blockquote><p>The scope describes which libraries should be searched for symbol lookups occuring within the scope owner. (By the way, given that lookup scope may differ by caller, implementing <code>dlsym()</code> is not <em>that</em> trivial.) It is further divided into <strong>scope elements (struct r_scope_elem)</strong> – a single scope element basically describes a single search list of libraries, and the scope (<strong>link_map.l_scope</strong> is the scope used for symbol lookup) is list of such scope elements.</p></blockquote><blockquote><p>To reiterate, a symbol lookup scope is a list of lists! Then, when looking up a symbol, the linker walks the lists in the order they are listed in the scope. But what really are the scope elements? There are two usual kinds:</p><ul><li>The "global scope" – all libraries (ahem, link_maps) that have been requested to be loaded by the main program (what ldd on the binary file of the main program would print out, plus dlopen()ed stuff).</li><li>The "local scope" – DT_NEEDED library dependencies of the current link_map (what ldd on the binary file of the library would print out, plus dlopen()ed stuff).</li></ul></blockquote><blockquote><p>The global scope is shared between all link_maps (in the current namespace), while the local scope is owned by a particular library.</p></blockquote><h2 id="回填-.got.plt-表项">回填 .got.plt 表项</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> PLTREL *<span class="hljs-type">const</span> reloc<br>  = (<span class="hljs-type">const</span> <span class="hljs-type">void</span> *) (<span class="hljs-built_in">D_PTR</span> (l, l_info[DT_JMPREL]) + reloc_offset);<br><span class="hljs-type">void</span> *<span class="hljs-type">const</span> rel_addr = (<span class="hljs-type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);<br><span class="hljs-comment">/* Finally, fix up the plt itself.  */</span><br><span class="hljs-keyword">if</span> (__glibc_unlikely (<span class="hljs-built_in">GLRO</span>(dl_bind_not)))<br>  <span class="hljs-keyword">return</span> value;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">elf_machine_fixup_plt</span> (l, result, refsym, sym, reloc, rel_addr, value);<br><br><span class="hljs-comment">// sysdeps/x86_64/dl-machine.h</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span></span><br><span class="hljs-function"><span class="hljs-title">elf_machine_fixup_plt</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> link_map *map, <span class="hljs-type">lookup_t</span> t,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> ElfW(Sym) *refsym, <span class="hljs-type">const</span> ElfW(Sym) *sym,</span></span><br><span class="hljs-params"><span class="hljs-function">                       <span class="hljs-type">const</span> ElfW(Rela) *reloc,</span></span><br><span class="hljs-params"><span class="hljs-function">                       ElfW(Addr) *reloc_addr, ElfW(Addr) value)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">return</span> *reloc_addr = value;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Relocation table entry with addend (in section of type SHT_RELA).  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>  Elf64_Addr    r_offset;               <span class="hljs-comment">/* Address */</span><br>  Elf64_Xword   r_info;                 <span class="hljs-comment">/* Relocation type and symbol index */</span><br>  Elf64_Sxword  r_addend;               <span class="hljs-comment">/* Addend */</span><br>&#125; Elf64_Rela;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic main | grep -E &quot;Tag|JMPREL&quot;</span><br>  Tag        Type                         Name/Value<br> 0x0000000000000017 (JMPREL)             0x578<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|578&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [10] .rela.plt         RELA             0000000000000578  00000578<br>       0000000000000018  0000000000000018  AI       5    23     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># export reloc_table_start_addr=0x578</span><br><span class="hljs-comment"># export reloc_entry_size=0x18</span><br><span class="hljs-comment"># export reloc_offset=0</span><br><span class="hljs-comment"># od --skip-bytes=$(($reloc_table_start_addr + $reloc_entry_size * $reloc_offset)) --read-bytes=$reloc_entry_size --format=xL main</span><br>0002570 0000000000004018 0000000400000007<br>0002610 0000000000000000<br></code></pre></td></tr></table></figure><p>对比 <code>Elf64_Rela</code> 的定义，<code>r_offset</code> 的值是 0x4018 ，而 0x4018 恰好是 .got.plt 表为函数 foo 预留的占位符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># objdump -d -j .plt main | tail -n 3</span><br>    1030:   ff 25 e2 2f 00 00       jmpq   *0x2fe2(%rip)        <span class="hljs-comment"># 4018 &lt;_Z3foov&gt;</span><br>    1036:   68 00 00 00 00          pushq  <span class="hljs-variable">$0x0</span><br>    103b:   e9 e0 ff ff ff          jmpq   1020 &lt;.plt&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers main | grep -E &quot;Nr|.got.plt&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [23] .got.plt          PROGBITS         0000000000004000  00003000<br>       0000000000000020  0000000000000008  WA       0     0     8<br></code></pre></td></tr></table></figure><h1 id="dl_runtime_resolve_xsave-after-_dl_fixup">_dl_runtime_resolve_xsave: after _dl_fixup</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp *%r11               # Jump to function address.<br></code></pre></td></tr></table></figure><p><code>_dl_runtime_resolve_xsave</code> 在调用 <code>_dl_fixup</code> 之后的主要工作是：调用函数。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Search Symbols In One Binary</title>
    <link href="/2020/11/20/computer-science/dynamic-linking/search-symbols-in-one-binary/"/>
    <url>/2020/11/20/computer-science/dynamic-linking/search-symbols-in-one-binary/</url>
    
    <content type="html"><![CDATA[<h1 id="导读">导读</h1><p><a href="https://clcanny.github.io/2020/11/18/dynamic-linking-symbol-search-order/">Dynamic Linking: Symbol Search Order</a> 介绍了在多个文件间查找符号的顺序，本篇文章会聚焦于 <code>do_lookup_x</code> 函数，探讨在单文件内查找符号的步骤：</p><ol type="1"><li>布隆过滤器和哈希表是两个重要的数据结构；</li><li>它们是由编译器而不是运行时链接器准备的。</li></ol><p>Hash sections 有两种格式，GNU hash section 和 SYSV hash section ：</p><ol type="1"><li>GNU hash section 比 SYSV hash section 具备更好的性能；</li><li>通过 <code>-Wl,--hash-style=sysv</code> 选项指定编译 SYSV hash section ；</li><li>通过 <code>-Wl,--hash-style=gnu</code> 选项指定编译 GNU hash section 。</li></ol><p>本文讨论 GNU hash section 。</p><h1 id="code">Code</h1><h2 id="加载-.gnu.hash-section">加载 .gnu.hash section</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span> &#123;</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// Symbol hash table.</span><br>  <span class="hljs-comment">// The number of hash buckets.</span><br>  Elf_Symndx l_nbuckets;<br>  <span class="hljs-comment">// bitmask_words is the number of __ELF_NATIVE_CLASS sized words</span><br>  <span class="hljs-comment">// in the Bloom filter portion of the hash table section. This value</span><br>  <span class="hljs-comment">// must be non-zero, and must be a power of 2.</span><br>  <span class="hljs-comment">// l_gnu_bitmask_idxbits = bitmask_nwords - 1</span><br>  Elf32_Word l_gnu_bitmask_idxbits;<br>  <span class="hljs-comment">// A shift count used by the Bloom filter.</span><br>  <span class="hljs-comment">// HashValue_2 = HashValue_1 &gt;&gt; l_gnu_shift.</span><br>  Elf32_Word l_gnu_shift;<br>  <span class="hljs-type">const</span> <span class="hljs-title function_">ElfW</span><span class="hljs-params">(Addr)</span> * l_gnu_bitmask;<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">const</span> Elf32_Word* l_gnu_buckets;<br>    <span class="hljs-type">const</span> Elf_Symndx* l_chain;<br>  &#125;;<br>  <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>    <span class="hljs-type">const</span> Elf32_Word* l_gnu_chain_zero;<br>    <span class="hljs-type">const</span> Elf_Symndx* l_buckets;<br>  &#125;;<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> _dl_setup_hash(<span class="hljs-keyword">struct</span> link_map* <span class="hljs-built_in">map</span>) &#123;<br>  <span class="hljs-keyword">if</span> (__glibc_likely(<span class="hljs-built_in">map</span>-&gt;l_info[ADDRIDX(DT_GNU_HASH)] != <span class="hljs-literal">NULL</span>)) &#123;<br>    Elf32_Word* hash32 = (<span class="hljs-type">void</span>*)D_PTR(<span class="hljs-built_in">map</span>, l_info[ADDRIDX(DT_GNU_HASH)]);<br>    <span class="hljs-built_in">map</span>-&gt;l_nbuckets = *hash32++;<br>    Elf32_Word symbias = *hash32++;<br>    Elf32_Word bitmask_nwords = *hash32++;<br>    <span class="hljs-comment">// Must be a power of two.</span><br>    assert((bitmask_nwords &amp; (bitmask_nwords - <span class="hljs-number">1</span>)) == <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">map</span>-&gt;l_gnu_bitmask_idxbits = bitmask_nwords - <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">map</span>-&gt;l_gnu_shift = *hash32++;<br><br>    <span class="hljs-built_in">map</span>-&gt;l_gnu_bitmask = (ElfW(Addr)*)hash32;<br>    hash32 += __ELF_NATIVE_CLASS / <span class="hljs-number">32</span> * bitmask_nwords;<br><br>    <span class="hljs-built_in">map</span>-&gt;l_gnu_buckets = hash32;<br>    hash32 += <span class="hljs-built_in">map</span>-&gt;l_nbuckets;<br>    <span class="hljs-built_in">map</span>-&gt;l_gnu_chain_zero = hash32 - symbias;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从 <a href="https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2">GNU Hash ELF Sections</a> 摘抄了一段关于 .gnu.hash section 的描述：</p><blockquote><ul><li><p><strong>l_nbuckets</strong> The number of hash buckets</p></li><li><p><strong>symbias</strong> The dynamic symbol table has <em>dynsymcount</em> symbols. <em>symndx</em> is the index of the first symbol in the dynamic symbol table that is to be accessible via the hash table. This implies that there are (<em>dynsymcount</em> - <em>symndx</em>) symbols accessible via the hash table.</p></li><li><p><strong>bitmask_nwords</strong></p><p>The number of __ELF_NATIVE_CLASS sized words in the Bloom filter portion of the hash table section. This value must be non-zero, and must be a power of 2 as explained below.</p><p>Note that a value of 0 could be interpreted to mean that no Bloom filter is present in the hash section. However, the GNU linkers do not do this — the GNU hash section always includes at least 1 mask word.</p></li><li><p><strong>l_gnu_shift</strong> A shift count used by the Bloom filter. HashValue_2 = HashValue_1 &gt;&gt; l_gnu_shift.</p></li></ul></blockquote><h2 id="哈希算法">哈希算法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">uint_fast32_t</span></span><br><span class="hljs-function"><span class="hljs-title">dl_new_hash</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint_fast32_t</span> h = <span class="hljs-number">5381</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *s; c != <span class="hljs-string">&#x27;\0&#x27;</span>; c = *++s)<br>    h = h * <span class="hljs-number">33</span> + c;<br>  <span class="hljs-keyword">return</span> h &amp; <span class="hljs-number">0xffffffff</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查找符号">查找符号</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// elf/dl-lookup.c</span><br><span class="hljs-comment">// do_lookup_x</span><br><span class="hljs-comment">// const uint_fast32_t new_hash = dl_new_hash (undef_name);</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span> *map = list[i]-&gt;l_real;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-title">ElfW</span><span class="hljs-params">(Addr)</span> *bitmask </span>= map-&gt;l_gnu_bitmask;<br><span class="hljs-keyword">if</span> (__glibc_likely (bitmask != <span class="hljs-literal">NULL</span>))<br>&#123;<br>  <span class="hljs-built_in">ElfW</span>(Addr) bitmask_word<br>    = bitmask[(new_hash / __ELF_NATIVE_CLASS)&amp; map-&gt;l_gnu_bitmask_idxbits];<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashbit1 = new_hash &amp; (__ELF_NATIVE_CLASS - <span class="hljs-number">1</span>);<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashbit2 = ((new_hash &gt;&gt; map-&gt;l_gnu_shift)<br>                           &amp; (__ELF_NATIVE_CLASS - <span class="hljs-number">1</span>));<br>  <span class="hljs-keyword">if</span> (__glibc_unlikely ((bitmask_word &gt;&gt; hashbit1)<br>                        &amp; (bitmask_word &gt;&gt; hashbit2) &amp; <span class="hljs-number">1</span>))<br>  &#123;<br>    Elf32_Word bucket = map-&gt;l_gnu_buckets[new_hash<br>                                           % map-&gt;l_nbuckets];<br>    <span class="hljs-keyword">if</span> (bucket != <span class="hljs-number">0</span>)<br>    &#123;<br>      <span class="hljs-type">const</span> Elf32_Word *hasharr = &amp;map-&gt;l_gnu_chain_zero[bucket];<br>      <span class="hljs-function"><span class="hljs-keyword">do</span></span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(((*hasharr ^ new_hash) &gt;&gt; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">        </span>&#123;<br>          symidx = hasharr - map-&gt;l_gnu_chain_zero;<br>          sym = <span class="hljs-built_in">check_match</span> (undef_name, ref, version, flags,<br>                             type_class, &amp;symtab[symidx], symidx,<br>                             strtab, map, &amp;versioned_sym,<br>                             &amp;num_versions);<br>          <span class="hljs-keyword">if</span> (sym != <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">goto</span> found_it;<br>        &#125;<br>      <span class="hljs-keyword">while</span> ((*hasharr++ &amp; <span class="hljs-number">1u</span>) == <span class="hljs-number">0</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span><br>  &#123;<br>    <span class="hljs-comment">/* Use the old SysV-style hash table.  Search the appropriate</span><br><span class="hljs-comment">       hash bucket in this object&#x27;s symbol table for a definition</span><br><span class="hljs-comment">       for the same symbol name.  */</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="详解">详解</h1><p>.gnu.hash 需要有多个导出符号才能较方便地分析，因此我们将使用 test_gnu_hash.cpp 作为待分析的文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// test_gnu_hash.cpp</span><br><span class="hljs-comment">// g++ -std=c++11 -shared -fPIC test_gnu_hash.cpp -o libtest_gnu_hash.so</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">haha</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">more</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dynamic libtest_gnu_hash.so | grep -E &quot;Tag|GNU_HASH&quot;</span><br>  Tag        Type                         Name/Value<br> 0x000000006ffffef5 (GNU_HASH)           0x260<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --section-headers libtest_gnu_hash.so | grep -E &quot;Nr|260&quot; -A1 | grep -v &quot;\-\-&quot;</span><br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 2] .gnu.hash         GNU_HASH         0000000000000260  00000260<br>       0000000000000038  0000000000000000   A       3     0     8<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># export gnu_hash_start_addr=0x260</span><br><span class="hljs-comment"># export gnu_hash_size=0x38</span><br><span class="hljs-comment"># od --skip-bytes=$gnu_hash_start_addr --read-bytes=$gnu_hash_size --format=xI libtest_gnu_hash.so</span><br>0001140 00000003 00000005 00000001 00000006<br>0001160 04200400 18012908 00000005 00000008<br>0001200 00000000 b8f7d29a b95a257a b9d35b69<br>0001220 6a5ebc3c 6a6128eb<br></code></pre></td></tr></table></figure><table style="width:100%;"><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">l_nbuckets</th><th style="text-align: center;">symbias</th><th style="text-align: center;">bitmask_nwords</th><th style="text-align: center;">l_gnu_bitmask_idxbits</th><th style="text-align: center;">l_gnu_shift</th><th style="text-align: center;">l_gnu_bitmask</th><th style="text-align: center;">l_gnu_buckets</th><th style="text-align: center;">l_gnu_chain_zero + symbias</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">value</td><td style="text-align: center;">0x3</td><td style="text-align: center;">0x5</td><td style="text-align: center;">0x1</td><td style="text-align: center;">0x0</td><td style="text-align: center;">0x6</td><td style="text-align: center;">0x1801290804200400</td><td style="text-align: center;">[0x5, 0x8, 0x0]</td><td style="text-align: center;">[0xb8f7d29a, 0xb95a257a, 0xb9d35b69, 0x6a5ebc3c, 0x6a6128eb]</td></tr></tbody></table><h2 id="哈希表">哈希表</h2><p>编译器实现哈希表时用了几个技巧：</p><ol type="1"><li>用一维数组 <code>l_gnu_chain_zero + symbias</code> 实现二维哈希表：<ol type="1"><li>将在同一个哈希桶内的元素放在数组的连续区域；</li><li>用另一个一维数组 <code>l_gnu_buckets</code> 记录哈希桶的起始位置；</li><li>约定哈希桶的最后一个元素的最后一个比特是 1 ，其余元素的最后一个比特是 0 ；</li></ol></li><li>为节省哈希表空间：<ol type="1"><li>哈希表只记录哈希值，不记录符号在 .dynsym 表中的下标；</li><li>哈希表只记录可导出符号（比如 <code>_Z3foov</code> ）的哈希值，不记录不可导出符号（比如 <code>__cxa_finalize@GLIBC_2.2.5</code> ）的哈希值；</li><li>为同时达到以上两个目标，编译器在 .dynsym 表中将不可导出符号（比如 <code>__cxa_finalize@GLIBC_2.2.5</code> ）排在可导出符号（比如 <code>_Z3foov</code> ）的前面，将第一个可导出符号在 .dynsym 表中的下标记为 <code>symbias</code> ，计算 <code>l_gnu_chain_zero</code> 的公式是 <code>map-&gt;l_gnu_chain_zero = map-&gt;l_gnu_buckets + map-&gt;l_nbuckets - symbias</code> 。</li></ol></li></ol><p>因此，链接器查找哈希表的步骤是：</p><ol type="1"><li>根据 <code>l_gnu_buckets</code> 找到哈希桶的第一个元素；</li><li>顺序搜索哈希桶内的元素，直到找到相应的哈希值或者到达结尾。</li></ol><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-search-symbols-in-one-binary/one-dimensional-hash-table.png" /></p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-search-symbols-in-one-binary/two-dimensional-hash-table.png" /></p><table><thead><tr class="header"><th style="text-align: center;">id</th><th style="text-align: center;">name</th><th style="text-align: center;">new_hash</th><th style="text-align: center;">处理最后一个比特后</th><th style="text-align: center;">bucket</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">_Z4hahav</td><td style="text-align: center;">0xb8f7d29a</td><td style="text-align: center;">0xb8f7d29a</td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">6</td><td style="text-align: center;">_Z4morev</td><td style="text-align: center;">0xb95a257b</td><td style="text-align: center;">0xb95a257a</td><td style="text-align: center;">0</td></tr><tr class="odd"><td style="text-align: center;">7</td><td style="text-align: center;">_Z4testv</td><td style="text-align: center;">0xb9d35b68</td><td style="text-align: center;"><strong>0xb9d35b69</strong></td><td style="text-align: center;">0</td></tr><tr class="even"><td style="text-align: center;">8</td><td style="text-align: center;">_Z3barv</td><td style="text-align: center;">0x6a5ebc3c</td><td style="text-align: center;">0x6a5ebc3c</td><td style="text-align: center;">1</td></tr><tr class="odd"><td style="text-align: center;">9</td><td style="text-align: center;">_Z3foov</td><td style="text-align: center;">0x6a6128eb</td><td style="text-align: center;"><strong>0x6a6128eb</strong></td><td style="text-align: center;">1</td></tr></tbody></table><p>加粗部分是每个哈希桶的最后一个元素，最后一个比特需要置成 1 。</p><ol type="1"><li>根据 <code>l_gnu_buckets</code> 找到哈希桶的第一个元素；</li><li>顺序搜索哈希桶内的元素，直到找到相应的哈希值或者到达结尾。</li></ol><h3 id="symbias">symbias</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf --dyn-syms libtest_gnu_hash.so</span><br>Symbol table <span class="hljs-string">&#x27;.dynsym&#x27;</span> contains 10 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>     1: 0000000000000000     0 FUNC    WEAK   DEFAULT  UND __cxa_finalize@GLIBC_2.2.5 (2)<br>     2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_deregisterTMCloneTab<br>     3: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__<br>     4: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable<br>     5: 000000000000110a     7 FUNC    GLOBAL DEFAULT   11 _Z4hahav<br>     6: 0000000000001111     7 FUNC    GLOBAL DEFAULT   11 _Z4morev<br>     7: 0000000000001103     7 FUNC    GLOBAL DEFAULT   11 _Z4testv<br>     8: 00000000000010fc     7 FUNC    GLOBAL DEFAULT   11 _Z3barv<br>     9: 00000000000010f5     7 FUNC    GLOBAL DEFAULT   11 _Z3foov<br></code></pre></td></tr></table></figure><p><code>symbias</code> 表明第一个可以通过 .gnu.hash section 访问的符号（即可以提供给其它库访问的符号），在 <code>libtest_gnu_hash.so</code> 中这个符号是 <code>_Z4hahav</code> 。</p><h2 id="布隆过滤器">布隆过滤器</h2><p>布隆过滤器的原理可以参考文章<a href="https://zhuanlan.zhihu.com/p/43263751">详解布隆过滤器的原理，使用场景和注意事项</a>，简而言之，将数据使用多个不同的哈希函数生成多个哈希值，并将对应比特位置为 1 ，就能判断某个数据肯定不存在。</p><p>参考 <a href="https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2">GNU Hash ELF Sections</a> ，构建布隆过滤器的伪代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">uint_fast32_t</span> new_hash = <span class="hljs-built_in">dl_new_hash</span>(undef_name);<br><span class="hljs-type">uint32_t</span> H1 = new_hash;<br><span class="hljs-type">uint32_t</span> H2 = new_hash &gt;&gt; map-&gt;l_gnu_shift;<br><span class="hljs-type">uint32_t</span> N = (H1 / __ELF_NATIVE_CLASS) &amp; map-&gt;l_gnu_bitmask_idxbits;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashbit1 = H1 % __ELF_NATIVE_CLASS;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashbit2 = H2 % __ELF_NATIVE_CLASS;<br>bloom[N] |= (<span class="hljs-number">1</span> &lt;&lt; hashbit1);<br>bloom[N] |= (<span class="hljs-number">1</span> &lt;&lt; hashbit2);<br></code></pre></td></tr></table></figure><p>构建布隆过滤器的 C++ 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// bloom.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ios&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">uint32_t</span> <span class="hljs-title">dl_new_hash</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint32_t</span> h = <span class="hljs-number">5381</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> c = *s; c != <span class="hljs-string">&#x27;\0&#x27;</span>; c = *++s)<br>    h = h * <span class="hljs-number">33</span> + c;<br>  <span class="hljs-keyword">return</span> h &amp; <span class="hljs-number">0xffffffff</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> __ELF_NATIVE_CLASS = <span class="hljs-number">64</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> l_gnu_shift = <span class="hljs-number">6</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> bitmask_nwords = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> l_gnu_bitmask_idxbits = bitmask_nwords - <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">new_bitmask</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">uint64_t</span>* bitmask_arr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint32_t</span> hash_value1 = <span class="hljs-built_in">dl_new_hash</span>(s);<br>  <span class="hljs-type">uint32_t</span> hash_value2 = hash_value1 &gt;&gt; l_gnu_shift;<br>  <span class="hljs-type">int</span> n = (hash_value1 / __ELF_NATIVE_CLASS) &amp; l_gnu_bitmask_idxbits;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashbit1 = hash_value1 % __ELF_NATIVE_CLASS;<br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> hashbit2 = hash_value2 % __ELF_NATIVE_CLASS;<br>  <span class="hljs-comment">// Please use 1L (64 bits) instead of 1 (32 bits).</span><br>  bitmask_arr[n] |= (<span class="hljs-number">1L</span> &lt;&lt; hashbit1);<br>  bitmask_arr[n] |= (<span class="hljs-number">1L</span> &lt;&lt; hashbit2);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">uint64_t</span> bitmask_arr[bitmask_nwords] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-built_in">new_bitmask</span>(<span class="hljs-string">&quot;_Z4hahav&quot;</span>, bitmask_arr);<br>  <span class="hljs-built_in">new_bitmask</span>(<span class="hljs-string">&quot;_Z4morev&quot;</span>, bitmask_arr);<br>  <span class="hljs-built_in">new_bitmask</span>(<span class="hljs-string">&quot;_Z4testv&quot;</span>, bitmask_arr);<br>  <span class="hljs-built_in">new_bitmask</span>(<span class="hljs-string">&quot;_Z3barv&quot;</span>, bitmask_arr);<br>  <span class="hljs-built_in">new_bitmask</span>(<span class="hljs-string">&quot;_Z3foov&quot;</span>, bitmask_arr);<br>  std::cout &lt;&lt; std::hex &lt;&lt; <span class="hljs-string">&quot;0x&quot;</span> &lt;&lt; bitmask_arr[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 0x1801290804200400</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="more">More</h1><p>编译器如何处理哈希冲突？</p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://blogs.oracle.com/solaris/gnu-hash-elf-sections-v2">GNU Hash ELF Sections</a></li><li><a href="https://zhuanlan.zhihu.com/p/43263751">知乎：详解布隆过滤器的原理，使用场景和注意事项</a></li><li><a href="https://answerywj.com/2020/05/14/ld-hash-style/">AnSwEr's Blog ：--hash-style 兼容性问题</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Symbol Search Order</title>
    <link href="/2020/11/18/computer-science/dynamic-linking/symbol-search-order/"/>
    <url>/2020/11/18/computer-science/dynamic-linking/symbol-search-order/</url>
    
    <content type="html"><![CDATA[<h1 id="导读">导读</h1><p>这篇文章探讨了<strong>目前</strong>链接器在各个文件之间查找符号的顺序，对于大多数链接过程：</p><ol type="1"><li>可执行文件及其加载的动态链接库都会被加载到 id 为 <code>LM_ID_BASE</code> = 0 的 namespace 下；</li><li>符号都能在 <code>l_scope[0]</code> 指向的已加载文件列表（即 global scope ）中找到；</li><li>查找符号的顺序是 <code>main_map-&gt;l_searchlist</code> 的顺序，也即广度优先遍历依赖树的顺序：<ol type="1"><li><code>link_map-&gt;l_scope[0]</code> 指向 <code>GL(dl_ns)[nsid]._ns_loaded-&gt;l_searchlist</code> ，又因为 <code>GL(dl_ns)[nsid]._ns_loaded</code> 是 <code>main_map</code> ，所以 <code>link_map-&gt;l_scope[0]</code> 指向 <code>main_map-&gt;l_searchlist</code> ；</li><li>根据 <a href="https://clcanny.github.io/2020/11/15/dynamic-linking-init-order/">Dynamic Linking: Init Order</a> 的说法，<code>main_map-&gt;l_searchlist</code> 指向 <code>main_map-&gt;l_initfini</code> 的后半段，这部分未经 <code>_dl_sort_maps</code> 函数排序，仍然保持着广度优先遍历依赖树的顺序。</li></ol></li></ol><h1 id="code">Code</h1><h2 id="l_scope">l_scope</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Structure to describe a single list of scope elements.  The lookup</span><br><span class="hljs-comment">   functions get passed an array of pointers to such structures.  */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">r_scope_elem</span><br>&#123;<br>  <span class="hljs-comment">/* Array of maps for the scope.  */</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span> **r_list;<br>  <span class="hljs-comment">/* Number of entries in the scope.  */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> r_nlist;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">link_map</span><br>  &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-comment">/* Size of array allocated for &#x27;l_scope&#x27;.  */</span><br>    <span class="hljs-type">size_t</span> l_scope_max;<br>    <span class="hljs-comment">/* This is an array defining the lookup scope for this link map.</span><br><span class="hljs-comment">       There are initially at most three different scope lists.  */</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">r_scope_elem</span> **l_scope;<br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br></code></pre></td></tr></table></figure><h2 id="赋值-l_scope">赋值 l_scope</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Storage management for the chain of loaded shared objects.</span><br><span class="hljs-comment">   Copyright (C) 1995-2018 Free Software Foundation, Inc.</span><br><span class="hljs-comment">   This file is part of the GNU C Library.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The GNU C Library is free software; you can redistribute it and/or</span><br><span class="hljs-comment">   modify it under the terms of the GNU Lesser General Public</span><br><span class="hljs-comment">   License as published by the Free Software Foundation; either</span><br><span class="hljs-comment">   version 2.1 of the License, or (at your option) any later version.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The GNU C Library is distributed in the hope that it will be useful,</span><br><span class="hljs-comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="hljs-comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span><br><span class="hljs-comment">   Lesser General Public License for more details.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   You should have received a copy of the GNU Lesser General Public</span><br><span class="hljs-comment">   License along with the GNU C Library; if not, see</span><br><span class="hljs-comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span><br><br><span class="hljs-comment">// Add the new link_map `new` to the end of the namespace list.</span><br><span class="hljs-type">void</span> _dl_add_to_namespace_list(<span class="hljs-keyword">struct</span> link_map* new, Lmid_t nsid) &#123;<br>  _dl_debug_printf(<br>      <span class="hljs-string">&quot;\nadding object %s to 0x%x as global scope with namespace id %u\n\n&quot;</span>,<br>      <span class="hljs-built_in">strlen</span>(new-&gt;l_name) == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;&lt;empty libname&gt;&quot;</span> : new-&gt;l_name,<br>      GL(dl_ns)[nsid]._ns_loaded,<br>      nsid);<br><br>  <span class="hljs-keyword">if</span> (GL(dl_ns)[nsid]._ns_loaded != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">l</span> =</span> GL(dl_ns)[nsid]._ns_loaded;<br>    <span class="hljs-keyword">while</span> (l-&gt;l_next != <span class="hljs-literal">NULL</span>)<br>      l = l-&gt;l_next;<br>    new-&gt;l_prev = l;<br>    new-&gt;l_next = <span class="hljs-literal">NULL</span>;<br>    l-&gt;l_next = new;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    GL(dl_ns)[nsid]._ns_loaded = new;<br>  &#125;<br>  ++GL(dl_ns)[nsid]._ns_nloaded;<br>  new-&gt;l_serial = GL(dl_load_adds);<br>  ++GL(dl_load_adds);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* _<span class="hljs-title">dl_new_object</span>(<span class="hljs-title">char</span>* <span class="hljs-title">realname</span>,</span><br><span class="hljs-class">                                <span class="hljs-title">const</span> <span class="hljs-title">char</span>* <span class="hljs-title">libname</span>,</span><br><span class="hljs-class">                                <span class="hljs-title">int</span> <span class="hljs-title">type</span>,</span><br><span class="hljs-class">                                <span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">loader</span>,</span><br><span class="hljs-class">                                <span class="hljs-title">int</span> <span class="hljs-title">mode</span>,</span><br><span class="hljs-class">                                <span class="hljs-title">Lmid_t</span> <span class="hljs-title">nsid</span>) &#123;</span><br>  _dl_debug_printf(<span class="hljs-string">&quot;\ncreating object of %s with namespace id %u\n\n&quot;</span>,<br>                   <span class="hljs-built_in">strlen</span>(libname) == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;&lt;empty libname&gt;&quot;</span> : libname,<br>                   nsid);<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">new</span> =</span> (<span class="hljs-keyword">struct</span> link_map*)<span class="hljs-built_in">calloc</span>(<br>      <span class="hljs-keyword">sizeof</span>(*new) + audit_space + <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> link_map*) + <span class="hljs-keyword">sizeof</span>(*newname) +<br>          libname_len,<br>      <span class="hljs-number">1</span>);<br><br>  <span class="hljs-comment">// Counter for the scopes we have to handle.</span><br>  <span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (GL(dl_ns)[nsid]._ns_loaded != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// Add the global scope.</span><br>    new-&gt;l_scope[idx++] = &amp;GL(dl_ns)[nsid]._ns_loaded-&gt;l_searchlist;<br>    _dl_debug_printf(<span class="hljs-string">&quot;\nassigning l_searchlist (0x%x) of 0x%x as global scope &quot;</span><br>                     <span class="hljs-string">&quot;to l_scope[%u] of object %s\n\n&quot;</span>,<br>                     &amp;GL(dl_ns)[nsid]._ns_loaded-&gt;l_searchlist,<br>                     GL(dl_ns)[nsid]._ns_loaded,<br>                     idx - <span class="hljs-number">1</span>,<br>                     <span class="hljs-built_in">strlen</span>(libname) == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;&lt;empty libname&gt;&quot;</span> : libname);<br>  &#125;<br><br>  new-&gt;l_local_scope[<span class="hljs-number">0</span>] = &amp;new-&gt;l_searchlist;<br>  <span class="hljs-keyword">return</span> new;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-symbol-search-order/l-scope-point-to-l-searchlist.png" /></p><h1 id="证明">证明</h1><h2 id="namespace">Namespace</h2><p>namespace 是链接器提供的隔离机制，根据 <a href="https://sourceware.org/glibc/wiki/LinkerNamespaces">glic wiki: Linker Namespaces</a> 的说法，namespace 一开始用于隔离：</p><ol type="1"><li>可执行文件及其加载的动态链接库</li><li>LD_AUDIT 及其加载的动态链接库</li></ol><p>正常情况下，可执行文件及其加载的动态链接库都会被加载到 id 为 <code>LM_ID_BASE</code> = 0 的 namespace 下，它们之间不存在隔离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// lib.cpp</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Makefile</span><br>all :<br>    gcc lib.cpp -shared -fPIC -o liba.so<br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -la -o libb.so<br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -lb -o libe.so<br>    gcc main.cpp                                                                        \<br>            -Wl,--dynamic-linker=<span class="hljs-variable">$(PWD)</span>/../glibc/build/install/lib/ld-linux-x86-64.so.2 \<br>            -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -le                                              \<br>            -o main<br>    LD_DEBUG=all ./main 2&gt;&amp;1 | grep <span class="hljs-string">&quot;creating object&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># make</span><br>LD_DEBUG=all ./main 2&gt;&amp;1 | grep <span class="hljs-string">&quot;creating object&quot;</span><br>      2313:     creating object of &lt;empty libname&gt; with namespace <span class="hljs-built_in">id</span> 0<br>      2313:     creating object of &lt;empty libname&gt; with namespace <span class="hljs-built_in">id</span> 0<br>      2313:     creating object of libe.so with namespace <span class="hljs-built_in">id</span> 0<br>      2313:     creating object of libc.so.6 with namespace <span class="hljs-built_in">id</span> 0<br>      2313:     creating object of libb.so with namespace <span class="hljs-built_in">id</span> 0<br>      2313:     creating object of liba.so with namespace <span class="hljs-built_in">id</span> 0<br></code></pre></td></tr></table></figure><p>各个动态链接库都使用了 id 为 0 的 namespace 。</p><h2 id="scope">Scope</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># LD_DEBUG=all ./main 2&gt;&amp;1 | grep -E &quot;creating main map |assigning&quot;</span><br>      2390:     creating main map at: 0x57cde190<br>      2390:     assigning l_searchlist (0x57cde450) of 0x57cde190 as global scope to l_scope[0] of object &lt;empty libname&gt;<br>      2390:     assigning l_searchlist (0x57cde450) of 0x57cde190 as global scope to l_scope[0] of object libe.so<br>      2390:     assigning l_searchlist (0x57cde450) of 0x57cde190 as global scope to l_scope[0] of object libc.so.6<br>      2390:     assigning l_searchlist (0x57cde450) of 0x57cde190 as global scope to l_scope[0] of object libb.so<br>      2390:     assigning l_searchlist (0x57cde450) of 0x57cde190 as global scope to l_scope[0] of object liba.so<br></code></pre></td></tr></table></figure><p>各个动态链接库都使用了可执行文件的 <code>l_searchlist</code> 作为 <code>l_scope[0]</code> 。</p><h2 id="order">Order</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-built_in">sayHello</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// b.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* var;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; var &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// f.cpp</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* var = <span class="hljs-string">&quot;I&#x27;m in f.&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g.cpp</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* var = <span class="hljs-string">&quot;I&#x27;m in g.&quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// empty.cpp</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Makefile</span><br>all :<br>    g++ -std=c++11 empty.cpp -shared -fPIC -o libe.so<br>    g++ -std=c++11 f.cpp -shared -fPIC -o libf.so<br>    g++ -std=c++11 g.cpp -shared -fPIC -o libg.so<br>    g++ -std=c++11 empty.cpp -shared -fPIC -o libh.so<br>    g++ -std=c++11 empty.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -le -lf -o liba.so<br>    g++ -std=c++11 b.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -lg -lh -o libb.so<br>    g++ -std=c++11 -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -la -lb main.cpp -o main<br>    LD_DEBUG=all ./main 2&gt;&amp;1 | grep -E <span class="hljs-string">&quot;var|I&#x27;m in&quot;</span><br></code></pre></td></tr></table></figure><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-symbol-search-order/order.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># make</span><br>LD_DEBUG=all ./main 2&gt;&amp;1 | grep -E <span class="hljs-string">&quot;var|I&#x27;m in&quot;</span><br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=./main [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/home/demons/_dl_map_objects_validate/search_symbol_order/liba.so [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/home/demons/_dl_map_objects_validate/search_symbol_order/libb.so [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/usr/lib/x86_64-linux-gnu/libstdc++.so.6 [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/lib/x86_64-linux-gnu/libm.so.6 [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/lib/x86_64-linux-gnu/libgcc_s.so.1 [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/lib/x86_64-linux-gnu/libc.so.6 [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/home/demons/_dl_map_objects_validate/search_symbol_order/libe.so [0]<br>      6382:     symbol=var;  lookup <span class="hljs-keyword">in</span> file=/home/demons/_dl_map_objects_validate/search_symbol_order/libf.so [0]<br>      6382:     binding file /home/demons/_dl_map_objects_validate/search_symbol_order/libb.so [0] to /home/demons/_dl_map_objects_validate/search_symbol_order/libf.so [0]: normal symbol `var<span class="hljs-string">&#x27;</span><br><span class="hljs-string">I&#x27;</span>m <span class="hljs-keyword">in</span> f.<br></code></pre></td></tr></table></figure><h1 id="a-coredump">A coredump</h1><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-symbol-search-order/coredump.png" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// a.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-type">const</span> std::string var = <span class="hljs-string">&quot;I&#x27;m in a.&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accessVar</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; var[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// b.cpp</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accessVar</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">AccessVar</span> &#123;<br>  <span class="hljs-built_in">AccessVar</span>() &#123;<br>    <span class="hljs-built_in">accessVar</span>();<br>  &#125;<br>&#125; _;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// e.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> &#123;<br><span class="hljs-type">const</span> std::string var = <span class="hljs-string">&quot;I&#x27;m in e.&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accessVar</span><span class="hljs-params">()</span> </span>&#123;<br>  std::cout &lt;&lt; var[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Makefile</span><br>all :<br>    g++ e.cpp -shared -fPIC -O3 -o libe.so<br>    g++ a.cpp -shared -fPIC -O3 -o liba.so<br>    g++ b.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -le -O3 -o libb.so<br>    g++ main.cpp -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -la -lb -O3 -o main<br>    LD_DEBUG=all ./main 2&gt;&amp;1 | grep -E <span class="hljs-string">&quot;calling init|accessVar&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">Segmentation fault<br>     14934:     calling init: /lib/x86_64-linux-gnu/libc.so.6<br>     14934:     calling init: /lib/x86_64-linux-gnu/libm.so.6<br>     14934:     calling init: /lib/x86_64-linux-gnu/libgcc_s.so.1<br>     14934:     calling init: /usr/lib/x86_64-linux-gnu/libstdc++.so.6<br>     14934:     calling init: /home/demons/_dl_map_objects_validate/search_symbol_order/libe.so<br>     14934:     calling init: /home/demons/_dl_map_objects_validate/search_symbol_order/libb.so<br>     14934:     symbol=_Z9accessVarv;  lookup <span class="hljs-keyword">in</span> file=./main [0]<br>     14934:     symbol=_Z9accessVarv;  lookup <span class="hljs-keyword">in</span> file=/home/demons/_dl_map_objects_validate/search_symbol_order/liba.so [0]<br>     14934:     binding file /home/demons/_dl_map_objects_validate/search_symbol_order/libb.so [0] to /home/demons/_dl_map_objects_validate/search_symbol_order/liba.so [0]: normal symbol `_Z9accessVarv<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>初始化的顺序是 eba ，查找符号的顺序是 abe ，因此初始化 libb.so 的时候用到了来自 liba.so 的、尚未初始化的 <code>var</code> 变量，导致 coredump 。</p><h1 id="more">More</h1><p>关于 Namespace 和 Scope 的 corner case ，后续会另写一篇文章来探讨。</p><h1 id="参考资料">参考资料</h1><ul><li><a href="https://sourceware.org/glibc/wiki/LinkerNamespaces">glic wiki: Linker Namespaces</a></li><li><a href="https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter6-1243/index.html">Oracle: Establishing a Namespace</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Init Order</title>
    <link href="/2020/11/15/computer-science/dynamic-linking/init-order/"/>
    <url>/2020/11/15/computer-science/dynamic-linking/init-order/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="导读">导读</h1><p>这篇文章探讨了<strong>目前</strong>动态链接库的初始化顺序：</p><ol type="1"><li>精华在 Code 一节，笔者简化了 <code>_dl_sort_maps</code> 和 <code>_dl_map_object_deps</code> ，并为之添加了图示，有利于从代码层面理解动态链接库的初始化顺序；</li><li>一般而言，<code>_dl_sort_maps</code> 不会产生任何影响，在这种情况下，动态链接库的初始化顺序是广度优先遍历依赖树的逆序；</li><li><code>_dl_sort_maps</code> 的核心思想是：被依赖的链接库应该先于依赖它的链接库初始化；</li><li>用两个例子证明我们的理解是对的。</li></ol><h1 id="code">Code</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Load the dependencies of a mapped object.</span><br><span class="hljs-comment">   Copyright (C) 1996-2018 Free Software Foundation, Inc.</span><br><span class="hljs-comment">   This file is part of the GNU C Library.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The GNU C Library is free software; you can redistribute it and/or</span><br><span class="hljs-comment">   modify it under the terms of the GNU Lesser General Public</span><br><span class="hljs-comment">   License as published by the Free Software Foundation; either</span><br><span class="hljs-comment">   version 2.1 of the License, or (at your option) any later version.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The GNU C Library is distributed in the hope that it will be useful,</span><br><span class="hljs-comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="hljs-comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span><br><span class="hljs-comment">   Lesser General Public License for more details.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   You should have received a copy of the GNU Lesser General Public</span><br><span class="hljs-comment">   License along with the GNU C Library; if not, see</span><br><span class="hljs-comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span><br><br><span class="hljs-comment">// We use a very special kind of list to track the path through the list of</span><br><span class="hljs-comment">// loaded shared objects.  We have to produce a flat list with unique members of</span><br><span class="hljs-comment">// all involved objects.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br>    <span class="hljs-type">int</span> done;              <span class="hljs-comment">// Nonzero if this map was processed.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">map</span>;</span>  <span class="hljs-comment">// The data.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">next</span>;</span>     <span class="hljs-comment">// Elements for normal list.</span><br>&#125;;<br><br><span class="hljs-comment">// Sort array `maps` according to dependencies of the contained objects.</span><br><span class="hljs-type">void</span> _dl_sort_maps(<span class="hljs-keyword">struct</span> link_map** maps, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nmaps) &#123;<br>    <span class="hljs-type">uint16_t</span> seen[nmaps];<br>    <span class="hljs-built_in">memset</span>(seen, <span class="hljs-number">0</span>, nmaps * <span class="hljs-keyword">sizeof</span>(seen[<span class="hljs-number">0</span>]));<br>    <span class="hljs-comment">//                                                  i</span><br>    <span class="hljs-comment">//                                                  │</span><br>    <span class="hljs-comment">// ┌───────────────────────┬───────────────────────┬▼┬─┬─┬─┬─┬─┐</span><br>    <span class="hljs-comment">// │           a           │           b           │c│d│e│f│g│h│</span><br>    <span class="hljs-comment">// ├───────────────────────┴───────────────────────┼─┴─┴─┴─┴─┴─┤</span><br>    <span class="hljs-comment">// │  The elements between [0,i) has been sorted,  │Hasn&#x27;t been│</span><br>    <span class="hljs-comment">// │they doesn&#x27;t depend on the subsequent elements.│  sorted.  │</span><br>    <span class="hljs-comment">// └───────────────────────────────────────────────┴───────────┘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i++; i &lt; nmaps) &#123;<br>        <span class="hljs-comment">// `seen` records how many times we have seen element n at position `i`,</span><br>        <span class="hljs-comment">// it is used to detect ring.</span><br>        ++seen[i];<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">thisp</span> =</span> maps[i];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> k = nmaps - <span class="hljs-number">1</span>; k &gt; i; k--) &#123;<br>            <span class="hljs-comment">// Look through the dependencies of the object.</span><br>            <span class="hljs-comment">//      i     k            i     k</span><br>            <span class="hljs-comment">//      │     │            │     │</span><br>            <span class="hljs-comment">// ┌─┬─┬▼┬─┬─┬▼┬─┬─┐  ┌─┬─┬▼┬─┬─┬▼┬─┬─┐</span><br>            <span class="hljs-comment">// │a│b│c│d│e│f│g│h│  │a│b│d│e│f│c│g│h│</span><br>            <span class="hljs-comment">// └─┴─┴▲┴─┴─┴┬┴─┴─┘  └─┴─┴─┴─┴─┴─┴─┴─┘</span><br>            <span class="hljs-comment">//      │     │</span><br>            <span class="hljs-comment">//      │     │</span><br>            <span class="hljs-comment">//    f depends</span><br>            <span class="hljs-comment">//      on c.─┘</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> link_map** runp = maps[k]-&gt;l_initfini;<br>                 runp != <span class="hljs-literal">NULL</span> &amp;&amp; *runp != <span class="hljs-literal">NULL</span>;<br>                 runp++) &#123;<br>                <span class="hljs-keyword">if</span> (__glibc_unlikely(*runp == thisp)) &#123;<br>                    <span class="hljs-comment">// Move the current object to the back past the last</span><br>                    <span class="hljs-comment">// object with it as the dependency.</span><br>                    memmove(&amp;maps[i], &amp;maps[i + <span class="hljs-number">1</span>], (k - i) * <span class="hljs-keyword">sizeof</span>(maps[<span class="hljs-number">0</span>]));<br>                    maps[k] = thisp;<br>                    <span class="hljs-type">uint16_t</span> this_seen = seen[i];<br>                    memmove(&amp;seen[i], &amp;seen[i + <span class="hljs-number">1</span>], (k - i) * <span class="hljs-keyword">sizeof</span>(seen[<span class="hljs-number">0</span>]));<br>                    seen[k] = this_seen;<br><br>                    <span class="hljs-comment">// Found a ring in dependency tree, don&#x27;t try to sort them.</span><br>                    <span class="hljs-comment">// The following graph shows `seen[i] &gt; 1` isn&#x27;t right:</span><br>                    <span class="hljs-comment">//    ┌─────┐</span><br>                    <span class="hljs-comment">//    │     │    abcd</span><br>                    <span class="hljs-comment">// ┌─┬▼┬───┬┴┐   bcad</span><br>                    <span class="hljs-comment">// │a│b│ c │d│   cadb</span><br>                    <span class="hljs-comment">// └▲┴─┴┬─▲┴┬┘   adcb // seen[0] = 2, not ring.</span><br>                    <span class="hljs-comment">//  │   │ │ │    dcab</span><br>                    <span class="hljs-comment">//  └───┘ └─┘</span><br>                    <span class="hljs-keyword">if</span> (seen[i] &gt; nmaps - i) &#123;<br>                        <span class="hljs-keyword">goto</span> next;<br>                    &#125;<br>                    <span class="hljs-comment">// Reset `k` and check dependencies once again.</span><br>                    k = nmaps - <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    next:<br>        <span class="hljs-built_in">memset</span>(&amp;seen[i], <span class="hljs-number">0</span>, (nmaps - i) * <span class="hljs-keyword">sizeof</span>(seen[<span class="hljs-number">0</span>]));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// This isn&#x27;t a recursive function.</span><br><span class="hljs-type">void</span> _dl_map_object_deps(<span class="hljs-keyword">struct</span> link_map* <span class="hljs-built_in">map</span>,<br>                         <span class="hljs-keyword">struct</span> link_map** preloads,<br>                         <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> npreloads,<br>                         <span class="hljs-type">int</span> trace_mode,<br>                         <span class="hljs-type">int</span> open_mode) &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nlist = <span class="hljs-number">1</span> + npreloads;<br>    <span class="hljs-comment">// `__alloca` is used to allocate memory that is automatically freed.</span><br>    <span class="hljs-comment">// `known` is the queue used in the depth-first search process.</span><br>    <span class="hljs-comment">// `done` indicates whether the node has been searched, it is used to avoid</span><br>    <span class="hljs-comment">// infinite recursion when search a directed cyclic graph.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">known</span> =</span> __alloca(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>) * (nlist + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nlist + <span class="hljs-number">1</span>; i++) &#123;<br>        known[i].done = <span class="hljs-number">0</span>;<br>        known[i].next = &amp;known[i + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-comment">// 1. Load `map` itself.</span><br>    known[<span class="hljs-number">0</span>].<span class="hljs-built_in">map</span> = <span class="hljs-built_in">map</span>;<br>    <span class="hljs-comment">// We use `l_reserved` as a mark bit to detect objects we have already put</span><br>    <span class="hljs-comment">// in the search list and avoid adding duplicate elements later in the list.</span><br>    <span class="hljs-built_in">map</span>-&gt;l_reserved = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 2. Add the `preloaded` items after `map` but before any of its</span><br>    <span class="hljs-comment">// dependencies.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; npreloads; i++) &#123;<br>        known[i + <span class="hljs-number">1</span>].<span class="hljs-built_in">map</span> = preloads[i];<br>        preloads[i].l_reserved = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 3. Terminate the lists.</span><br>    known[nlist - <span class="hljs-number">1</span>].next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">// Pointer to last unique object.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">tail</span> =</span> &amp;known[nlist - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// clang-format off</span><br>    <span class="hljs-comment">//  known                  tail</span><br>    <span class="hljs-comment">//  │                      │</span><br>    <span class="hljs-comment">// ┌▼──┬───────────┬──────┬▼────────────────────┬───────────────────────────────┐┌───────┐</span><br>    <span class="hljs-comment">// │map│preloads[0]│......│preloads[npreloads-1]│known[1+preloads] // empty node││nullptr│</span><br>    <span class="hljs-comment">// └┬──┴▲─────────┬┴▲────┬┴▲───────────────────┬┴───────────────────────────────┘└▲──────┘</span><br>    <span class="hljs-comment">//  │   │         │ │    │ │                   │                                  │</span><br>    <span class="hljs-comment">//  └───┘         └─┘    └─┘                   └──────────────────────────────────┘</span><br>    <span class="hljs-comment">// clang-format on</span><br><br>    <span class="hljs-comment">// Process each element of the search list, loading each of its</span><br>    <span class="hljs-comment">// auxiliary objects and immediate dependencies.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Auxiliary objects will be added in the list before the object itself.</span><br>    <span class="hljs-comment">// https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/6n33n7f8u/index.html</span><br>    <span class="hljs-comment">// Note: I ignore codes about auxiliary objects because they are rarely</span><br>    <span class="hljs-comment">// used.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Dependencies will be appended to the list as we step through it.</span><br>    <span class="hljs-comment">// This produces a flat, ordered list that represents a breadth-first search</span><br>    <span class="hljs-comment">// of the dependency tree.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* runp = known; runp;) &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">l</span> =</span> runp-&gt;<span class="hljs-built_in">map</span>;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>** <span class="hljs-title">needed</span> =</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nneeded = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// Unless otherwise stated, this object is handled.</span><br>        <span class="hljs-comment">// If we have no auxiliary objects, `done` is 1.</span><br>        runp-&gt;done = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Allocate a temporary record to contain the references to the</span><br>        <span class="hljs-comment">// dependencies of this object.</span><br>        <span class="hljs-keyword">if</span> (l-&gt;l_searchlist.r_list == <span class="hljs-literal">NULL</span> &amp;&amp; l-&gt;l_initfini == <span class="hljs-literal">NULL</span> &amp;&amp;<br>            l != <span class="hljs-built_in">map</span> &amp;&amp; l-&gt;l_ldnum &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// l-&gt;l_ldnum includes space for the terminating NULL.</span><br>            needed = (<span class="hljs-keyword">struct</span> link_map**)<span class="hljs-built_in">malloc</span>(l-&gt;l_ldnum *<br>                                               <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> link_map*));<br>        &#125;<br><br>        <span class="hljs-comment">// l_info stores same information as `readelf --dynamic $elf`.</span><br>        <span class="hljs-comment">// Note: Omit l_info[AUXTAG] and l_info[FILTERTAG].</span><br>        <span class="hljs-keyword">if</span> (l-&gt;l_info[DT_NEEDED]) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span>* strtab = (<span class="hljs-type">const</span> <span class="hljs-type">void</span>*)D_PTR(l, l_info[DT_STRTAB]);<br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">orig</span>;</span><br>            <span class="hljs-type">const</span> <span class="hljs-title function_">ElfW</span><span class="hljs-params">(Dyn)</span> * d;<br><br>            <span class="hljs-keyword">for</span> (d = l-&gt;l_ld; d-&gt;d_tag != DT_NULL; ++d) &#123;<br>                <span class="hljs-keyword">if</span> (__builtin_expect(d-&gt;d_tag, DT_NEEDED) == DT_NEEDED) &#123;<br>                    <span class="hljs-comment">// Recognize DSTs.</span><br>                    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = expand_dst(l, strtab + d-&gt;d_un.d_val, <span class="hljs-number">0</span>);<br>                    <span class="hljs-comment">// Map in the needed object.</span><br>                    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>* <span class="hljs-title">dep</span> =</span> _dl_map_object(<br>                        l,<br>                        name,<br>                        l-&gt;l_type == lt_executable ? lt_library : l-&gt;l_type,<br>                        trace_mode,<br>                        open_mode,<br>                        l-&gt;l_ns);<br><br>                    <span class="hljs-comment">// clang-format off</span><br>                    <span class="hljs-comment">//  known                                                                           tail</span><br>                    <span class="hljs-comment">//  │                                                                               │</span><br>                    <span class="hljs-comment">// ┌▼──┬───────────┬──────┬─────────────────────┬────────────────────────────────┐ ┌▼───┐</span><br>                    <span class="hljs-comment">// │map│preloads[0]│......│preloads[npreloads-1]│known[1+preloads] // empty node │ │newp│</span><br>                    <span class="hljs-comment">// └┬──┴▲─────────┬┴▲────┬┴▲───────────────────┬┴────────────────────────────────┘ └▲───┘</span><br>                    <span class="hljs-comment">//  │   │         │ │    │ │                   │                                    │</span><br>                    <span class="hljs-comment">//  └───┘         └─┘    └─┘                   └────────────────────────────────────┘</span><br>                    <span class="hljs-comment">// clang-format on</span><br>                    <span class="hljs-comment">// `l_reserved` indicates if object is already in the search</span><br>                    <span class="hljs-comment">// list.</span><br>                    <span class="hljs-keyword">if</span> (!dep-&gt;l_reserved) &#123;<br>                        <span class="hljs-comment">// Allocate new entry.</span><br>                        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span>* <span class="hljs-title">newp</span> =</span> alloca(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>));<br>                        <span class="hljs-comment">// Append DEP to the list.</span><br>                        newp-&gt;<span class="hljs-built_in">map</span> = dep;<br>                        newp-&gt;done = <span class="hljs-number">0</span>;<br>                        newp-&gt;next = <span class="hljs-literal">NULL</span>;<br>                        tail-&gt;next = newp;<br>                        tail = newp;<br>                        ++nlist;<br>                        <span class="hljs-comment">// Set the mark bit that says it&#x27;s already in the list.</span><br>                        dep-&gt;l_reserved = <span class="hljs-number">1</span>;<br>                    &#125;<br><br>                    <span class="hljs-comment">// Remember this dependency.</span><br>                    <span class="hljs-keyword">if</span> (needed != <span class="hljs-literal">NULL</span>) &#123;<br>                        needed[nneeded++] = dep;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// Note: Omit DT_AUXILIARY and DT_FILTER.</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// Terminate the list of dependencies and store the array address.</span><br>        <span class="hljs-keyword">if</span> (needed != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-comment">// Please note nneeded include size of NULL.</span><br>            needed[nneeded++] = <span class="hljs-literal">NULL</span>;<br>            <span class="hljs-comment">// List of object in order of the init and fini calls.</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>** <span class="hljs-title">l_initfini</span> =</span> (<span class="hljs-keyword">struct</span> link_map**)<span class="hljs-built_in">malloc</span>(<br>                (<span class="hljs-number">2</span> * nneeded + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(needed[<span class="hljs-number">0</span>]));<br>            l_initfini[<span class="hljs-number">0</span>] = l;<br>            <span class="hljs-built_in">memcpy</span>(&amp;l_initfini[<span class="hljs-number">1</span>], needed, nneeded * <span class="hljs-keyword">sizeof</span>(needed[<span class="hljs-number">0</span>]));<br>            <span class="hljs-built_in">memcpy</span>(&amp;l_initfini[nneeded + <span class="hljs-number">1</span>],<br>                   l_initfini,<br>                   nneeded * <span class="hljs-keyword">sizeof</span>(needed[<span class="hljs-number">0</span>]));<br>            <span class="hljs-comment">// clang-format off</span><br>            <span class="hljs-comment">// ┌─┬─────────┬───┬─────────────────┬───────┬─┬─────────┬───┬─────────────────┐</span><br>            <span class="hljs-comment">// │l│needed[0]│...│needed[nneeded-1]│nullptr│l│needed[0]│...│needed[nneeded-1]│</span><br>            <span class="hljs-comment">// └─┴─────────┴───┴─────────────────┴───────┴─┴─────────┴───┴─────────────────┘</span><br>            <span class="hljs-comment">// clang-format on</span><br>            l-&gt;l_initfini = l_initfini;<br>        &#125;<br><br>        <span class="hljs-comment">// If we have no auxiliary objects just go on to the next map.</span><br>        <span class="hljs-keyword">if</span> (runp-&gt;done) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                runp = runp-&gt;next;<br>            &#125; <span class="hljs-keyword">while</span> (runp != <span class="hljs-literal">NULL</span> &amp;&amp; runp-&gt;done);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Store the search list we built in the object.</span><br>    <span class="hljs-comment">// It will be used for searches in the scope of this object.</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">link_map</span>** <span class="hljs-title">l_initfini</span> =</span><br>        (<span class="hljs-keyword">struct</span> link_map**)<span class="hljs-built_in">malloc</span>((<span class="hljs-number">2</span> * nlist + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> link_map*));<br>    <span class="hljs-built_in">map</span>-&gt;l_searchlist.r_list = &amp;l_initfini[nlist + <span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">map</span>-&gt;l_searchlist.r_nlist = nlist;<br><br>    <span class="hljs-keyword">for</span> (nlist = <span class="hljs-number">0</span>, <span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span>* runp = known; runp; runp = runp-&gt;next) &#123;<br>        <span class="hljs-built_in">map</span>-&gt;l_searchlist.r_list[nlist++] = runp-&gt;<span class="hljs-built_in">map</span>;<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Why?</span><br>        <span class="hljs-comment">// Now clear all the mark bits we set in the objects on the search list</span><br>        <span class="hljs-comment">// to avoid duplicates, so the next call starts fresh.</span><br>        runp-&gt;<span class="hljs-built_in">map</span>-&gt;l_reserved = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Sort the initializer list to take dependencies into account.</span><br>    <span class="hljs-comment">// The binary itself will always be initialize last.</span><br>    <span class="hljs-built_in">memcpy</span>(<br>        l_initfini, <span class="hljs-built_in">map</span>-&gt;l_searchlist.r_list, nlist * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> link_map*));<br>    <span class="hljs-comment">// Terminate the list of dependencies.</span><br>    l_initfini[nlist] = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//  map-&gt;l_initfini</span><br>    <span class="hljs-comment">//  │</span><br>    <span class="hljs-comment">// ┌▼──┬───────────┬───┬─────────────────────┬──────┬───┬──────┐</span><br>    <span class="hljs-comment">// │map│preloads[0]│...│preloads[npreloads-1]│newp_1│...│newp_k│</span><br>    <span class="hljs-comment">// ├───┴───┬───────┴───┴─────────────────────┴──────┴───┴──────┘</span><br>    <span class="hljs-comment">// │nullptr│</span><br>    <span class="hljs-comment">// ├───┬───┴───────┬───┬─────────────────────┬──────┬───┬──────┐</span><br>    <span class="hljs-comment">// │map│preloads[0]│...│preloads[npreloads-1]│newp_1│...│newp_k│</span><br>    <span class="hljs-comment">// └▲──┴───────────┴───┴─────────────────────┴──────┴───┴──────┘</span><br>    <span class="hljs-comment">//  │</span><br>    <span class="hljs-comment">//  map-&gt;l_searchlist.r_list</span><br><br>    <span class="hljs-comment">// We can skip looking for the binary itself which is at the front of the</span><br>    <span class="hljs-comment">// search list, and skip fini parts.</span><br>    _dl_sort_maps(&amp;l_initfini[<span class="hljs-number">1</span>], nlist - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">map</span>-&gt;l_initfini = l_initfini;<br><br>    <span class="hljs-keyword">if</span> (l_reldeps != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-type">void</span>* old_l_reldeps = <span class="hljs-built_in">map</span>-&gt;l_reldeps;<br>        <span class="hljs-built_in">map</span>-&gt;l_reldeps = l_reldeps;<br>        _dl_scope_free(old_l_reldeps);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Run initializers for newly loaded objects.</span><br><span class="hljs-comment">   Copyright (C) 1995-2018 Free Software Foundation, Inc.</span><br><span class="hljs-comment">   This file is part of the GNU C Library.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The GNU C Library is free software; you can redistribute it and/or</span><br><span class="hljs-comment">   modify it under the terms of the GNU Lesser General Public</span><br><span class="hljs-comment">   License as published by the Free Software Foundation; either</span><br><span class="hljs-comment">   version 2.1 of the License, or (at your option) any later version.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   The GNU C Library is distributed in the hope that it will be useful,</span><br><span class="hljs-comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="hljs-comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span><br><span class="hljs-comment">   Lesser General Public License for more details.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   You should have received a copy of the GNU Lesser General Public</span><br><span class="hljs-comment">   License along with the GNU C Library; if not, see</span><br><span class="hljs-comment">   &lt;http://www.gnu.org/licenses/&gt;.  */</span><br><br><span class="hljs-type">void</span> _dl_init(<span class="hljs-keyword">struct</span> link_map* main_map, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv, <span class="hljs-type">char</span>** env) &#123;<br>    <span class="hljs-comment">/* Stupid users forced the ELF specification to be changed.  It now</span><br><span class="hljs-comment">       says that the dynamic loader is responsible for determining the</span><br><span class="hljs-comment">       order in which the constructors have to run.  The constructors</span><br><span class="hljs-comment">       for all dependencies of an object must run before the constructor</span><br><span class="hljs-comment">       for the object itself.  Circular dependencies are left unspecified.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">       This is highly questionable since it puts the burden on the dynamic</span><br><span class="hljs-comment">       loader which has to find the dependencies at runtime instead of</span><br><span class="hljs-comment">       letting the user do it right.  Stupidity rules!  */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">unsigned</span> i = main_map-&gt;l_searchlist.r_nlist - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        call_init(main_map-&gt;l_initfini[i], argc, argv, env);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="证明">证明</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// lib.cpp</span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># Makefile</span><br>compile-need-sort :<br>    <span class="hljs-comment"># Depth: 2.</span><br>    gcc lib.cpp -shared -fPIC -o libg.so<br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -lg -o libf.so<br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -lf -o libe.so<br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -le -o libh.so<br>    <span class="hljs-comment"># Depth: 1.</span><br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -le -lf -o liba.so<br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -lg -lh -o libb.so<br>    gcc main.cpp                                                                     \<br>            -Wl,--dynamic-linker=<span class="hljs-variable">$(PWD)</span>/glibc/build/install/lib/ld-linux-x86-64.so.2 \<br>            -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -la -lb                                       \<br>            -o main<br>    LD_DEBUG=all ./main 2&gt;&amp;1 | grep <span class="hljs-string">&quot;calling init&quot;</span><br><br>compile-dont-need-sort :<br>    <span class="hljs-comment"># Depth: 2.</span><br>    gcc lib.cpp -shared -fPIC -o libg.so<br>    gcc lib.cpp -shared -fPIC -o libf.so<br>    gcc lib.cpp -shared -fPIC -o libe.so<br>    gcc lib.cpp -shared -fPIC -o libh.so<br>    <span class="hljs-comment"># Depth: 1.</span><br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -le -lf -o liba.so<br>    gcc lib.cpp -shared -fPIC -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -lg -lh -o libb.so<br>    gcc main.cpp                                                                     \<br>            -Wl,--dynamic-linker=<span class="hljs-variable">$(PWD)</span>/glibc/build/install/lib/ld-linux-x86-64.so.2 \<br>            -L<span class="hljs-variable">$(PWD)</span> -Wl,-rpath=<span class="hljs-variable">$(PWD)</span> -la -lb                                       \<br>            -o main<br>    LD_DEBUG=all ./main 2&gt;&amp;1 | grep <span class="hljs-string">&quot;calling init&quot;</span><br></code></pre></td></tr></table></figure><h2 id="normal-case">Normal Case</h2><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-init-order/makefile-compile-dont-need-sort.png" alt="" /><figcaption>makefile-compile-dont-need-sort</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># make compile-dont-need-sort</span><br>LD_DEBUG=all ./main 2&gt;&amp;1 | grep <span class="hljs-string">&quot;calling init&quot;</span><br>     12859:     calling init: /home/demons/_dl_map_objects_validate/glibc/build/install/lib/libc.so.6<br>     12859:     calling init: /home/demons/_dl_map_objects_validate/libh.so<br>     12859:     calling init: /home/demons/_dl_map_objects_validate/libg.so<br>     12859:     calling init: /home/demons/_dl_map_objects_validate/libf.so<br>     12859:     calling init: /home/demons/_dl_map_objects_validate/libe.so<br>     12859:     calling init: /home/demons/_dl_map_objects_validate/libb.so<br>     12859:     calling init: /home/demons/_dl_map_objects_validate/liba.so<br></code></pre></td></tr></table></figure><p>通过 <code>LD_DEBUG=all</code> 看到的初始化顺序与推断的顺序一致。</p><h2 id="special-case">Special Case</h2><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/dynamic-linking-init-order/makefile-compile-need-sort.png" alt="" /><figcaption>makefile-compile-need-sort</figcaption></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># make compile-need-sort</span><br>LD_DEBUG=all ./main 2&gt;&amp;1 | grep <span class="hljs-string">&quot;calling init&quot;</span><br>     12802:     calling init: /home/demons/_dl_map_objects_validate/glibc/build/install/lib/libc.so.6<br>     12802:     calling init: /home/demons/_dl_map_objects_validate/libg.so<br>     12802:     calling init: /home/demons/_dl_map_objects_validate/libf.so<br>     12802:     calling init: /home/demons/_dl_map_objects_validate/libe.so<br>     12802:     calling init: /home/demons/_dl_map_objects_validate/libh.so<br>     12802:     calling init: /home/demons/_dl_map_objects_validate/libb.so<br>     12802:     calling init: /home/demons/_dl_map_objects_validate/liba.so<br></code></pre></td></tr></table></figure><p>通过 <code>LD_DEBUG=all</code> 看到的初始化顺序与推断的顺序一致。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Dynamic Linking</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Build OpenJDK</title>
    <link href="/2020/10/24/computer-science/programming-language/java/build-openjdk/"/>
    <url>/2020/10/24/computer-science/programming-language/java/build-openjdk/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>C++ 代码通过 JNI 调用 Java 代码，通过分析 coredump 发现 Java 代码占用大量虚存。</p><p>从 coredump 提取 Java heap dump 需要 JDK 版本完全一致，运行时的 JRE 版本和 jmap 版本甚至不能相差一个小版本，因而需要从头编译特定的 OpenJDK 。</p><h1 id="编译-openjdk">编译 OpenJDK</h1><p>编译 OpenJDK 有两点需要注意：</p><ol type="1"><li>在 2020 年，<code>debian:jessie</code> 自带的 <code>hg</code> 无法正常下载 OpenJDK 源代码并切分支；<code>debian:buster</code> 自带的 OpenJDK 无法作为 bootstrap JDK 来编译 jdk8u 。</li><li>编译 OpenJDK 过程较慢，建议使用服务器（笔者使用的是 24 core 的抢占式实例）来编译；由于需要下载 OpenJDK 源代码，选用服务器时请考虑网络环境。</li></ol><h2 id="安装-docker">安装 Docker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -fsSL https://get.docker.com -o get-docker.sh<br>sudo sh get-docker.sh<br>sudo usermod -aG docker <span class="hljs-variable">$USER</span><br></code></pre></td></tr></table></figure><h2 id="下载特定版本的-openjdk">下载特定版本的 OpenJDK</h2><p><code>hg</code> 需要高于某个版本才能工作，这里选用 <code>debian:buster</code> 自带的 <code>hg</code> （特别提醒：<code>debian:jessie</code> 自带的 <code>hg</code> 是无法在 2020 年正常下载 OpenJDK 源代码并切分支的）。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># download_openjdk.dockerfile</span><br><span class="hljs-keyword">FROM</span> debian:buster<br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;837940593@qq.com&quot;</span></span><br><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y mercurial</span><br><br><span class="hljs-comment"># Download OpenJDK.</span><br><span class="hljs-comment"># https://hg.openjdk.java.net</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> hg <span class="hljs-built_in">clone</span> https://hg.openjdk.java.net/jdk8u/jdk8u jdk8u</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /jdk8u</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> bash get_source.sh</span><br><span class="hljs-comment"># Please find tags in https://hg.openjdk.java.net/jdk8u/jdk8u/tags.</span><br><span class="hljs-comment"># 25.65-b01 -&gt; jdk8u65-b01</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> hg up jdk8u65-b01 &amp;&amp; hg <span class="hljs-built_in">id</span></span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> find . -<span class="hljs-built_in">type</span> d -maxdepth 1 | xargs -n1 -Isubdir -- sh -c <span class="hljs-string">&quot;cd subdir &amp;&amp; hg up jdk8u65-b01 &amp;&amp; hg id&quot;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t download_openjdk:jdk8u65-b01 -f download_openjdk.dockerfile .<br>docker <span class="hljs-built_in">cp</span> $(docker create --<span class="hljs-built_in">rm</span> download_openjdk:jdk8u65-b01):/jdk8u .<br></code></pre></td></tr></table></figure><h2 id="编译-openjdk-1">编译 OpenJDK</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># build_openjdk.dockerfile</span><br><span class="hljs-keyword">FROM</span> debian:jessie<br><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;837940593@qq.com&quot;</span></span><br><br><span class="hljs-keyword">ARG</span> DEBIAN_FRONTEND=noninteractive<br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y cpio file build-essential make zip unzip</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y libX11-dev libxext-dev libxrender-dev libxtst-dev libxt-dev</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y libcups2-dev</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y libfreetype6-dev</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y libasound2-dev</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y libfontconfig1-dev</span><br><span class="hljs-comment"># Install boot jdk.</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get install -y openjdk-7-jdk</span><br><br><span class="hljs-keyword">ADD</span><span class="language-bash"> jdk8u /jdk8u</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /jdk8u</span><br><span class="hljs-comment"># https://stackoverflow.com/questions/52377684/compile-jdk8-error-could-not-find-freetype</span><br><span class="hljs-keyword">ENV</span> DISABLE_HOTSPOT_OS_VERSION_CHECK ok<br><span class="hljs-keyword">RUN</span><span class="language-bash"> bash configure --with-freetype-include=/usr/include/freetype2 --with-freetype-lib=/usr/lib/x86_64-linux-gnu</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> make JOBS=24 all</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> tar -czvf linux-x86_64-normal-server-release-jdk8u65-b01.tar.gz build</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t build_openjdk:jdk8u65-b01 -f build_openjdk.dockerfile .<br>docker <span class="hljs-built_in">cp</span> $(docker create --<span class="hljs-built_in">rm</span> build_openjdk:jdk8u65-b01):/jdk8u/linux-x86_64-normal-server-release-jdk8u65-b01.tar.gz .<br></code></pre></td></tr></table></figure><p><code>linux-x86_64-normal-server-release-jdk8u65-b01.tar.gz</code> 在笔者的机器上是 1.3G ，文件太大不利于拷贝；也可以执行 <code>tar -czvf linux-x86_64-normal-server-release-jdk8u65-b01-tiny.tar.gz build/linux-x86_64-normal-server-release/jdk</code> 打包出一个仅为 223 MB 的包。</p><h2 id="使用-jmap">使用 jmap</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// generate_jni_core.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;jni.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    JNIEnv* env = <span class="hljs-literal">nullptr</span>;<br>    JavaVM* jvm = <span class="hljs-literal">nullptr</span>;<br><br>    JavaVMOption options[<span class="hljs-number">1</span>];<br>    options[<span class="hljs-number">0</span>].optionString = <span class="hljs-string">&quot;-Djava.class.path=.&quot;</span>;<br>    JavaVMInitArgs vm_args;<br>    std::<span class="hljs-built_in">memset</span>(&amp;vm_args, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vm_args));<br>    vm_args.version = JNI_VERSION_1_2;<br>    vm_args.nOptions = <span class="hljs-number">1</span>;<br>    vm_args.options = options;<br><br>    <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">JNI_CreateJavaVM</span>(&amp;jvm, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;env), &amp;vm_args) !=<br>           JNI_ERR);<br>    <span class="hljs-built_in">assert</span>(env != <span class="hljs-literal">nullptr</span>);<br><br>    jclass cls = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;SayHello&quot;</span>);<br>    <span class="hljs-built_in">assert</span>(cls != <span class="hljs-number">0</span>);<br>    jmethodID mid = env-&gt;<span class="hljs-built_in">GetStaticMethodID</span>(cls, <span class="hljs-string">&quot;sayHello&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>    <span class="hljs-built_in">assert</span>(mid != <span class="hljs-number">0</span>);<br>    env-&gt;<span class="hljs-built_in">CallStaticVoidMethod</span>(cls, mid);<br>    std::<span class="hljs-built_in">abort</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SayHello.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SayHello</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>用以下命令编译 C++ 代码和 Java 代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> JAVA_HOME=/linux-x86_64-normal-server-release/jdk<br>g++ -std=c++11 -O0 -ggdb generate_jni_core.cpp                                     \<br>    -I/linux-x86_64-normal-server-release/jdk/include                         \<br>    -I/linux-x86_64-normal-server-release/jdk/include/linux                   \<br>    -L/linux-x86_64-normal-server-release/jdk/lib/amd64/server                \<br>    -Wl,-rpath=/linux-x86_64-normal-server-release/jdk/lib/amd64/server -ljvm \<br>    -o generate_jni_core<br>build/linux-x86_64-normal-server-release/jdk/bin/javac SayHello.java<br></code></pre></td></tr></table></figure><p>执行 generate_jni_core 以产生 coredump ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ulimit</span> -c unlimited<br>./generate_jni_core<br></code></pre></td></tr></table></figure><p>用 jmap 从 coredump 中提取 Java heap dump ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">build/linux-x86_64-normal-server-release/jdk/bin/jmap \<br>    -dump:format=b,file=dump.hprof generate_jni_core core<br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><ul><li><a href="https://docs.docker.com/engine/install/debian/">Install Docker Engine on Debian</a></li><li><a href="https://stackoverflow.com/questions/25292198/docker-how-can-i-copy-a-file-from-an-image-to-a-host">Stack Overflow: Docker - how can I copy a file from an image to a host?</a></li><li><a href="https://openjdk.java.net/">OpenJDK</a></li><li><a href="https://stackoverflow.com/questions/9981080/core-dump-taken-with-gcore-jmap-conversion-to-hprof-file-format-fails-with-erro">Stack Overflow: Core dump taken with gcore, jmap conversion to hprof file format fails with Error message</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>A Simple Example of ANTLR4 and C++</title>
    <link href="/2020/09/13/computer-science/programming-language/c++/a-simple-example-of-antlr4-and-c++/"/>
    <url>/2020/09/13/computer-science/programming-language/c++/a-simple-example-of-antlr4-and-c++/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="a-simple-example-of-antlr4-and-c">A Simple Example of ANTLR4 and C++</h1><p>本篇文章着重介绍 C++ 下如何使用 ANTLR4 ，不会深究 ANTLR4 的语法。</p><h2 id="定义语法文件">定义语法文件</h2><p>参考 <a href="https://github.com/antlr/grammars-v4/blob/master/sql/mysql/Positive-Technologies/MySqlLexer.g4">MySqlLexer.g4</a> 和 <a href="https://github.com/antlr/grammars-v4/blob/master/sql/mysql/Positive-Technologies/MySqlParser.g4">MySqlParser.g4</a> 定义一个非常简单的加减运算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs g4">// ArithmeticLexer.g4<br>lexer grammar ArithmeticLexer;<br><br>options &#123; language=Cpp; &#125;<br><br>PLUS:        &#x27;+&#x27;;<br>MINUS:       &#x27;-&#x27;;<br>DEC_DIGIT:   [0-9]+;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs g4">// ArithmeticParser.g4<br>parser grammar ArithmeticParser;<br><br>options &#123; tokenVocab=ArithmeticLexer; language=Cpp; &#125;<br><br>expression<br>    : left=DEC_DIGIT PLUS  right=DEC_DIGIT<br>    | left=DEC_DIGIT MINUS right=DEC_DIGIT<br>    ;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># java -jar antlr-4.8-complete.jar ArithmeticLexer.g4 -Werror -o generated</span><br><span class="hljs-comment"># java -jar antlr-4.8-complete.jar ArithmeticParser.g4 -Werror -o generated</span><br></code></pre></td></tr></table></figure><h2 id="编译-antlr-cpp-runtime">编译 ANTLR Cpp runtime</h2><p>ANTLR4 不提供 Linux 下的二进制文件，需要从 <a href="https://github.com/antlr/antlr4">ANTLR4 源代码</a> 自行编译。</p><p>编译依赖： <code>build-essential make cmake g++ git uuid-dev pkg-config</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> antlr/runtime/Cpp<br><span class="hljs-built_in">mkdir</span> build &amp;&amp; <span class="hljs-built_in">cd</span> build<br>cmake ..<br>make -j20 &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>编译头文件放于 <code>/usr/local/include/antlr4-runtime</code> ，链接库放于 <code>/usr/local/lib</code> 。</p><p>若不想安装，也可执行 <code>make package</code> 命令将头文件和链接库打包到 <code>LIBANTLR4-4.8-Linux.tar.gz</code> 文件。</p><h2 id="按-listener-模式访问语法树">按 Listener 模式访问语法树</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;ANTLRInputStream.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;CommonTokenStream.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;generated/ArithmeticLexer.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;generated/ArithmeticParser.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;generated/ArithmeticParserBaseListener.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;tree/ParseTreeWalker.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyListener</span> : <span class="hljs-keyword">public</span> ArithmeticParserBaseListener &#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exitExpression</span><span class="hljs-params">(ArithmeticParser::ExpressionContext* ctx)</span> </span>&#123;<br>        <span class="hljs-type">int</span> left = std::<span class="hljs-built_in">stoi</span>(ctx-&gt;left-&gt;<span class="hljs-built_in">getText</span>());<br>        <span class="hljs-type">int</span> right = std::<span class="hljs-built_in">stoi</span>(ctx-&gt;right-&gt;<span class="hljs-built_in">getText</span>());<br>        <span class="hljs-keyword">if</span> (ctx-&gt;<span class="hljs-built_in">PLUS</span>() != <span class="hljs-literal">nullptr</span>) &#123;<br>            std::cout &lt;&lt; left + right &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; left - right &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">antlr4::ANTLRInputStream <span class="hljs-title">inputStream</span><span class="hljs-params">(<span class="hljs-string">&quot;1+1&quot;</span>)</span></span>;<br>    <span class="hljs-function">ArithmeticLexer <span class="hljs-title">lexer</span><span class="hljs-params">(&amp;inputStream)</span></span>;<br>    <span class="hljs-function">antlr4::CommonTokenStream <span class="hljs-title">tokens</span><span class="hljs-params">(&amp;lexer)</span></span>;<br>    <span class="hljs-function">ArithmeticParser <span class="hljs-title">parser</span><span class="hljs-params">(&amp;tokens)</span></span>;<br>    MyListener listener;<br>    antlr4::tree::ParseTreeWalker::DEFAULT.<span class="hljs-built_in">walk</span>(&amp;listener, parser.<span class="hljs-built_in">expression</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -std=c++11 main.cpp                                           \<br>    $(find generated -<span class="hljs-built_in">type</span> f -name <span class="hljs-string">&quot;*.cpp&quot;</span>)                       \<br>    -I/usr/local/include/antlr4-runtime                           \<br>    -L/usr/local/lib/ -Wl,-rpath=/usr/local/lib/ -lantlr4-runtime \<br>    -o main<br></code></pre></td></tr></table></figure><h2 id="reference">Reference</h2><ul><li>https://github.com/antlr/antlr4/blob/master/doc/cpp-target.md</li></ul>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Perf Without Programming</title>
    <link href="/2020/06/19/computer-science/performance-analysis/perf-without-programming/"/>
    <url>/2020/06/19/computer-science/performance-analysis/perf-without-programming/</url>
    
    <content type="html"><![CDATA[<h1 id="无编程-perf">无编程 perf</h1><p>perf 是快速定位问题的利器，由于缺乏系统的理解，笔者在工作中未能用好 perf 。</p><p>这篇文章会由概述至细节地探讨 perf 、探讨 perf 与 kprobe / uprobe ... 之间的关系，介绍无编程情况下如何使用 perf 定位问题，若有错漏，敬请指出。</p><h2 id="brief-introduction">Brief Introduction</h2><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/perf-without-programming/perf-events-map-2.jpg" /></p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">Dynamic Tracing</th><th style="text-align: center;">Static Tracing</th><th style="text-align: center;">Counters</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">User space</td><td style="text-align: center;"><strong>uprobes</strong></td><td style="text-align: center;"><strong>User Staticlly-Defined Tracing</strong></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;">Kernel space</td><td style="text-align: center;"><strong>kprobes</strong></td><td style="text-align: center;"><strong>Kernel Tracepoint Events</strong></td><td style="text-align: center;">Software Events</td></tr><tr class="odd"><td style="text-align: center;">Hardware</td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;">CPU performance monitoring counters</td></tr><tr class="even"><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><strong>Timed Profiling</strong></td></tr></tbody></table><p>笔者对<a href="http://brendangregg.com/perf_events/perf_events_map.png">原图</a>稍作改动：用 Kernel Tracepoint Events 取代 Software Events ；这样做的理由是：Counters 在实际工作中较少应用，且 Software Events 和 Kernel Tracepoint Events 都在内核空间工作，容易搞混，所以在初识 perf 的过程中不妨先放下 Counters 。</p><p>表格中加粗部分是本篇文章着重探讨的 5 中 trace 方法。</p><p>另外，Timed Profiling 是一种非常特殊的 Counters ，它是从外部侵入的、基于采样的 Counters ，与 Software Events （内核自行计数）和 PMCs （硬件自行计数）都有所不同。</p><h2 id="timed-profiling">Timed Profiling</h2><p>Timed Profiling 应该是大多数人对 perf 的第一印象：检查程序慢在何处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ -std=c++11 -O0 main.cpp -o main</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m in f.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;I&#x27;m in g.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-built_in">g</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo perf record --call-graph dwarf -F 99 ./main<br>sudo <span class="hljs-built_in">chmod</span> 777 perf.data<br>perf script | ./FlameGraph/stackcollapse-perf.pl | ./FlameGraph/flamegraph.pl &gt; out.svg<br></code></pre></td></tr></table></figure><blockquote><p>The choice of 99 Hertz, instead of 100 Hertz, is to avoid accidentally sampling in lockstep with some periodic activity, which would produce skewed results. This is also coarse: you may want to increase that to higher rates (eg, up to 997 Hertz) for finer resolution, especially if you are sampling short bursts of activity and you'd still like enough resolution to be useful. Bear in mind that higher frequencies means higher overhead.</p></blockquote><p>采样频率尽量避免类似于 100 这样的整百数。</p><h2 id="kernel-tracepoint-events">Kernel Tracepoint Events</h2><p>Kernel Tracepoint Events 是内核事先埋好的点，结合 stack trace 能定位一些问题，如内存分配。</p><p>检查 Kernel Tracepoint Events 的命令：<code>sudo perf list | awk -F: '/Tracepoint event/ &#123; print $1 &#125;' | sort | uniq</code></p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/perf-without-programming/perf-events-map.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf list | awk -F: &#x27;/Tracepoint event/ &#123; print $1 &#125;&#x27; | sort | uniq | grep &quot;syscalls&quot;</span><br>raw_syscalls<br>syscalls<br></code></pre></td></tr></table></figure><blockquote><p>These are grouped into libraries of tracepoints; eg, "sock:" for socket events, "sched:" for CPU scheduler events. A key value of tracepoints is that they should have a stable API, so if you write tools that use them on one kernel version, they should work on later versions as well.</p></blockquote><p>syscalls 也是一组事件。</p><h3 id="example">Example</h3><p>假设我们有一个因 mmap 导致虚存快速增长的程序，如何将泄漏点查出来呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ -std=c++11 mmapButNotWritten.cpp -O3 -ggdb -o mmapButNotWritten</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">8</span> * <span class="hljs-number">1024</span>, PROT_NONE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    std::cout &lt;&lt; p &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf record --call-graph dwarf -e &quot;syscalls:sys_exit_mmap&quot; ./mmapButNotWritten</span><br>0x7f955b1b9000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo chmod 777 perf.data</span><br><span class="hljs-comment"># perf script</span><br><span class="hljs-comment"># perf script 的一部分输出</span><br>mmapButNotWritt 31964 [000] 885228.328547: syscalls:sys_exit_mmap: 0x7f955b1b9000<br>            7f955a935a13 mmap64 (inlined)<br>            559554b957df main (/home/demons/mmapButNotWritten)<br>            7f955a83bb96 __libc_start_main (/lib/x86_64-linux-gnu/libc-2.27.so)<br>            559554b95859 _start (/home/demons/mmapButNotWritten)<br></code></pre></td></tr></table></figure><p>perf 选项说明：</p><ul><li><p>--call-graph: fp / dwarf / lbr / no</p><p>fp 是 frame pointer 的缩写，使用 fp 要求编译时加上 -fno-omit-frame-pointer 选项</p><p>dwarf 使用 libunwind 处理缺少 frame pointer 的情况</p></li><li><p>-e: events</p></li><li><p>-p: pid</p></li></ul><h3 id="进阶">进阶</h3><p>如何获取 mmap 的参数和返回值？具体参见“ kprobes - Example 2 —— 打印参数”小节。</p><h2 id="kprobes">kprobes</h2><p>根据文章<a href="https://superuser.com/questions/287371/obtain-kernel-config-from-currently-running-linux-system">如何获取内核配置</a>，查看内核是否开启 kprobes 的命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo cat /boot/config-$(uname -r) | grep -i kprobe</span><br>CONFIG_KPROBES=y<br>CONFIG_KPROBES_ON_FTRACE=y<br>CONFIG_HAVE_KPROBES=y<br>CONFIG_HAVE_KPROBES_ON_FTRACE=y<br>CONFIG_KPROBE_EVENTS=y<br><span class="hljs-comment"># CONFIG_KPROBES_SANITY_TEST is not set</span><br></code></pre></td></tr></table></figure><h3 id="example-1-打印调用栈">Example 1 —— 打印调用栈</h3><p>借用“ Kernel Tracepoint Events - Example ”中的例子，应该如何用 kprobes 调查类似问题呢？</p><p>根据文章 <a href="https://stackoverflow.com/questions/9798008/connection-between-mmap-user-call-to-mmap-kernel-call">connection between mmap user call to mmap kernal call</a> ，mmap 最终会调用 mmap_region ，函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">mmap_region</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file* file,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">vm_flags_t</span> vm_flags,</span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff)</span></span>;<br></code></pre></td></tr></table></figure><p>通过 perf 添加 kprobes 的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe --add mmap_region</span><br>Added new event:<br>  probe:mmap_region    (on mmap_region)<br><span class="hljs-comment"># sudo perf list | grep mmap_region</span><br>probe:mmap_region                                  [Tracepoint event]<br></code></pre></td></tr></table></figure><p>添加的 kprobe 会在 <code>/sys/kernel/debug/</code> 中显示出来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo cat /sys/kernel/debug/tracing/kprobe_events</span><br>p:probe/mmap_region _text+2238544<br><span class="hljs-comment"># sudo cat /sys/kernel/debug/kprobes/list</span><br>0000000044a2daff  k  mmap_region+0x0    [DISABLED][FTRACE]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf record --call-graph dwarf -e probe:mmap_region ./mmapButNotWritten</span><br>0x7f1aedf48000<br><span class="hljs-comment"># sudo chmod 777 perf.data</span><br><span class="hljs-comment"># perf script</span><br>mmapButNotWritt  3547 [000] 951782.708116: probe:mmap_region: (ffffffffb5622850)<br>        ffffffffb5622851 [unknown] ([kernel.kallsyms])<br>        ffffffffb55feeac [unknown] ([kernel.kallsyms])<br>        ffffffffb56209fa [unknown] ([kernel.kallsyms])<br>        ffffffffb5433f6b [unknown] ([kernel.kallsyms])<br>        ffffffffb5403bb3 [unknown] ([kernel.kallsyms])<br>        ffffffffb5e00081 [unknown] ([kernel.kallsyms])<br>            7f1aed6c4a13 mmap64 (inlined)<br>            55f96b80b7df main (/home/demons/mmapButNotWritten)<br>            7f1aed5cab96 __libc_start_main (/lib/x86_64-linux-gnu/libc-2.27.so)<br>            55f96b80b859 _start (/home/demons/mmapButNotWritten)<br></code></pre></td></tr></table></figure><p>通过 perf 删除 kprobe ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe --del mmap_region</span><br>Removed event: probe:mmap_region<br></code></pre></td></tr></table></figure><h3 id="example-2-打印参数">Example 2 —— 打印参数</h3><p>笔者按照 <a href="http://brendangregg.com/perf.html#DynamicTracingEg">DynamicTracingEg</a> 的示例，要求 kprobe 打印 addr 参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe --add &#x27;mmap_region addr&#x27;</span><br>Failed to find the path <span class="hljs-keyword">for</span> kernel: Invalid ELF file<br>  Error: Failed to add events.<br></code></pre></td></tr></table></figure><p>由于找不到 debug 信息，无法确认 addr 参数在函数调用中的位置（貌似？），直接指定 addr 参数报错。</p><h4 id="指定参数名">指定参数名</h4><p>根据<a href="https://www.zhihu.com/people/radioactivezx">知乎用户：基本无害</a>的评论：</p><blockquote><p>这一段 perf 找不到 kprobe 函数名外的参数、返回值信息是因为缺少 vmlinux ，可以使用命令 <code>--vmlinux=&lt;vmlinux_path&gt;</code> 指定 vmlinux 。发行版一般也会提供官方 kernel 对应的文件，比如 Debian/Ubuntu 下 linux-image-5.8.0-3-amd 包会有一个对应的 linux-image-5.8.0-3-amd-dbg 包，安装之后 perf probe 可以自动找到。安装后 <code>perf probe -V printk</code> 能列出参数。</p></blockquote><p>依据 <a href="https://superuser.com/questions/62575/where-is-vmlinux-on-my-ubuntu-installation">Stack Exchange: Where is vmlinux on my Ubuntu installation?</a> 的指导安装 vmlinux ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo apt-get install linux-image-4.19-amd64 linux-image-4.19-amd64-dbg</span><br><span class="hljs-comment"># uname -r</span><br>4.19.0-0.bpo.17-amd64<br><span class="hljs-comment"># ls /usr/lib/debug/boot/vmlinux-4.19.0-0.bpo.17-amd64</span><br>/usr/lib/debug/boot/vmlinux-4.19.0-0.bpo.17-amd64<br></code></pre></td></tr></table></figure><p>4.9.0 版本的内核使用 kprobes 时会报错 <code>mmap_region is out of .text, skip it.</code> ，不建议使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe -V mmap_region</span><br>Available variables at mmap_region<br>        @&lt;mmap_region+0&gt;<br>                char*   __func__<br>                long unsigned int       addr<br>                long unsigned int       len<br>                long unsigned int       pgoff<br>                struct file*    file<br>                vm_flags_t      vm_flags<br><span class="hljs-comment"># sudo perf probe --add &#x27;mmap_region addr&#x27;</span><br>Added new event:<br>  probe:mmap_region    (on mmap_region with addr)<br>You can now use it <span class="hljs-keyword">in</span> all perf tools, such as:<br>       perf record -e probe:mmap_region -aR <span class="hljs-built_in">sleep</span> 1<br><span class="hljs-comment"># sudo perf record --call-graph dwarf -e probe:mmap_region ./mmapButNotWritten</span><br>0x7f8eb7a04000<br>[ perf record: Woken up 1 <span class="hljs-built_in">times</span> to write data ]<br>[ perf record: Captured and wrote 0.217 MB perf.data (25 samples) ]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo chmod 777 perf.data</span><br><span class="hljs-comment"># perf script</span><br>mmapButNotWritt  4032 [000]  2222.246366: probe:mmap_region: (ffffffffa5211e40) addr=0x555c53d86000<br>        ffffffffa5211e41 mmap_region+0x1<br>        ffffffffa52128bd do_mmap+0x46d<br>        ffffffffa51ef312 vm_mmap_pgoff+0xd2<br>        ffffffffa52cf1d8 elf_map+0x98<br>        ffffffffa52d1121 load_elf_binary+0x661<br>        ffffffffa5270f56 search_binary_handler+0xa6<br>        ffffffffa5272a38 __do_execve_file.isra.34+0x578<br>        ffffffffa5272e64 __x64_sys_execve+0x34<br>        ffffffffa5004105 do_syscall_64+0x55<br>        ffffffffa5800088 entry_SYSCALL_64_after_hwframe+0x44<br></code></pre></td></tr></table></figure><p>删除 kprobe ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe --del mmap_region</span><br>Removed event: probe:mmap_region<br></code></pre></td></tr></table></figure><h4 id="指定寄存器">指定寄存器</h4><p>我们可以根据 <a href="https://en.wikipedia.org/wiki/X86_calling_conventions">X86 calling conventions</a> 手动指定参数：</p><table><thead><tr class="header"><th style="text-align: center;">Architecture</th><th style="text-align: center;">Name</th><th style="text-align: center;">Operation system, compiler</th><th style="text-align: center;">Parameters (Registers)</th><th style="text-align: center;">Parameters (Stack order)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">x86-64</td><td style="text-align: center;">System V AMD64 ABI</td><td style="text-align: center;">Solaris, Linux, BSD, OS X (GCC, Intel C++ Compiler)</td><td style="text-align: center;">RDI, RSI, RDX, RCX, R8, R9, [XYZ]MM0–7</td><td style="text-align: center;">RTL (C)</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">mmap_region</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file* file,    <span class="hljs-comment">// RDI</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> addr,   <span class="hljs-comment">// RSI</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len,    <span class="hljs-comment">// RDX</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags,  <span class="hljs-comment">// RCX</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">vm_flags_t</span> vm_flags,  <span class="hljs-comment">// R8 vm_flags_t = unsigned long</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pgoff)</span></span>; <span class="hljs-comment">// R9</span><br></code></pre></td></tr></table></figure><p>在笔者机器上，perf 采用的寄存器名称都以 16-bit 寄存器名称为准，长度通过寄存器名称后的类型来指定。</p><p><a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture">X86 架构</a> 寄存器对应表：</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/perf-without-programming/registers.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo su</span><br><span class="hljs-comment"># echo &#x27;p:mmap_region mmap_region file=%di:u64 addr=%si:u64 len=%dx:u64 flags=%cx:u64 vm_flags=%r8:u64 pgoff=%r9:u64&#x27; &gt; /sys/kernel/debug/tracing/kprobe_events</span><br><span class="hljs-comment"># cat /sys/kernel/debug/tracing/kprobe_events</span><br>p:kprobes/mmap_region mmap_region file=%di:u64 addr=%si:u64 len=%dx:u64 flags=%cx:u64 vm_flags=%r8:u64 pgoff=%r9:u64<br><span class="hljs-comment"># exit</span><br><span class="hljs-comment"># sudo perf record --call-graph dwarf -e kprobes:mmap_region ./mmapButNotWritten</span><br>0x7f74dc178000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo chmod 777 perf.data</span><br><span class="hljs-comment"># perf script</span><br>mmapButNotWritt  3781 [000] 967984.290594: kprobes:mmap_region: (ffffffffb5622850) file=0 addr=140139885461504 len=8192 flags=112 vm_flags=34213839224 pgoff=18446662055947353720<br>    ffffffffb5622851 [unknown] ([kernel.kallsyms])<br>    ffffffffb55feeac [unknown] ([kernel.kallsyms])<br>    ffffffffb56209fa [unknown] ([kernel.kallsyms])<br>    ffffffffb5433f6b [unknown] ([kernel.kallsyms])<br>    ffffffffb5403bb3 [unknown] ([kernel.kallsyms])<br>    ffffffffb5e00081 [unknown] ([kernel.kallsyms])<br>        7f74db8f4a13 mmap64 (inlined)<br>        5593b07117df main (/home/demons/mmapButNotWritten)<br>        7f74db7fab96 __libc_start_main (/lib/x86_64-linux-gnu/libc-2.27.so)<br>        5593b0711859 _start (/home/demons/mmapButNotWritten)<br></code></pre></td></tr></table></figure><p>删除 kprobe ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo su</span><br><span class="hljs-comment"># echo &gt; /sys/kernel/debug/tracing/kprobe_events</span><br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><p>kprobes 可以分为两类：普通 kprobes 和 return kprobes 。普通 kprobes 以 p 开头， 在函数执行之前调用，因而可以获取到参数；return kprobes 以 r 开头，在函数执行之后调用，因而不能获取到参数。</p><h2 id="user-statically-defined-tracing">User Statically-Defined Tracing</h2><p>USDT 是用户代码事先埋好的点，以下实验需要先安装 systemtap-sdt-dev 。</p><p>Support was added in later 4.x series kernels.</p><h3 id="埋点">埋点</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/sdt.h&gt;</span></span><br><span class="hljs-comment">// g++ -std=c++11 -shared -fPIC -O3 -ggdb math.cpp -o libmath.so</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">funcInLib</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-built_in">DTRACE_PROBE2</span>(math, funcInLib, x, y);<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// dtrace -G -64 -s math.d libmath.so</span><br>provider math &#123;<br>    <span class="hljs-function">probe <span class="hljs-title">funcInLib</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf -n libmath.so</span><br>Displaying notes found <span class="hljs-keyword">in</span>: .note.gnu.build-id<br>  Owner                 Data size   Description<br>  GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)<br>    Build ID: e40dccf6baa20b96206670d5a52b770f5df98608<br><br>Displaying notes found <span class="hljs-keyword">in</span>: .note.stapsdt<br>  Owner                 Data size   Description<br>  stapsdt              0x00000037   NT_STAPSDT (SystemTap probe descriptors)<br>    Provider: math<br>    Name: funcInLib<br>    Location: 0x0000000000000580, Base: 0x0000000000000591, Semaphore: 0x0000000000000000<br>    Arguments: -4@%edi -4@%esi<br></code></pre></td></tr></table></figure><h3 id="监听">监听</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf buildid-cache --add libmath.so</span><br><span class="hljs-comment"># sudo perf list | grep sdt_math</span><br>sdt_math:funcInLib                                 [SDT event]<br><span class="hljs-comment"># sudo perf probe sdt_math:funcInLib</span><br>Added new event:<br>  sdt_math:funcInLib   (on %funcInLib <span class="hljs-keyword">in</span> /home/demons/uprobe/libmath.so)<br><span class="hljs-comment"># sudo perf list | grep sdt_math</span><br>sdt_math:funcInLib                                 [Tracepoint event]<br>sdt_math:funcInLib                                 [SDT event]<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf record --call-graph dwarf -e sdt_math:funcInLib ./main</span><br><span class="hljs-comment"># sudo chmod 777 perf.data</span><br><span class="hljs-comment"># perf script</span><br>main  4146 [000] 970663.914768: sdt_math:funcInLib: (7f7ef2391580) arg1=1 arg2=2<br>            7f7ef2391580 funcInLib (/home/demons/uprobe/libmath.so)<br>            55e4d885b632 main (/home/demons/uprobe/main)<br>            7f7ef1fc1b96 __libc_start_main (/lib/x86_64-linux-gnu/libc-2.27.so)<br>            55e4d885b669 _start (/home/demons/uprobe/main)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe --del sdt_math:funcInLib</span><br>Removed event: sdt_math:funcInLib<br><span class="hljs-comment"># sudo perf buildid-cache --remove libmath.so</span><br></code></pre></td></tr></table></figure><h2 id="uprobes">uprobes</h2><p>根据文章<a href="https://superuser.com/questions/287371/obtain-kernel-config-from-currently-running-linux-system">如何获取内核参数</a>，查看内核是否开启 uprobes 的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// sudo <span class="hljs-built_in">cat</span> /boot/config-$(<span class="hljs-built_in">uname</span> -r) | grep -i uprobe<br>CONFIG_ARCH_SUPPORTS_UPROBES=y<br>CONFIG_UPROBES=y<br>CONFIG_UPROBE_EVENTS=y<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ -std=c++11 -shared -fPIC -O3 -ggdb math.cpp -o libmath.so</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">funcInLib</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// g++ -std=c++11 -O3 -ggdb main.cpp -L$PWD -lmath -Wl,-rpath=$PWD -o main</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">funcInLib</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">funcInLib</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="example-1-通过-perf-插入-uprobes">Example 1 —— 通过 perf 插入 uprobes</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe -x libmath.so &#x27;--add=funcInLib x y&#x27;</span><br>Probe on address 0x580 to force probing at the <span class="hljs-keyword">function</span> entry.<br>Added new event:<br>  probe_libmath:funcInLib (on funcInLib <span class="hljs-keyword">in</span> /home/demons/uprobe/libmath.so with x y)<br></code></pre></td></tr></table></figure><p>Linux 3.13.1 kernel 可以使用以下命令创建 uprobes ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe -x libmath.so &#x27;--add=funcInLib x=%di:s32 y=%si:s32&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf record --call-graph dwarf -e probe_libmath:funcInLib ./main</span><br><span class="hljs-comment"># sudo chmod 777 perf.data</span><br><span class="hljs-comment"># perf script</span><br>main  3998 [000] 969778.093408: probe_libmath:funcInLib: (7f1ed04b2580) x=1 y=2<br>            7f1ed04b2580 funcInLib (/home/demons/uprobe/libmath.so)<br>            559fa97b6632 main (/home/demons/uprobe/main)<br>            7f1ed00e2b96 __libc_start_main (/lib/x86_64-linux-gnu/libc-2.27.so)<br>            559fa97b6669 _start (/home/demons/uprobe/main)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf probe -x libmath.so --del funcInLib</span><br>Removed event: probe_libmath:funcInLib<br></code></pre></td></tr></table></figure><h3 id="example-2-原始-uprobes">Example 2 —— 原始 uprobes</h3><p>本小节参考 <a href="https://www.kernel.org/doc/Documentation/trace/uprobetracer.txt">uprobe 文档</a></p><p>根据 <a href="https://stackoverflow.com/questions/40237321/find-functions-start-offset-in-elf">find functions start offset in elf</a> ，函数相对于 ELF 文件的偏移量为：</p><blockquote><p>function symbol offset = function symbol visual address - .text virtual address + .text offset</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># readelf -S libmath.so</span><br>Section Headers:<br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 9] .text             PROGBITS         00000000000004a0  000004a0<br>       00000000000000e5  0000000000000000  AX       0     0     16<br><span class="hljs-comment"># readelf -s libmath.so | grep funcInLib</span><br> 9: 0000000000000580     5 FUNC    GLOBAL DEFAULT    9 _Z9funcInLibii<br>54: 0000000000000580     5 FUNC    GLOBAL DEFAULT    9 _Z9funcInLibii<br></code></pre></td></tr></table></figure><p>funcInLib offset = 0x580 - 0x4a0 + 0x4a0 = 0x580</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo su</span><br><span class="hljs-comment"># echo &#x27;p:funcInLib /home/demons/uprobe/libmath.so:0x580 x=%di:s32 y=%si:s32&#x27; &gt; /sys/kernel/debug/tracing/uprobe_events</span><br><span class="hljs-comment"># cat /sys/kernel/debug/tracing/uprobe_events</span><br>p:uprobes/funcInLib /home/demons/uprobe/libmath.so:0x0000000000000580 x=%di:s32 y=%si:s32<br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo perf list | grep funcInLib</span><br>uprobes:funcInLib                                  [Tracepoint event]<br><span class="hljs-comment"># sudo perf record --call-graph dwarf -e uprobes:funcInLib ./main</span><br><span class="hljs-comment"># sudo chmod 777 perf.data</span><br><span class="hljs-comment"># perf script</span><br>main  3939 [000] 969570.321259: uprobes:funcInLib: (7ff377544580) x=1 y=2<br>            7ff377544580 funcInLib (/home/demons/uprobe/libmath.so)<br>            562707b8b632 main (/home/demons/uprobe/main)<br>            7ff377174b96 __libc_start_main (/lib/x86_64-linux-gnu/libc-2.27.so)<br>            562707b8b669 _start (/home/demons/uprobe/main)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># sudo su</span><br><span class="hljs-comment"># echo &gt; /sys/kernel/debug/tracing/uprobe_events</span><br><span class="hljs-comment"># exit</span><br></code></pre></td></tr></table></figure><h2 id="software-events">Software Events</h2><blockquote><p>Software events may have a default period. This means that when you use them for sampling, you're sampling a subset of events, not tracing every event. You can check with perf record -vv:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># perf record -vv -e context-switches /bin/true</span><br>perf_event_attr:<br>  &#123; sample_period, sample_freq &#125;   4000<br>  freq                             1<br></code></pre></td></tr></table></figure><blockquote><p>This default means is that the kernel adjusts the rate of sampling so that it's capturing about 4,000 context switch events per second. If you really meant to record them all, use -c 1:</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># perf record -vv -e context-switches -c 1 /bin/true</span><br>perf_event_attr:<br>  &#123; sample_period, sample_freq &#125;   1<br></code></pre></td></tr></table></figure><blockquote><p>Many other events (like tracepoints) have a default of 1 anyway. You'll encounter a non-1 default for many software and hardware events.</p></blockquote><h1 id="reference">Reference</h1><p><a href="http://brendangregg.com/perf.html">perf Examples</a></p><p><a href="https://superuser.com/questions/287371/obtain-kernel-config-from-currently-running-linux-system">obtain kernel config</a></p><p><a href="https://www.kernel.org/doc/Documentation/trace/kprobetrace.txt">kprobe documentation</a></p><p><a href="https://www.kernel.org/doc/Documentation/trace/uprobetracer.txt">uprobe documentation</a></p><p><a href="http://dtrace.org/guide/chp-usdt.html#:~:text=Statically%20Defined%20Tracing%20for%20User%20Applications,capabilities%20of%20the%20pid%20provider.">Statically Defined Tracing for User Applications</a></p><p><a href="https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture">X86 Architecture</a></p><p><a href="https://www.agner.org/optimize/calling_conventions.pdf">Calling Conventions</a></p><p><a href="https://www.zhihu.com/people/radioactivezx">知乎用户：基本无害</a>的评论</p><p><a href="https://superuser.com/questions/62575/where-is-vmlinux-on-my-ubuntu-installation">Stack Exchange: Where is vmlinux on my Ubuntu installation?</a></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Performance Analysis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Useful Vim Plugins</title>
    <link href="/2020/06/14/computer-science/tools/vim/useful-vim-plugins/"/>
    <url>/2020/06/14/computer-science/tools/vim/useful-vim-plugins/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的-vim-插件">常用的 VIM 插件</h1><h2 id="背景">背景</h2><p>VIM 有很多插件，但这些插件在笔者日常工作中都因为过于复杂而没有被充分利用；因而本篇文章着重介绍一些常用的插件及它们的精简命令。</p><h2 id="vim-easy-align">vim-easy-align</h2><p><a href="https://github.com/junegunn/vim-easy-align">junegunn/vim-easy-align</a> 用于快速对齐。</p><p>测试文本如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt"># Command: todo<br>a &amp; b &amp;1 c<br>a1 &amp;&amp; b1 &amp;&amp; c1<br></code></pre></td></tr></table></figure><h3 id="惯用法">惯用法</h3><p>用 Shift-V 或 Ctrl-V 进入 Visual 模式，选中待对齐的文本区域，敲击 <code>:EasyAlign</code> 执行对齐命令。</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-vim-plugin/start-easy-align.gif" /></p><p>EasyAlign 的用法：<code>EasyAlign [position]/regexp/[options]</code></p><p>regexp 采用与 VIM 相同的正则表达式语法</p><p>position 是可选项，默认值为 1 ，可选值有：1（第一个匹配正则表达式的分隔符）/ ... / -1（最后一个匹配正则表达式的分隔符）/ *（所有匹配正则表达式的分隔符）</p><p>常用的 options 如下：</p><table><thead><tr class="header"><th style="text-align: center;">名称</th><th style="text-align: center;">默认值</th><th style="text-align: center;">可选项</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><strong>d</strong>elimiter_align</td><td style="text-align: center;">r</td><td style="text-align: center;"><strong>l</strong>eft <strong>r</strong>ight <strong>c</strong>enter</td><td style="text-align: center;">决定分隔符的对齐方式</td></tr><tr class="even"><td style="text-align: center;"><strong>a</strong>lign</td><td style="text-align: center;">l</td><td style="text-align: center;"><strong>l</strong>eft <strong>r</strong>ight <strong>c</strong>enter</td><td style="text-align: center;">决定分隔符左侧文本的对齐方式（除 position 是 * 的情况外）</td></tr><tr class="odd"><td style="text-align: center;"><strong>i</strong>ndentation</td><td style="text-align: center;">k</td><td style="text-align: center;"><strong>k</strong>eep <strong>d</strong>eep <strong>s</strong>hallow <strong>n</strong>one</td><td style="text-align: center;">缩进模式</td></tr></tbody></table><p>options 有两种表达方式：</p><ol type="1"><li>类 JSON ：<code>&#123;'delimiter_align': 'r', 'align': 'r'&#125;</code></li><li>缩写：<code>[optionKey_1][optionValue_1][optionKey_2][optionValue_2]...</code></li></ol><p>由于类 JSON 表达式较长，笔者推荐缩写表达式，注意缩写表达式中不同的键值对之间不需要空格。</p><p>e.x. <code>EasyAlign */&amp;[0-9&amp;]\?/drar</code></p><h3 id="delimiter_align-示例">delimiter_align 示例</h3><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-vim-plugin/delimiter-align-default.gif" /></p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-vim-plugin/delimiter-align-left.gif" /></p><h3 id="align-示例">align 示例</h3><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-vim-plugin/align-default.gif" /></p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-vim-plugin/align-right.gif" /></p><h3 id="markdown-表格示例">Markdown 表格示例</h3><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-vim-plugin/table-align.gif" /></p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spark Useful Tips</title>
    <link href="/2020/05/03/computer-science/big-data/spark/spark-useful-tips/"/>
    <url>/2020/05/03/computer-science/big-data/spark/spark-useful-tips/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="常用的-spark-套路">常用的 Spark 套路</h1><h2 id="应用内重试">应用内重试</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">runQuery</span></span>() = spark.readStream.writeStream.start()<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">val</span> query = runQuery()<br>    query.awaitTermination()<br>  &#125; <span class="hljs-keyword">catch</span> &#123;<br>    <span class="hljs-keyword">case</span> e: <span class="hljs-type">Throwable</span> =&gt;<br>    <span class="hljs-keyword">if</span> (!meetConditionsForRetry()) &#123;<br>      logError(<span class="hljs-string">s&quot;Query exit: <span class="hljs-subst">$e</span>&quot;</span>)<br>      <span class="hljs-keyword">throw</span> e<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      logWarnning(<span class="hljs-string">s&quot;Query stop: <span class="hljs-subst">$e</span>&quot;</span>)<br>      <span class="hljs-comment">// Sleep.</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spark-重试">Spark 重试</h2><p>根据 <a href="https://spark.apache.org/docs/latest/running-on-yarn.html">Running Spark on YARN</a> 文档，设置重试需要两个参数：</p><p>spark.yarn.am.attemptFailuresValidityInterval: Defines the validity interval for AM failure tracking. If the AM has been running for at least the defined interval, the AM failure count will be reset. This feature is not enabled if not configured.</p><p>spark.yarn.maxAppAttempts: The maximum number of attempts that will be made to submit the application. It should be no larger than the global number of max attempts in the YARN configuration.</p><p>两个配置联手可以达到：Spark App 最多在 spark.yarn.am.attemptFailuresValidityInterval 时间内连续重启 spark.yarn.maxAppAttempts 次而不失败</p><h2 id="broadcast">Broadcast</h2><p>Spark 支持 join 静态表，但很多时候我们希望这张静态表每隔一段时间能更新一次，Boradcast 可以实现这个需求</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Logging</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-comment">// 1.</span><br>    <span class="hljs-meta">@transient</span> <span class="hljs-keyword">var</span> broadcastValue: <span class="hljs-type">Option</span>[<span class="hljs-type">String</span>] = <span class="hljs-type">None</span><br>    <span class="hljs-keyword">val</span> threadPool = <span class="hljs-keyword">new</span> <span class="hljs-type">ScheduledThreadPool</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">val</span> updateBroadcastValue = <span class="hljs-keyword">new</span> <span class="hljs-type">Runnable</span> &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// Update boardcastValue here.</span><br>      &#125;<br>    &#125;<br>    threadPool.scheduleAtFixedRate(updateBroadcastValue, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-type">TimeUnit</span>.<span class="hljs-type">MINUTES</span>)<br><br>    <span class="hljs-comment">// 2.</span><br>    <span class="hljs-keyword">var</span> broadcast = spark.sparkContext.broadcast(<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">val</span> broadcastListener = <span class="hljs-keyword">new</span> <span class="hljs-type">StreamingQueryListener</span> &#123;<br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onQueryStarted</span></span>(event: <span class="hljs-type">QueryStartedEvent</span>): <span class="hljs-type">Unit</span> = &#123;&#125;<br><br>      <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onQueryProgress</span></span>(event: <span class="hljs-type">QueryProgressEvent</span>): <span class="hljs-type">Unit</span> = &#123;<br>        broadcast = broadcastValue.flatMap(v =&gt; &#123;<br>          <span class="hljs-keyword">if</span> (!spark.sparkContext.isStopped) &#123;<br>            <span class="hljs-comment">// Unpersist broadcast blocking.</span><br>            broadcast.unpersist(<span class="hljs-literal">true</span>)<br>            broadcast = spark.sparkContext.broadcast(v)<br>            logInfo(<span class="hljs-string">s&quot;Update broadcast succeed: <span class="hljs-subst">$v</span>&quot;</span>)<br>          &#125;<br>        &#125;)<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 3.</span><br>    <span class="hljs-keyword">val</span> query = spark.readStream.mapPartitions(itPartition =&gt; &#123;<br>      <span class="hljs-keyword">val</span> value = broadcast.value<br>      <span class="hljs-comment">// Do other things.</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>broadcastValue 是定时更新的变量，将会通过 broadcast 从 Driver 发送到 Executor</li><li>broadcast 是将 broadcastValue 从 Driver 发送到 Executor 的变量，发起一次传输的条件是：即将开始一个 Spark Job 且 broadcastValue 尚未被更新过</li><li>mapPartitions 可以保证一个 partition 只读取一次 broadcast ，减少读取次数</li></ol><h2 id="合理设置分区数">合理设置分区数</h2><p>spark.sql.shuffle.partitions 的默认值是 200 ，且 Spark 在同一个 Executor 上的 Task 不会并发执行</p><p>一个 partition 会用一个 Task 去跑，假设只有一个 Executor ，那么你将会看到 200 个 Task 顺序执行</p><p>每个 Task 执行时都会访问 HDFS 去获取自己的状态（日志表现为 HDFSStateStore ），这些 IO 操作加起来的时间会很可观，大大拖慢处理速度</p><p>建议设置分区数的时候考虑两点：</p><ol type="1"><li>数据量大小</li><li>每个 Executor 尽量只有一个 Task （减少单个 Executor 访问 HDFS 的次数）</li></ol><p>重新设置分区数后，要删除原有的 checkpoint 才能生效（猜测是 Spark 不具备扩张或合并 State ）的能力</p><h2 id="重定向日志">重定向日志</h2><p>常规的使用 log4j.properties 的方法有两个缺点：</p><ol type="1"><li>不太好配置</li><li>如果重定向日志到服务器，accessId / accessKey 会被打包到 jar 中</li></ol><p>这里介绍如何用代码配置 log4j （Spark 也支持 log4j2 ）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">import</span> org.apache.log4j.<span class="hljs-type">AppenderSkeleton</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppender</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppenderSkeleton</span> </span>&#123;<br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activateOptions</span></span>(): <span class="hljs-type">Unit</span> = &#123;&#125;<br><br>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">append</span></span>(event: <span class="hljs-type">LoggingEvent</span>): <span class="hljs-type">Unit</span> = &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体实现可以参考<a href="https://github.com/aliyun/aliyun-log-log4j-appender/blob/master/src/main/java/com/aliyun/openservices/log/log4j/LoghubAppender.java">阿里云 LoghubAppender 的实现</a></p><p>accessId / accessKey 可以从 <code>SparkEnv.get.conf</code> 里面读出来，这样就可以避免 jar 中包含 accessId / accessKey</p><p>设置 Executor log4j properties 的代码如下，参考 <a href="https://kb.databricks.com/clusters/set-executor-log-level.html">Set executor log level</a> ：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scala">spark.sparkContext.parallelize(<span class="hljs-type">Seq</span>(<span class="hljs-string">&quot;&quot;</span>)).foreachPartition(_ =&gt; &#123;<br>  <span class="hljs-keyword">val</span> rootLogger = <span class="hljs-type">Logger</span>.getRootLogger<br>  <span class="hljs-keyword">val</span> myAppender = <span class="hljs-keyword">new</span> <span class="hljs-type">MyAppender</span>()<br>  myAppender.activateOptions()<br>  <span class="hljs-comment">// rootLogger.removeAllAppenders()</span><br>  rootLogger.addAppender(myAppender)<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Big Data</category>
      
      <category>Spark</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mmap Analyser V1</title>
    <link href="/2020/04/24/computer-science/memory-analysis/mmap-analyser-v1/"/>
    <url>/2020/04/24/computer-science/memory-analysis/mmap-analyser-v1/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="背景">背景</h1><p>程序链接 TCMalloc ，同时调用 mmap / munmap 管理一部分较大的内存；通过分析 TCMalloc 的统计信息，判断内存泄漏不是由 new / malloc 等常规接口导致的；因此怀疑是 mmap 导致的内存泄漏。</p><p>通过 Hook mmap / munmap 记录下每一次调用，可以分析出是哪里导致的内存泄漏。</p><h1 id="如何存储调用信息">如何存储调用信息？</h1><p>这涉及到三个问题的回答：</p><ol type="1"><li>buffer 是 thread local 还是 global ？</li><li>如何处理 buffer 满的情况？</li><li>什么时候将 buffer 写出？</li></ol><h2 id="thread-local-global">thread local / global</h2><p>thread local 的优势是不需要任何同步手段，劣势是时序关系无法保证。</p><p>内存的分配与释放未必是同一个线程，如果多线程之间 mmap / munmap 的时序关系没有记录下来，后期很难恢复，也很难知道是哪个线程导致的泄漏。</p><p>global buffer 的劣势是需要同步手段，同步手段可以选择比锁轻量的原子变量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1. 用原子变量抢写入空间</span><br><span class="hljs-type">uint64_t</span> index = mEndIndex.<span class="hljs-built_in">fetch_add</span>(<span class="hljs-number">2</span>, std::memory_order_relaxed);<br>mBuffer[index] = <span class="hljs-built_in">GenFirstValue</span>(Type::eMunmap, cycle, p);<br><span class="hljs-comment">// 2. 写入</span><br>mBuffer[index + <span class="hljs-number">1</span>] = <span class="hljs-built_in">GenSecondValue</span>(isSucceed, munmapSize);<br></code></pre></td></tr></table></figure><p>一旦将写入位置定下来，不同线程的写入并不会发生冲突。</p><p>注意 <code>fetch_add</code> 用最松的 memory order 来保证性能受到最低限度的影响。</p><h2 id="如何处理-buffer-满的情况">如何处理 buffer 满的情况？</h2><p>三种处理手段：不写入、扔掉前面的信息、等待 buffer 刷新。</p><p>等待 buffer 刷新不可避免地引入 PV 等同步手段（生产者、消费者模型），这会导致性能受到的影响不可控。</p><p>不写入和扔掉前面的信息本质上是同一种处理手段，在无法判断信息重要性的前提下，两者任意选一种皆可。</p><p>最终选择扔掉前面的信息，理由如下：</p><ol type="1"><li>扔掉前面的信息实现简单；</li><li>如果待调查的问题是内存暴涨，那么越新的信息越重要。</li></ol><p>如果发生信息覆盖，需要留下标记，方便分析（至少可以提示用户）。</p><p>引入长度为 2 bits 的 cycle 字段，cycle = the lowest 2 bits of (index / buffer size) 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">*cycle = (index / mBufferSize) &amp; <span class="hljs-number">0x3</span>;<br></code></pre></td></tr></table></figure><p>将 cycle 字段写出到 buffer ，当分析程序看到 cycle 变化较快的时候，就知道出现了信息丢弃的情况。</p><h2 id="什么时候将-buffer-写出">什么时候将 buffer 写出？</h2><ol type="1"><li>buffer 满的时候异步写出；</li><li>buffer 满的时候同步写出；</li><li>另起一个线程写出。</li></ol><p>以 buffer 满作为写出条件会导致一个问题：如何处理 buffer 未满的情况？如果一个程序 mmap / munmap 的次数较少，记录不足以写满 buffer ，那么 buffer 只能在进程结束的时候通过全局变量的析构函数一次性写出。但不是所有的程序都是 gracefully shutdown 的，特别是某些因为内存超限被 OOM Killer 杀掉的程序，这些程序的析构函数未必有机会得到调用。</p><p>异步写出有两个问题：</p><ol type="1"><li>与写入 buffer 有竞争关系，可能导致数据混乱；</li><li>为了 hook mmap / munmap ，我们的动态链接库加载时机非常早，此时 <code>libpthread.so</code> 还没有加载进来，因而不能直接调用 <code>std::thread</code> 和 <code>pthread_create</code> 函数。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mPThreadLib = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;libpthread.so&quot;</span>, RTLD_LAZY | RTLD_LOCAL);<br><span class="hljs-comment">// 启动线程</span><br><span class="hljs-keyword">using</span> FuncType = <span class="hljs-type">void</span>* (*)(<span class="hljs-type">void</span>*);<br><span class="hljs-keyword">using</span> PThreadCreateType =<br>    <span class="hljs-built_in">int</span> (*)(<span class="hljs-type">pthread_t</span>*, <span class="hljs-type">pthread_attr_t</span>*, FuncType, <span class="hljs-type">void</span>*);<br><span class="hljs-keyword">auto</span> pthreadCreate = <span class="hljs-built_in">reinterpret_cast</span>&lt;PThreadCreateType&gt;(<br>    <span class="hljs-built_in">dlsym</span>(mPThreadLib, <span class="hljs-string">&quot;pthread_create&quot;</span>));<br><span class="hljs-keyword">auto</span> pf = &amp;RingedBuffer::Dump;<br><span class="hljs-built_in">pthreadCreate</span>(<br>    &amp;mDumpThread, <span class="hljs-literal">nullptr</span>, *<span class="hljs-built_in">reinterpret_cast</span>&lt;FuncType*&gt;(&amp;pf), <span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 停止线程</span><br><span class="hljs-keyword">using</span> PThreadJoinType = <span class="hljs-built_in">int</span> (*)(<span class="hljs-type">pthread_t</span>, <span class="hljs-type">void</span>**);<br><span class="hljs-keyword">auto</span> pthreadJoin = <span class="hljs-built_in">reinterpret_cast</span>&lt;PThreadJoinType&gt;(<br>    <span class="hljs-built_in">dlsym</span>(mPThreadLib, <span class="hljs-string">&quot;pthread_join&quot;</span>));<br><span class="hljs-type">void</span>* ret = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-built_in">pthreadJoin</span>(mDumpThread, &amp;ret);<br></code></pre></td></tr></table></figure><h1 id="全局对象初始化顺序">全局对象初始化顺序</h1><p>我们有一个全局变量 <code>RingedBuffer sRingedBuffer</code> 负责记录调用信息，我们能否依赖构造函数将其成员变量初始化？</p><p>要注意：mmap / munmap 并不是只有 main 函数才会调用，TCMalloc / pthread 都会调用这两个函数。</p><p>即使我们的动态链接库先于这两个库加载，也没有办法保证 <code>sRingedBuffer</code> 的构造函数先于 TCMalloc / pthread 的全局变量调用。</p><p>因此，需要在每一次记录之前都调用一下 Init 函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">RecordMmap</span><span class="hljs-params">(<span class="hljs-type">void</span>* p, <span class="hljs-type">int</span> mmapSize, <span class="hljs-type">char</span>** funcNames, <span class="hljs-type">int</span> funcNamesSize)</span> </span>&#123;<br>    <span class="hljs-built_in">Init</span>();<br>    <span class="hljs-comment">// Do other thing.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>TCMalloc 中也采用了相同的做法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">do_memalign</span><span class="hljs-params">(<span class="hljs-type">size_t</span> align, <span class="hljs-type">size_t</span> size)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Static::<span class="hljs-built_in">pageheap</span>() == <span class="hljs-literal">NULL</span>) ThreadCache::<span class="hljs-built_in">InitModule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="如何获取调用栈">如何获取调用栈？</h1><ol type="1"><li>libunwind 提供的 backtrace 函数；</li><li>glibc 指代的 backtrace 函数；</li><li>获取 rsp / rbp 手动遍历；</li><li><code>__builtin_frame_address</code> 。</li></ol><p>第 3 种和第 4 种方法都会在开优化编译过的程序上面临 coredump 风险，因为栈底指针的压栈不再是必须的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">uint64_t</span>* rbp;<br><span class="hljs-built_in">asm</span>(<span class="hljs-string">&quot;mov %%rbp,%0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(rbp));<br><span class="hljs-keyword">auto</span> ra = *(rbp + <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>以上代码在遍历深度不为 1 的栈时会碰到 coredump 问题。</p><p>libunwind 能帮我们处理掉这些 tricky 的角落，用 libunwind 是不错的选择。</p><p>libunwind 的一些函数使用了不可重入锁，并且关了终端，所以不做特殊处理的话，会看到程序无法用 Ctrl-C 杀死，只能用 <code>kill -9</code> 结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">0</span>  <span class="hljs-number">0x00007f7e5119653d</span> in __lll_lock_wait ()<br><span class="hljs-number">1</span>  <span class="hljs-number">0x00007f7e51191e1b</span> in _L_lock_883 ()<br><span class="hljs-number">2</span>  <span class="hljs-number">0x00007f7e51191ce8</span> <span class="hljs-function">in <span class="hljs-title">pthread_mutex_lock</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">3  0x00007f7e513a8aca in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">4  0x00007f7e513a91f9 in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">5  0x00007f7e513ab206 in _<span class="hljs-title">ULx86_64_step</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">6  0x00007f7e513a6576 in <span class="hljs-title">backtrace</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">7  0x00007f7e5182fc9f in <span class="hljs-title">mmap</span> <span class="hljs-params">(addr=<span class="hljs-number">0x0</span>, length=<span class="hljs-number">4096</span>, prot=<span class="hljs-number">3</span>, flags=<span class="hljs-number">34</span>, fd=<span class="hljs-number">-1</span>, offset=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">8  0x00007f7e513a937d in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">9  0x00007f7e513a9c5b in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">10 0x00007f7e506d749c in <span class="hljs-title">dl_iterate_phdr</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">11 0x00007f7e513aa23e in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">12 0x00007f7e513a7c2d in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">13 0x00007f7e513a8d72 in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">14 0x00007f7e513a91f9 in ?? <span class="hljs-params">()</span></span><br><span class="hljs-function">15 0x00007f7e513ab206 in _<span class="hljs-title">ULx86_64_step</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">16 0x00007f7e513a6576 in <span class="hljs-title">backtrace</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">17 0x00007f7e5182fc9f in <span class="hljs-title">mmap</span> <span class="hljs-params">(addr=<span class="hljs-number">0x0</span>, length=<span class="hljs-number">4096</span>, prot=<span class="hljs-number">3</span>, flags=<span class="hljs-number">34</span>, fd=<span class="hljs-number">-1</span>, offset=<span class="hljs-number">0</span>)</span></span><br><span class="hljs-function">18 0x00000000004011dd in <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>可以看到：</p><ol type="1"><li>libunwind 将 glibc 提供的 backtrace 换成了自己的实现；</li><li><code>_ULx86_64_step</code> 会调用 mmap 函数。</li></ol><p>为了避免死锁，我们要用一个 thread local 变量记录 <a href="https://www.nongnu.org/libunwind/docs.html">libunwind 提供的函数</a>是否已经被调用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// Initializer::Init 负责用 dlopen 和 dlsym 加载 _ULx86_64_init_local 和 _ULx86_64_step</span><br><br><span class="hljs-type">int</span> _ULx86_64_init_local(<span class="hljs-type">unw_cursor_t</span>* cursor, <span class="hljs-type">unw_context_t</span>* context) &#123;<br>    <span class="hljs-comment">// Prevent sUnwInitLocal is nullptr if static vars of tcmalloc</span><br>    <span class="hljs-comment">// is initialized before mmap.</span><br>    Initializer::<span class="hljs-built_in">Init</span>();<br>    tBacktracing = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">auto</span> r = Initializer::<span class="hljs-built_in">sUnwInitLocal</span>(cursor, context);<br>    tBacktracing = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-type">int</span> _ULx86_64_step(<span class="hljs-type">unw_cursor_t</span>* cursor) &#123;<br>    <span class="hljs-comment">// Prevent sUnwStep is nullptr if static vars of tcmalloc</span><br>    <span class="hljs-comment">// is initialized before mmap.</span><br>    Initializer::<span class="hljs-built_in">Init</span>();<br>    tBacktracing = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">auto</span> r = Initializer::<span class="hljs-built_in">sUnwStep</span>(cursor);<br>    tBacktracing = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>仅仅 hook 这两个函数是不够的，因为 libunwind 提供的 backtrace 函数在编译时可以找到 <code>_ULx86_64_init_local</code> 和 <code>_ULx86_64_step</code> 函数，不会动态绑定这两个函数；所以需要 hook backtrace 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>** returnAddrs, <span class="hljs-type">int</span> skipCount, <span class="hljs-type">int</span> maxDepth)</span> </span>&#123;<br>    <span class="hljs-type">void</span>* ip = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-type">unw_cursor_t</span> cursor;<br>    <span class="hljs-type">unw_context_t</span> uc;<br>    <span class="hljs-built_in">unw_getcontext</span>(&amp;uc);<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">unw_init_local</span>(&amp;cursor, &amp;uc);<br>    <span class="hljs-built_in">assert</span>(ret &gt;= <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// Do not include current frame.</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; skipCount + <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unw_step</span>(&amp;cursor) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &lt; maxDepth) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unw_get_reg</span>(<br>                &amp;cursor, UNW_REG_IP, <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">unw_word_t</span>*&gt;(&amp;ip)) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        returnAddrs[n] = ip;<br>        n++;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">unw_step</span>(&amp;cursor) &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>backtrace</code> 函数的实现可以借鉴 TCMalloc 的 <code>GET_STACK_TRACE_OR_FRAMES</code> 函数。</p><h1 id="如何将返回地址解释成符号">如何将返回地址解释成符号？</h1><p>这里要做一个选择：原地解释还是事后解释？</p><ol type="1"><li>事后解释性能好；</li><li>如果不考虑 dlopen 和 dlclose ，每一次进程启动，ELF 文件加载到虚拟内存的位置是固定的；</li><li>如果程序反复调用 dlopen 和 dlclose ，部分 ELF 文件在虚拟内存中的位置是不可知的；</li><li>addr2line 2.27 有 bug ，解释结果可能和 gdb 不一致。</li></ol><p>所以这个版本用了原地解释的方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">void</span>* returnAddrs[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> n = <span class="hljs-built_in">backtrace</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">void</span>**&gt;(&amp;returnAddrs), <span class="hljs-number">1</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">char</span>** funcNames = <span class="hljs-built_in">backtrace_symbols</span>(returnAddrs, n);<br><span class="hljs-comment">// This array is malloced by backtrace_symbols(), and must be freed by the caller. (The strings pointed to by the array of pointers need not and should not be freed.)</span><br><span class="hljs-built_in">free</span>(funcNames);<br></code></pre></td></tr></table></figure><p>boost 用了一种更加折中的方案：开一个子进程来解释（这在理论上也会有 gap ）。</p><p>事后解释具有实现的可能性：<a href="http://man7.org/linux/man-pages/man7/rtld-audit.7.html">RTLD-AUDIT</a> 能够审计动态链接库的加载与卸载，这会放在下一篇文章讲。</p><h1 id="性能分析">性能分析</h1><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/mmap-analyser-v1/flamegraph.jpg" /></p><p><em>单线程下的火焰图（编译时未开优化）。</em></p><p>RecordMmap 在单线程下的表项并不算优异，主要是字符串拷贝等操作耗时。</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/mmap-analyser-v1/performance.jpg" /></p><p>每个线程分别调用 10000 次 mmap 和 munmap ，可以看到：</p><ol type="1"><li>hook 后 mmap / munmap 的耗时大概是 hook 前的 35 倍；</li><li>hook 后变慢程度并没有随着线程的增长而增长。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">g++ -std=c++11 mmap.cpp ringed_buffer.cpp -ltcmalloc -lunwind -lpthread -ldl -O3 -ggdb -shared -fPIC -o libmmap_analyser.so<br>g++ -std=c++11 test.cpp -lpthread -ltcmalloc -lunwind -O3 -ggdb -o <span class="hljs-built_in">test</span><br>time ./test<br>time <span class="hljs-built_in">env</span> LD_PRELOAD=<span class="hljs-string">&quot;libmmap_analyser.so&quot;</span> <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Memory Analysis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TCMalloc In TOMA</title>
    <link href="/2020/02/17/computer-science/memory-analysis/tcmalloc-in-toma/"/>
    <url>/2020/02/17/computer-science/memory-analysis/tcmalloc-in-toma/</url>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>TOMA = TCMalloc-based Object-oriented Memory Anaslyer</p><p>TOMA 是一个用于分析 C++ 程序内存占用的工具，这个工具利用 TCMalloc 提供的信息，将面向字节的内存分析转变成面向对象的分析工具，顺便提供了以下几种常用的工具：</p><ol type="1"><li>根据地址找出内存对象</li><li>提供对象的指向关系</li><li>识别常见对象（含虚表的对象、字符串、Lua 对象、Java 对象……）</li><li>识别运行中的线程及其堆栈</li><li>识别已销毁的堆栈</li></ol><p>TOMA 系列文章会介绍TOMA 工具开发过程中用到的关键技术：</p><ol type="1"><li>基于字节读取 coredump 文件</li><li>根据 TCMalloc 读取对象信息</li><li>快速扫描对象指针关系</li><li>NPTL 与识别运行中的线程及其堆栈</li><li>堆栈 call convention 与猜测已销毁的堆栈</li><li>虚表结构与识别含虚表的对象</li><li>识别 Lua 对象</li><li>识别 Java 对象</li></ol><h1 id="环境信息">环境信息</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">readelf -d libtcmalloc.so | grep SONAME<br>0x000000000000000e (SONAME) Library soname: [libtcmalloc.so.4]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname --m<br>x86_64<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/gperftools/gperftools/archive/gperftools-2.0.tar.gz<br>tar -xzvf gperftools-2.0.tar.gz<br>cd gperftools-gperftools-2.0<br>./configure --enable-minimal --prefix=$PWD/build<br>make -j60<br>make install<br></code></pre></td></tr></table></figure><p>以下源代码的版本是 gperftools-gperftools-2.0</p><p>截止笔者写这篇文章的时间（2019-11-01），tcmalloc 最新的版本是 gperftools-2.7</p><h1 id="tcmalloc-概述">TCMalloc 概述</h1><p>感谢 wallen 写的<a href="https://wallenwang.com/2018/11/tcmalloc/#ftoc-heading-62">TCMalloc 解密</a>，这是我认为在网上能找到的、关于 TCMalloc 写得最好的中文文章，本小节中的内容大多是对该文章的再次加工，图片更是全来源于这篇文章。</p><p>由于我们更关心如何找出正在使用中的对象，所以省略了 TCMalloc 分配与回收算法的介绍，并且也更加精简数据结构的介绍以突出重点。这一小节介绍的是逻辑概念，一些概念在 TCMalloc 的实现中是没有对应数据结构的。</p><p>一图胜千言，从图中我们可以得出使用中的对象的计算方法：</p><p>使用中的对象 = PageHeap 中的对象 - CentralCache 中的对象 - ThreadCache 中的对象</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/tcmalloc-in-TOMA/Overview.svg" /></p><h2 id="pageheap">PageHeap</h2><ol type="1"><li>Page 是 TCMalloc 对虚拟内存的抽象，可以近似地将 Page 理解成虚拟内存页</li><li>Span 由一页或多页连续的 Page 构成，是 PageHeap 管理内存页的基本单位</li><li>PageHeap 用于管理 Span</li></ol><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/tcmalloc-in-TOMA/PageHeap.svg" /></p><h3 id="pagemap">PageMap</h3><p>PageMap 协助 PageHeap 管理 Span ，回答这样一个问题：给定一个 Page ，如何确定它属于哪一个 Span ？</p><p>不妨将 PageMap 设想成一个长度为 page size 的数组，下标是 PageId ，值是指向 Span 的指针</p><p>在 TCMalloc 的实现中，PageMap 将采用二级或三级 radix tree （多级索引）以节省存储空间：</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/tcmalloc-in-TOMA/PageMap.svg" /></p><h2 id="centralcache">CentralCache</h2><ol type="1"><li>TCMalloc 根据对象的大小将小对象分类，一共有 85 类（不包括 0 字节大小的对象）</li><li>只有这 85 类对象会被 CentralCache 和 ThreadCache 缓存</li><li>CentralCache 是一个逻辑概念，实现上对应的是 CentralFreeList 类型的数组</li><li>CentralFreeList 真正管理的是 Span ，而小对象被包含在 Span 的空闲对象链表中，所以 CentralCache 实际上由每一个 Span 的空闲对象列表构成</li><li>CentralFreeList 的 <code>empty_</code> 链表保存了已经没有空闲对象可用的 Span，<code>nonempty_</code> 链表保存了还有空闲对象可用的 Span</li></ol><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/tcmalloc-in-TOMA/CentralCache.svg" /></p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/tcmalloc-in-TOMA/CentralFreeList.svg" /></p><h2 id="threadcache">ThreadCache</h2><p>ThreadCache 是独属于每一个线程的小对象缓存系统</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/tcmalloc-in-TOMA/ThreadCache.svg" /></p><h1 id="探索-tcmalloc-的细节">探索 TCMalloc 的细节</h1><p>本小节探索 TCMalloc 中对 TOMA 有影响的数据结构，数据结构均从 gperftools-gperftools-2.0 中整理得到</p><p>数据结构相比于原版去除了宏以方便理解，且通过验证（因为力求可以直接使用，所以未做省略，导致稍显详细）</p><p>以下会介绍几个关键的类：</p><ul><li>SizeMap 定义了小对象、Page 说明了 PageId 的构成、Span 是 TCMalloc 管理内存页的基本单位</li><li>PageHeap / CentralCahe / ThreadCache 是计算对象的重要数据结构</li></ul><h2 id="sizemap">SizeMap</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SizeMap</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>    ClassSize mTable[kNumClasses] = &#123;<br>        <span class="hljs-number">0</span>,      <span class="hljs-number">8</span>,      <span class="hljs-number">16</span>,     <span class="hljs-number">32</span>,     <span class="hljs-number">48</span>,     <span class="hljs-number">64</span>,     <span class="hljs-number">80</span>,     <span class="hljs-number">96</span>,     <span class="hljs-number">112</span>,<br>        <span class="hljs-number">128</span>,    <span class="hljs-number">144</span>,    <span class="hljs-number">160</span>,    <span class="hljs-number">176</span>,    <span class="hljs-number">192</span>,    <span class="hljs-number">208</span>,    <span class="hljs-number">224</span>,    <span class="hljs-number">240</span>,    <span class="hljs-number">256</span>,<br>        <span class="hljs-number">288</span>,    <span class="hljs-number">320</span>,    <span class="hljs-number">352</span>,    <span class="hljs-number">384</span>,    <span class="hljs-number">416</span>,    <span class="hljs-number">448</span>,    <span class="hljs-number">480</span>,    <span class="hljs-number">512</span>,    <span class="hljs-number">576</span>,<br>        <span class="hljs-number">640</span>,    <span class="hljs-number">704</span>,    <span class="hljs-number">768</span>,    <span class="hljs-number">896</span>,    <span class="hljs-number">1024</span>,   <span class="hljs-number">1152</span>,   <span class="hljs-number">1280</span>,   <span class="hljs-number">1408</span>,   <span class="hljs-number">1536</span>,<br>        <span class="hljs-number">1792</span>,   <span class="hljs-number">2048</span>,   <span class="hljs-number">2304</span>,   <span class="hljs-number">2560</span>,   <span class="hljs-number">2816</span>,   <span class="hljs-number">3072</span>,   <span class="hljs-number">3328</span>,   <span class="hljs-number">4096</span>,   <span class="hljs-number">4608</span>,<br>        <span class="hljs-number">5120</span>,   <span class="hljs-number">6144</span>,   <span class="hljs-number">6656</span>,   <span class="hljs-number">8192</span>,   <span class="hljs-number">9216</span>,   <span class="hljs-number">10240</span>,  <span class="hljs-number">12288</span>,  <span class="hljs-number">13312</span>,  <span class="hljs-number">16384</span>,<br>        <span class="hljs-number">20480</span>,  <span class="hljs-number">24576</span>,  <span class="hljs-number">26624</span>,  <span class="hljs-number">32768</span>,  <span class="hljs-number">40960</span>,  <span class="hljs-number">49152</span>,  <span class="hljs-number">57344</span>,  <span class="hljs-number">65536</span>,  <span class="hljs-number">73728</span>,<br>        <span class="hljs-number">81920</span>,  <span class="hljs-number">90112</span>,  <span class="hljs-number">98304</span>,  <span class="hljs-number">106496</span>, <span class="hljs-number">114688</span>, <span class="hljs-number">122880</span>, <span class="hljs-number">131072</span>, <span class="hljs-number">139264</span>, <span class="hljs-number">147456</span>,<br>        <span class="hljs-number">155648</span>, <span class="hljs-number">163840</span>, <span class="hljs-number">172032</span>, <span class="hljs-number">180224</span>, <span class="hljs-number">188416</span>, <span class="hljs-number">196608</span>, <span class="hljs-number">204800</span>, <span class="hljs-number">212992</span>, <span class="hljs-number">221184</span>,<br>        <span class="hljs-number">229376</span>, <span class="hljs-number">237568</span>, <span class="hljs-number">245760</span>, <span class="hljs-number">253952</span>, <span class="hljs-number">262144</span>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>SizaMap 提供了一张 Id 到 Size 的对应表，小对象在分配前都要先对齐到上一级大小</p><h2 id="page">Page</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 64 = 16 (unused) + 12 (levelA) + 12 (levelB) + 11 (levelC) + 13 (pageShift)</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kUnusedBits = <span class="hljs-number">16</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kPageIdBits = <span class="hljs-number">35</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kInteriorBits = <span class="hljs-number">12</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kLeafBits = <span class="hljs-number">11</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> kPageBits = <span class="hljs-number">13</span>;<br></code></pre></td></tr></table></figure><p>在 64 位机器中，高 16 位永远为 0 ，暂未被使用</p><p>TCMalloc 的 Page 大小默认是 8K = 2^13 ，低 13 位构成页内偏移</p><p>中间的 35 位构成 radix tree 的三级索引，分别是 12 / 12 / 11</p><p><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/tcmalloc-in-TOMA/page-and-span.jpeg" /></p><h2 id="span">Span</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Span</span> &#123;<br>    <span class="hljs-comment">// origin name: start</span><br>    <span class="hljs-type">uint64_t</span> mStartPageId;<br>    <span class="hljs-comment">// origin name: length</span><br>    <span class="hljs-type">uint64_t</span> mPageNum;<br>    Span* mNext;<br>    Span* mPrev;<br>    <span class="hljs-type">void</span>* mObjects;<br>    <span class="hljs-comment">// origin name: refcount</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mNonFreeObjectNum : <span class="hljs-number">16</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mClassId : <span class="hljs-number">8</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mLocation : <span class="hljs-number">2</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mSample : <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// possible values of mLocation</span><br>    <span class="hljs-keyword">enum</span> &#123; eInUse = <span class="hljs-number">0</span>, eNormal = <span class="hljs-number">1</span>, eReturned = <span class="hljs-number">2</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>mNext / mPrev 用于构建双向环形链表，链表头存放与 CentralFreeList 类型的数组中</li><li>mObjects 存储页内空闲对象列表</li><li>mNonFreeObjectNum 记录页内非空闲对象数</li><li>mLocation 记录页状态：使用中（拆分成小对象缓存或分配给应用程序）、缓存中、已归还给操作系统</li></ul><h2 id="pageheap-1">PageHeap</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PageHeap</span> &#123;<br>    PageMap3 mPagemap;<br>    PackedCache mPagemapCache;<br>    SpanList mLargeFree;<br>    SpanList mSmallFree[kSmallSpanMaxPage];<br>    <span class="hljs-type">uint8_t</span> mStats[<span class="hljs-number">24</span>];<br>    <span class="hljs-type">int64_t</span> mScavengeCounter;<br>    <span class="hljs-type">int</span> mReleaseIndex;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> kSmallSpanMaxPage = <span class="hljs-number">128</span>;<br></code></pre></td></tr></table></figure><ul><li>mPagemap 记录着 PageId 与 Span 的对应关系（这将是我们找出所有 Span 的重要字段）</li><li>mPagemapCache 是 mPagemap 的缓存（我们不使用这个字段）</li><li>mLargeFree / mSmallFree 缓存未使用的 Span （分配出去的 Span 不由 PageHeap 管理，Span 指针在 mPagemap 中有记录）</li></ul><h3 id="pagemap3">PageMap3</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PageMap3</span> &#123;<br>    LevelANode* mRoot;<br>    <span class="hljs-type">void</span>* (*mAlloc)(<span class="hljs-type">uint64_t</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LevelCNode</span> &#123;<br>    Span* mPtrs[kLeafLength];<br>    Span* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LevelBNode</span> &#123;<br>    LevelCNode* mPtrs[kInteriorLength];<br>    LevelCNode* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">LevelANode</span> &#123;<br>    LevelBNode* mPtrs[kInteriorLength];<br>    LevelBNode* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>PageMap3 的实现非常简单、直观，是一个 3 级 radix tree</p><h3 id="packedcache">PackedCache</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PackedCache</span> &#123;<br>    <span class="hljs-type">uint64_t</span> array_[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>];<br><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kKeyBits = <span class="hljs-number">35</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> kKeyMask = (<span class="hljs-number">1L</span> &lt;&lt; kKeyBits) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kValueBits = <span class="hljs-number">7</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> kValueMask = (<span class="hljs-number">1</span> &lt;&lt; kValueBits) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kHashBits = <span class="hljs-number">16</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">uint64_t</span> kHashMask = (<span class="hljs-number">1</span> &lt;&lt; kHashBits) - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// origin name: GetOrDefault</span><br>    <span class="hljs-comment">// default value = 0</span><br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> key)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>PackedCache 是 PageMap3 的缓存，实现很巧妙（篇幅关系，这里不展开）</p><h3 id="spanlist">SpanList</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpanList</span> &#123;<br>    Span mNormal;<br>    Span mReturned;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="centralcache-1">CentralCache</h2><p>TCMalloc 的实现中没有 CentralCache 这个类，我们为了方便 CentralCache 作为返回值类型使用，创建了这个类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// C++ can&#x27;t return array, so we can&#x27;t use array directly.</span><br><span class="hljs-comment">// using CentralCache = CentralFreeList[kNumClasses];</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CentralCache</span> &#123;<br>    CentralFreeList mCentralFreeLists[kNumClasses];<br>    CentralFreeList <span class="hljs-keyword">operator</span>[](<span class="hljs-type">int</span> i) <span class="hljs-type">const</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>CentralCache 就是由 CentralFreeList 构成的数组</p><h3 id="centralfreelist">CentralFreeList</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CentralFreeList</span> &#123;<br>    <span class="hljs-type">uint8_t</span> mSpinLock[<span class="hljs-number">4</span>];<br><br>    std::<span class="hljs-type">size_t</span> mClassId;<br>    Span mEmptySpan;<br>    Span mNonEmptySpan;<br>    <span class="hljs-comment">// Number of spans in mEmptySpan plus mNonEmptySpan</span><br>    std::<span class="hljs-type">size_t</span> mNumSpans;<br>    <span class="hljs-comment">// origin name: counter_</span><br>    <span class="hljs-comment">// not include free objects in tcSlots</span><br>    std::<span class="hljs-type">size_t</span> mInSpanFreeObjNum;<br><br>    TCEntry mTcSlots[kTcSlotSize];<br>    <span class="hljs-type">int32_t</span> mUsedSlots;<br>    <span class="hljs-type">int32_t</span> mCacheSize;<br>    <span class="hljs-type">int32_t</span> mMaxCacheSize;<br><br>    <span class="hljs-type">int8_t</span> mPad[<span class="hljs-number">48</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>mEmptySpan / mNonEmptySpan 分别存储所有对象未被使用的 Span 和有对象被使用的 Span</li><li>mUsedSlots 记录使用中 mTcSlots 的大小</li><li>mCacheSize 是 mUsedSlots 的上限</li><li>mMaxCacheSize 是 mCacheSize 的上限，它对于某一类对象而言是一个固定值</li></ul><h4 id="tcentry">TCEntry</h4><p>CentralFreeList 和 ThreadCache之间的对象移动有个优化措施，因为大部分情况都是每次移动 batch_size 个对象，为了减少链表操作，提升效率，CentralFreeList 将移动的 batch_size 个对象的链表的首尾指针缓存在了TCEntry 中。因此后续只要需要移动 batch_size 个对象，只需要操作链表的首尾即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TCEntry</span> &#123;<br>    <span class="hljs-type">void</span>* mHead;<br>    <span class="hljs-type">void</span>* mTail;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="threadcache-1">ThreadCache</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ThreadCache</span> &#123;<br>    ThreadCache* mNext;<br>    ThreadCache* mPrev;<br><br>    <span class="hljs-comment">// origin name: size</span><br>    std::<span class="hljs-type">size_t</span> mCacheSizeInByte;<br>    std::<span class="hljs-type">size_t</span> mMaxSize;<br>    <span class="hljs-type">uint8_t</span> mSampler[<span class="hljs-number">16</span>];<br>    FreeList mFreeList[kNumClasses];<br>    <span class="hljs-type">uint64_t</span> mTid;<br>    <span class="hljs-type">bool</span> mInSetSpecific;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>mMaxSize 是 mCacheSizeInByte 的上限？（这一条在实际使用 TOMA 时出现过反例）</li></ul><h1 id="标记-obejct">标记 Obejct</h1><h2 id="overview">Overview</h2><p>使用中的对象 = 所有 Span - PageHeap 缓存的 Span - Span 缓存的对象（即 CentralCache 中的对象） - ThreadCache 中的对象 - TCEntry 缓存的对象</p><p>我们需要设计两个类来存储所有对象的状态，方便标记及查找：</p><ul><li>SpanManager 存储 SpanWrapper</li><li>SpanWrapper 存储当前 Span 内的对象的状态</li></ul><h2 id="辅助类">辅助类</h2><p>为方便分析程序的编写，TOMA 新增了一些辅助类</p><h3 id="spanmanager">SpanManager</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// This class must be very fast.</span><br><span class="hljs-comment">// Don&#x27;t use any exception.</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpanManager</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> Leaf = std::array&lt;observer_ptr&lt;SpanWrapper&gt;, kLeafLength&gt;;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> rootLength = <span class="hljs-number">1</span> &lt;&lt; (kInteriorBits + kInteriorBits);<br>    <span class="hljs-keyword">using</span> Root = std::array&lt;std::unique_ptr&lt;Leaf&gt;, rootLength&gt;;<br><br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpanManager</span>(<span class="hljs-type">const</span> CoredumpReader&amp; coreReader,<br>                Address pageHeapAddr,<br>                Address centralCacheAddr,<br>                Address threadCacheAddr);<br>    <span class="hljs-built_in">SpanManager</span>(<span class="hljs-type">const</span> SpanManager&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">SpanManager</span>(SpanManager&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>    SpanManager&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SpanManager&amp; other) = <span class="hljs-keyword">delete</span>;<br>    SpanManager&amp; <span class="hljs-keyword">operator</span>=(SpanManager&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">SpanWrapper::iterator <span class="hljs-title">FindObj</span><span class="hljs-params">(Address addr)</span></span>;<br>    <span class="hljs-function">SpanWrapper::const_iterator <span class="hljs-title">FindObj</span><span class="hljs-params">(Address addr)</span> <span class="hljs-type">const</span></span>;<br><br>    std::set&lt;std::unique_ptr&lt;SpanWrapper&gt;&gt;&amp; <span class="hljs-keyword">operator</span>[](ClassId classId);<br><br> <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QueryGlobalSpan</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MarkFreeSpan</span><span class="hljs-params">(observer_ptr&lt;SpanWrapper&gt; sw)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MarkSpanCacheObjs</span><span class="hljs-params">(observer_ptr&lt;SpanWrapper&gt; sw)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QueryThreadFreeList</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QueryTcSlotObjs</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">observer_ptr&lt;SpanWrapper&gt; <span class="hljs-title">FindSpanWrapperByPageId</span><span class="hljs-params">(Address pageId)</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> SpanWrapper sEmptySpanWrapper;<br><br> <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> CoredumpReader&amp; mCoreReader;<br><br>    Address mPageHeapAddr;<br>    Address mCentralCacheAddr;<br>    Address mThreadCacheAddr;<br><br>    PageHeap mPageHeap;<br>    CentralCache mCentralCache;<br><br>    <span class="hljs-comment">// It is used to search spans.</span><br>    Root mRoot;<br>    <span class="hljs-comment">// It is used to iterate spans.</span><br>    std::array&lt;std::set&lt;std::unique_ptr&lt;SpanWrapper&gt;&gt;, kNumClasses&gt; mSpans;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>mSpans</code> 拥有 SpanWrapper 的所有权，并提供按照对象大小遍历 SpanWrapper 的能力</li><li><code>mRoot</code> 是一棵 radix tree ，持有 SpanWrapper 的 observer ptr ，提供按照 PageId 搜索 SpanWrapper 的能力</li><li><code>QueryGlobalSpan</code> / <code>MarkFreeSpan</code> / <code>MarkSpanCacheObjs</code> / <code>QueryThreadFreeList</code> / <code>QueryTcSlotObjs</code> 是寻找并标记 Object 的重要函数</li></ul><p>总结：SpanManager 是 SpanWrapper 的拥有者和管理者，还是 Object 计算器</p><h3 id="spanwrapper">SpanWrapper</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpanWrapper</span> : <span class="hljs-keyword">public</span> Span &#123;<br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iter</span>;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span>;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iter</span><br>        : <span class="hljs-keyword">public</span> std::iterator&lt;std::forward_iterator_tag,  <span class="hljs-comment">// iterator_category</span><br>                               Object&lt;T&gt;,                  <span class="hljs-comment">// value_type</span><br>                               std::<span class="hljs-type">size_t</span>,                <span class="hljs-comment">// difference_type</span><br>                               Object&lt;T&gt;*,                 <span class="hljs-comment">// pointer</span><br>                               Object&lt;T&gt;&gt;;                 <span class="hljs-comment">// reference</span><br><br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> iterator = Iter&lt;SpanWrapper&gt;;<br>    <span class="hljs-keyword">using</span> const_iterator = Iter&lt;<span class="hljs-type">const</span> SpanWrapper&gt;;<br><br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SpanWrapper</span><span class="hljs-params">(<span class="hljs-type">const</span> Span&amp; span)</span></span>;<br>    <span class="hljs-built_in">SpanWrapper</span>(<span class="hljs-type">const</span> SpanWrapper&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">SpanWrapper</span>(SpanWrapper&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>    SpanWrapper&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SpanWrapper&amp; other) = <span class="hljs-keyword">delete</span>;<br>    SpanWrapper&amp; <span class="hljs-keyword">operator</span>=(SpanWrapper&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> SpanWrapper&amp; other) <span class="hljs-type">const</span>;<br><br>    <span class="hljs-function">iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">iterator <span class="hljs-title">end</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">iterator <span class="hljs-title">find</span><span class="hljs-params">(Address addr)</span></span>;<br><br>    <span class="hljs-function">const_iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">const_iterator <span class="hljs-title">end</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">const_iterator <span class="hljs-title">find</span><span class="hljs-params">(Address addr)</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">Size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFreeSpan</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsBigObj</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">GetFreeObjectNum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">GetAllObjectNum</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">Count</span><span class="hljs-params">(Tag tag)</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">GetIndex</span><span class="hljs-params">(Address addr)</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">public</span>:<br>    ClassSize mClassSize;<br>    Address mStartAddr;<br>    Address mEndAddr;<br><br>    std::vector&lt;Tag&gt; mObjTags;<br>&#125;;<br></code></pre></td></tr></table></figure><p>关于 SpanWrapper ：</p><ul><li>从概念上说，SpanWrapper 是装着 Object 的容器</li><li>从实现上说，SpanWrapper 仅仅记录 Object 的状态（<code>mObjTags</code> 数组），因为 Object 的起始地址可以从 <code>mObjTags</code> 的下标和 <code>mClassSize</code> 推断出来，Object 的大小就是 <code>mClassSize</code></li><li><code>GetIndex</code> 可以根据地址计算出 Object 相对于 Span 的偏移量（即地址属于 Span 的第几个对象）</li></ul><p>关于 Object ：</p><ul><li>从概念上说，Object 应当记录对象的起始地址、大小和状态</li><li>从实现上说，Object 只需要记录指向所属 SpanWrapper 的指针和 <code>mObjTags</code> 的下标，就可以计算出上述三个属性</li></ul><p>总结：SpanWrapper 是 Object 的拥有者和管理者</p><h2 id="寻找-span">寻找 Span</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpanManager::QueryGlobalSpan</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint64_t</span> pageId = <span class="hljs-number">0</span>; pageId &lt; kPageIdLength;) &#123;<br>        <span class="hljs-type">uint64_t</span> nextPageId = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">auto</span> p = <span class="hljs-built_in">FindSpanByPageId</span>(mCoreReader, mPageHeap, pageId, &amp;nextPageId);<br>        <span class="hljs-keyword">if</span> (p != <span class="hljs-literal">nullptr</span>) &#123;<br>            Span span = mCoreReader.<span class="hljs-built_in">Defer</span>&lt;Span&gt;(p);<br>            <span class="hljs-comment">// Insert span to mSpans.</span><br>            <span class="hljs-comment">// sw is observer ptr of span wrapper in mSpans.</span><br>            <span class="hljs-keyword">if</span> (sw-&gt;<span class="hljs-built_in">IsFreeSpan</span>()) &#123;<br>                <span class="hljs-built_in">MarkFreeSpan</span>(sw);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">MarkSpanCacheObjs</span>(sw);<br>            &#125;<br>            <span class="hljs-comment">// Insert observer ptr of span wrapper to mRoot.</span><br>            pageId += sw-&gt;mPageNum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pageId = nextPageId;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>QueryGlobalSpan 利用 PageMap3 来找出所有的 Span</p><p>注意：不要从 0 到 kPageIdLength 逐个遍历 PageId ，这样做非常慢</p><p>正确的做法是根据 radix tree 的特性，直接跳到下一个存在的 PageId</p><h2 id="标记-pageheap-缓存的-span">标记 PageHeap 缓存的 Span</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpanManager::MarkFreeSpan</span><span class="hljs-params">(observer_ptr&lt;SpanWrapper&gt; sw)</span> </span>&#123;<br>    <span class="hljs-built_in">Assert</span>(sw-&gt;mNonFreeObjectNum == <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (sw-&gt;mLocation == Span::eNormal) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = sw-&gt;<span class="hljs-built_in">begin</span>(); it != sw-&gt;<span class="hljs-built_in">end</span>(); it++) &#123;<br>            it-&gt;<span class="hljs-built_in">GetTag</span>() = Tag::sNormalFreeSpan;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = sw-&gt;<span class="hljs-built_in">begin</span>(); it != sw-&gt;<span class="hljs-built_in">end</span>(); it++) &#123;<br>            it-&gt;<span class="hljs-built_in">GetTag</span>() = Tag::sReturnedFreeSpan;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被 PageHeap 缓存的 Span 可以通过 <code>mLocation</code> 字段识别出来</p><p>所谓标记，就是把 <code>mObjTags</code> 数组里的每一个元素都置为对应的状态</p><h2 id="标记-centralcache-缓存的对象">标记 CentralCache 缓存的对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpanManager::MarkSpanCacheObjs</span><span class="hljs-params">(observer_ptr&lt;SpanWrapper&gt; sw)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (Address freeObj = <span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(sw-&gt;mObjects);<br>         freeObj != <span class="hljs-number">0</span>;<br>         freeObj = mCoreReader.<span class="hljs-built_in">Defer</span>&lt;Address&gt;(freeObj)) &#123;<br>        <span class="hljs-keyword">auto</span> it = sw-&gt;<span class="hljs-built_in">find</span>(freeObj);<br>        it-&gt;<span class="hljs-built_in">GetTag</span>() = Tag::sSpanCache;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> freeObjectNum = sw-&gt;<span class="hljs-built_in">Count</span>(Tag::sSpanCache);<br>    <span class="hljs-built_in">Assert</span>(freeObjectNum == sw-&gt;<span class="hljs-built_in">GetFreeObjectNum</span>());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标记-tcentry-缓存的对象">标记 TCEntry 缓存的对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpanManager::QueryTcSlotObjs</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> classId : <span class="hljs-built_in">range</span>(kNumClasses)) &#123;<br>        <span class="hljs-type">const</span> CentralFreeList&amp; centralFreeList = mCentralCache[classId];<br>        <span class="hljs-built_in">Assert</span>(centralFreeList.mClassId == classId);<br>        <span class="hljs-comment">// search tc slots</span><br>        <span class="hljs-keyword">auto</span> usedSlot = centralFreeList.mUsedSlots;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> slotIndex : <span class="hljs-built_in">range</span>(usedSlot)) &#123;<br>            <span class="hljs-type">const</span> TCEntry&amp; entry = centralFreeList.mTcSlots[slotIndex];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> freeObj = entry.mHead; freeObj != entry.mTail;<br>                 freeObj = mCoreReader.<span class="hljs-built_in">Defer</span>&lt;<span class="hljs-type">void</span>*&gt;(freeObj)) &#123;<br>                <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">FindObj</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(freeObj));<br>                <span class="hljs-built_in">Assert</span>(it);<br>                it-&gt;<span class="hljs-built_in">GetTag</span>() = Tag::sTcSlot;<br>            &#125;<br>            <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">FindObj</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(entry.mTail));<br>            <span class="hljs-built_in">Assert</span>(it);<br>            it-&gt;<span class="hljs-built_in">GetTag</span>() = Tag::sTcSlot;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标记-threadcache-缓存的对象">标记 ThreadCache 缓存的对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpanManager::QueryThreadFreeList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">TraverseDoubleLinkedList</span>&lt;ThreadCache, ThreadCacheIter, <span class="hljs-type">bool</span>, <span class="hljs-literal">false</span>&gt;(<br>        mCoreReader,<br>        mThreadCacheAddr,<br>        [<span class="hljs-keyword">this</span>](<span class="hljs-type">const</span> ThreadCache&amp; threadCache, <span class="hljs-type">bool</span> isHead) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; freeList = threadCache.mFreeList;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> classId : <span class="hljs-built_in">range</span>(kNumClasses)) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> freeObj = freeList[classId].mObject;<br>                     freeObj != <span class="hljs-literal">nullptr</span>;<br>                     freeObj = mCoreReader.<span class="hljs-built_in">Defer</span>&lt;<span class="hljs-type">void</span>*&gt;(freeObj)) &#123;<br>                    <span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">FindObj</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;Address&gt;(freeObj));<br>                    <span class="hljs-built_in">Assert</span>(it);<br>                    it-&gt;<span class="hljs-built_in">GetTag</span>() = Tag::sThreadCache;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="reference">reference</h1><ol type="1"><li><a href="https://wallenwang.com/2018/11/tcmalloc/">TCMalooc 解密</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Memory Analysis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>String Literal In Cpp11</title>
    <link href="/2020/02/16/computer-science/programming-language/c++/string-literal-in-cpp11/"/>
    <url>/2020/02/16/computer-science/programming-language/c++/string-literal-in-cpp11/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="在-c-中优雅地写多行字符串">在 C++ 中优雅地写多行字符串</h1><h2 id="背景">背景</h2><p>在 UT 中常常碰到以下需求：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">TEST_F</span>(TestSuite, deserialize) &#123;<br>  <span class="hljs-keyword">auto</span> jsonStr = <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;James\&quot;,\&quot;nickname\&quot;:\&quot;goodboy\&quot;&#125;&quot;</span>;<br>  <span class="hljs-keyword">auto</span> object = <span class="hljs-built_in">deserialze</span>(jsonStr);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>jsonStr</code> 不直观，我们想要 json 原本的样子</p><h2 id="string-literal">String Literal</h2><p>C++11 提供了 <code>R"delimiter(raw string)delimiter"</code> 的语法，其中 <code>delimiter</code> 可以自行定义</p><p>有了 String Literal ，以上代码可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-string">R&quot;delimiter(</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;: &quot;James&quot;,</span><br><span class="hljs-string">  &quot;nickname&quot;: &quot;good boy&quot;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">)delimiter&quot;</span><br></code></pre></td></tr></table></figure><p>但我们往往需要同时兼顾代码的对齐以及字符串的格式（比如将字符串打印出来），比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> s = <span class="hljs-string">R&quot;delimiter(</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">          &quot;name&quot;: &quot;James&quot;,</span><br><span class="hljs-string">          &quot;nickname&quot;: &quot;good boy&quot;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        )delimiter&quot;</span>;<br>    std::cout &lt;&lt; s &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;James&quot;</span>,<br>  <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;good boy&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>空行和行首的空格是为了对齐代码而引入的，我们并不希望它们也打印出来，符合期望的输出是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;James&quot;</span>,<br>  <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;good boy&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="trim">Trim</h2><p>为减少性能消耗，Trim 需要在编译期完成</p><p>有两种方法做到这一点：</p><ol type="1"><li>模板：将字符串作为模板参数传入</li><li>constexpr</li></ol><p>模板被证明是行不通的，将在函数内声明的字符串字面量作为模板参数传给模板类会报错：<code>non-type template argument refers to object that does not have linkage</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StringLiteral</span> &#123;<br> <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> mArray[N];<br><br> <span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> S&gt;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">StringLiteral</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;s)[S],</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> omitFirstEmptyLine,</span></span><br><span class="hljs-params"><span class="hljs-function">                            <span class="hljs-type">bool</span> omitLastEmptyLine)</span> </span>&#123;<br>        <span class="hljs-built_in">static_assert</span>(S &gt;= <span class="hljs-number">1</span>, <span class="hljs-string">&quot;&quot;</span>);<br><br>        <span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// Omit the first empty line.</span><br>        <span class="hljs-keyword">if</span> (omitFirstEmptyLine &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            begin = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// Omit the last empty line.</span><br>        <span class="hljs-comment">// N-2 N-1 N</span><br>        <span class="hljs-comment">// \n  \0</span><br>        <span class="hljs-type">int</span> end = N;<br>        <span class="hljs-keyword">if</span> (omitLastEmptyLine &amp;&amp; s[N - <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            end = N - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> minSpaceNum = N;<br>        <span class="hljs-type">bool</span> newLine = <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">int</span> spaceNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin; i &lt; end; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;\n&#x27;</span> || i == end - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (minSpaceNum &gt; spaceNum) &#123;<br>                    minSpaceNum = spaceNum;<br>                &#125;<br>                newLine = <span class="hljs-literal">true</span>;<br>                spaceNum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span> &amp;&amp; newLine) &#123;<br>                spaceNum++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            newLine = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;<br>        spaceNum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = begin; i &lt; end - <span class="hljs-number">1</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>                spaceNum = <span class="hljs-number">0</span>;<br>                mArray[k] = s[i];<br>                k++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (spaceNum &lt; minSpaceNum) &#123;<br>                spaceNum++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            mArray[k] = s[i];<br>            k++;<br>        &#125;<br>        mArray[k] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><br>        <span class="hljs-comment">// Omit the last empty line.</span><br>        <span class="hljs-keyword">if</span> (omitLastEmptyLine &amp;&amp; mArray[k - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            mArray[k - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">c_str</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mArray;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">int</span> N&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">literal</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> (&amp;lit)[N])</span> -&gt; StringLiteral&lt;N&gt; </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">StringLiteral</span>&lt;N&gt;(lit, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="编译">编译</h2><p>由于使用了 constexpr 特性，需要在 c++14 标准下编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">clang++ -std=c++14 -O0 -ggdb test.cpp -o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h2 id="测试">测试</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> a = <span class="hljs-built_in">literal</span>(<span class="hljs-string">R&quot;delimiter(</span><br><span class="hljs-string">        test</span><br><span class="hljs-string">        test</span><br><span class="hljs-string">        )delimiter&quot;</span>);<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> b = <span class="hljs-built_in">literal</span>(<span class="hljs-string">R&quot;delimiter(</span><br><span class="hljs-string">test</span><br><span class="hljs-string">test</span><br><span class="hljs-string">)delimiter&quot;</span>);<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> c = <span class="hljs-built_in">literal</span>(<span class="hljs-string">R&quot;delimiter(</span><br><span class="hljs-string">        test</span><br><span class="hljs-string">test</span><br><span class="hljs-string">)delimiter&quot;</span>);<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> d = <span class="hljs-built_in">literal</span>(<span class="hljs-string">R&quot;delimiter(</span><br><span class="hljs-string">                test</span><br><span class="hljs-string">        test</span><br><span class="hljs-string">        )delimiter&quot;</span>);<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> s = d.<span class="hljs-built_in">c_str</span>();<br>    std::cout &lt;&lt; a.<span class="hljs-built_in">c_str</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; b.<span class="hljs-built_in">c_str</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; c.<span class="hljs-built_in">c_str</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; s &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">literal</span>(<span class="hljs-string">R&quot;delimiter(</span><br><span class="hljs-string">        &#123;</span><br><span class="hljs-string">          &quot;name&quot;: &quot;James&quot;,</span><br><span class="hljs-string">          &quot;nickname&quot;: &quot;good boy&quot;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        )delimiter&quot;</span>);<br>    std::cout &lt;&lt; s.<span class="hljs-built_in">c_str</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;James&quot;</span>,<br>  <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;good boy&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="reference">Reference</h1><ol type="1"><li><a href="https://en.cppreference.com/w/cpp/language/string_literal">string literal</a></li><li><a href="https://akrzemi1.wordpress.com/2017/06/28/compile-time-string-concatenation/">Compile-time string concatenation</a></li><li><a href="https://stackoverflow.com/questions/1826464/c-style-strings-as-template-arguments">C-Style Strings as template arguments?</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Useful And Easy New Features Of Cpp11</title>
    <link href="/2019/07/16/computer-science/programming-language/c++/useful-and-easy-new-features-of-cpp11/"/>
    <url>/2019/07/16/computer-science/programming-language/c++/useful-and-easy-new-features-of-cpp11/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="简单易用的-c11-新特性">简单易用的 C++11 新特性</h1><p>重构代码时提炼几点有用的 C++11 新特性，能够帮助大家写出更加优雅的 C++ 代码。</p><h2 id="强制类型转换">强制类型转换</h2><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">const_cast</td><td style="text-align: center;">-</td></tr><tr class="even"><td style="text-align: center;">static_cast</td><td style="text-align: center;">隐式转换</td></tr><tr class="odd"><td style="text-align: center;">dynamic_cast</td><td style="text-align: center;">安全的下行转换</td></tr><tr class="even"><td style="text-align: center;">reinterpret_cast</td><td style="text-align: center;">不安全、无条件的编译期转换</td></tr></tbody></table><h2 id="右值语义">右值语义</h2><blockquote><p><a href="https://www.zhihu.com/question/22111546/answer/30801982">如何移动一头大象？</a>在第二个冰箱中启动量子复制系统，克隆一只完全相同的大象，然后启动高能激光将第一个冰箱内的大象气化消失。</p></blockquote><h3 id="value-categories">Value categories</h3><blockquote><p>Each C++ expression is characterized by two independent properties: a <em>type</em> and a <em>value category</em>.</p></blockquote><p>参考<a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues">Stroustrup 叙述 C++11 值类型取名历程</a>，整理出判断值类型的表：</p><ul><li>Has identity<ul><li>It's possible to determine whether the expression refers to the same entity as another expression, such as by comparing addressses of the objects or the functions they identity (obtained directly or indirectly).</li></ul></li><li>Can be moved from<ul><li>Move constructor, move assignments operator, or another function overload that implements move semantics can bind to the expression.</li><li>The resource will not be used in another place or be discarded by explicitly.</li></ul></li></ul><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">has identity</th><th style="text-align: center;">hasn't identity</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">can be moved from</td><td style="text-align: center;">xvalue</td><td style="text-align: center;">prvalue</td></tr><tr class="even"><td style="text-align: center;">can't be moved from</td><td style="text-align: center;">lvalue</td><td style="text-align: center;">-</td></tr></tbody></table><p>glvaue (generalized lvalue) = xvalue + lvalue</p><p>rvalue = xvalue + prvalue</p><p>根据 <a href="https://en.cppreference.com/w/cpp/language/value_category">cppreference</a> 的描述，整理出值类型的属性：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">lvalue</th><th style="text-align: center;">xvalue</th><th style="text-align: center;">prvalue</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">取地址</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td></tr><tr class="even"><td style="text-align: center;">出现在 built-in assignment 的左侧</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td></tr><tr class="odd"><td style="text-align: center;">polymorphic 静态类型与实际类型不一致</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td></tr><tr class="even"><td style="text-align: center;">initialize a lvalue reference</td><td style="text-align: center;">Y</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td></tr><tr class="odd"><td style="text-align: center;">initialize an rvalue reference</td><td style="text-align: center;">N</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td></tr><tr class="even"><td style="text-align: center;">initialize a const lvalue reference</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td><td style="text-align: center;">Y</td></tr><tr class="odd"><td style="text-align: center;">绑定引用会延长生命周期</td><td style="text-align: center;">N</td><td style="text-align: center;">N</td><td style="text-align: center;">Y</td></tr></tbody></table><h4 id="compiler-is-a-liar">Compiler is a liar</h4><h5 id="prvalue-不支持多态">prvalue 不支持多态？</h5><p><a href="https://stackoverflow.com/questions/15482508/what-is-an-example-of-a-difference-in-allowed-usage-or-behavior-between-an-xvalu">SO</a> 对 <strong>prvalue 不支持多态</strong> 有一个看似合理的解释：</p><blockquote><p>Correspondingly, because a prvalue's static type is guaranteed to be its dynamic type, extending its lifetime is meaningful and can be done by the compiler. On the other hand, for the xvalue, the object is at some unknown, arbitrary location, so the compiler couldn't easily extend its lifetime, especially given that the type could be polymorphic.</p></blockquote><p>延长 prvalue 需要确保编译器看到的类型（静态类型）是对象的真实类型（动态类型），否则编译器不知道该如何回收栈空间</p><figure><img src="https://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-and-easy-new-features-of-Cpp11/polymorphic-of-prvalue-reference.jpg" alt="" /><figcaption>polymorphic-of-prvalue-reference</figcaption></figure><p>prvalue reference 延长 prvalue 生命周期在 clang7 的实现方式：</p><ol type="1"><li>临时变量转正：栈顶指针在函数调用后移动到返回值之上（更低的地址）</li><li>使用多态指针指向转正后的临时变量</li></ol><p>至少在 clang 7 的实现方式下，prvalue 是可以使用多态的</p><p>严格意义上说，编译器应该在编译期拒绝 polymorphic prvalue reference ，以符合标准</p><p>标准没有规定引用必须实现成指针，因而上图斜上方的实现方法在 prvalue 的场景下也是可行的，但这种实现方法就必须拒绝 polymorphic prvalue reference ，否则运行期会出现非预期的行为</p><h5 id="rvalue-不能出现在赋值表达式的左侧">rvalue 不能出现在赋值表达式的左侧？</h5><p>xvalue 是具名变量，出现在赋值表达式左侧是可以理解的，那么 prvalue 呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">clang version 8.0.1-svn363027-1~exp1~20190611210016.75 (branches/release_80)<br>Target: x86_64-pc-linux-gnu<br>Thread model: posix<br>InstalledDir: /usr/bin<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// clang++-8 -std=c++11 -emit-llvm -S prvalue.cpp</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123; <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;&#125; &#125;;<br><span class="hljs-function">Test <span class="hljs-title">Make</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Test</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Make</span>() = <span class="hljs-built_in">Test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ll">define dso_local i32 @main() #2 &#123;<br>  %1 = alloca %struct.Test, align 8<br>  %2 = alloca %struct.Test, align 8<br>  %3 = bitcast %struct.Test* %1 to i8*<br>  call void @llvm.memset.p0i8.i64(i8* align 8 %3, i8 0, i64 8, i1 false)<br>  call void @_ZN4TestC2Ev(%struct.Test* %1) #3<br>  call void @_Z4Makev(%struct.Test* sret %2)<br>  %4 = call %struct.Test* @_ZN4TestaSEOS_(%struct.Test* %2, %struct.Test* %1) #3<br>  ret i32 0<br>&#125;<br></code></pre></td></tr></table></figure><p>笔者稍稍修改 <code>main</code> 函数，去除掉对理解没有帮助的修饰符 <code>dereferenceable</code></p><figure><img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/useful-and-easy-new-features-of-Cpp11/prvalue-left-operand.png" alt="" /><figcaption>prvalue-left-operand</figcaption></figure><p>Clang8 并没有立即消除本应该失去生命周期的变量，因而 prvalue 可以被赋值</p><p>再看以下一段更加直观的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">include &lt;iostream&gt;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp;) = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Test</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;~Test()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;operator=&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function">Test <span class="hljs-title">Make</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Test</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">Make</span>() = <span class="hljs-built_in">Test</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">operator=<br>~Test()<br>~Test()<br></code></pre></td></tr></table></figure><p>在为 prvalue 赋值的场景下，Clang 8 延长了临时变量的生命周期至函数结束</p><p>但对于基础类型（如 <code>int</code> ），其右值仍然不可出现在辅助表达式左侧（这是编译器的一个谎言）</p><p>如果自行实现一个严格控制变量声明周期的编译器，<code>prvalue</code> 则不能出现在赋值表达式左侧</p><h4 id="some-specific-rules">Some specific rules</h4><h5 id="rvalue-reference-is-a-lvalue">rvalue reference is a lvalue</h5><blockquote><p>Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories.</p></blockquote><p>划重点：non-reference type, value category</p><p>不妨定义一个二元组 [non reference type, value category] 来描述表达式分类，取名为 full type</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t1;<br>    Test&amp;&amp; r = std::<span class="hljs-built_in">move</span>(t1);<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(r)</span></span>; <span class="hljs-comment">// copy constructor</span><br><br>    <span class="hljs-function">Test <span class="hljs-title">t3</span><span class="hljs-params">(std::move(t1))</span></span>; <span class="hljs-comment">// move constructor</span><br>    <span class="hljs-function">Test <span class="hljs-title">t4</span><span class="hljs-params">(std::move(r))</span></span>; <span class="hljs-comment">// move constructor</span><br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码来自 <a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues/9552880#9552880">SO</a> ：如何解释 <code>Test t2(r)</code> 调用拷贝构造函数而不是移动构造函数？一种合理的解释如下：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">type</th><th style="text-align: center;">value category</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">std::move(t1)</td><td style="text-align: center;">Test</td><td style="text-align: center;">rvalue</td></tr><tr class="even"><td style="text-align: center;">r</td><td style="text-align: center;">rvalue reference of Test</td><td style="text-align: center;">lvalue</td></tr></tbody></table><p>full type 必须是 non reference type ，rvalue reference of Test 不满足定义，不妨直接删掉 reference 部分</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">type</th><th style="text-align: center;">value category</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">std::move(t1)</td><td style="text-align: center;">Test</td><td style="text-align: center;">rvalue</td></tr><tr class="even"><td style="text-align: center;">r</td><td style="text-align: center;"><del>rvalue reference of</del> Test</td><td style="text-align: center;">rvalue</td></tr></tbody></table><p>所以编译器选择拷贝构造函数而不是移动构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t1;<br>    Test&amp;&amp; r1 = std::<span class="hljs-built_in">move</span>(t1);<br>    Test&amp;&amp; r2 = std::<span class="hljs-built_in">move</span>(r1);<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(r2)</span></span>; <span class="hljs-comment">// copy constructor</span><br>&#125;<br></code></pre></td></tr></table></figure><p>类似地，编译器在决策 <code>t2(r2)</code> 调用哪一个构造函数的时候，也有一个类似的过程：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">type</th><th style="text-align: center;">value category</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">std::move(t1)</td><td style="text-align: center;">Test</td><td style="text-align: center;">rvalue</td></tr><tr class="even"><td style="text-align: center;">r1</td><td style="text-align: center;"><del>rvalue reference of</del> Test</td><td style="text-align: center;">lvalue</td></tr><tr class="odd"><td style="text-align: center;">std::move(r1)</td><td style="text-align: center;">Test</td><td style="text-align: center;">rvalue</td></tr><tr class="even"><td style="text-align: center;">r2</td><td style="text-align: center;"><del>rvalue reference of</del> Test</td><td style="text-align: center;">rvalue</td></tr></tbody></table><h6 id="why-rvalue-reference-cant-be-a-rvalue">Why rvalue reference can't be a rvalue?</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">UpperCaseInPlace</span><span class="hljs-params">(string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">transform</span>(str.<span class="hljs-built_in">begin</span>(), str.<span class="hljs-built_in">end</span>(), str.<span class="hljs-built_in">begin</span>(), ::toupper);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(string&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;call lvalue version&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">upperCaseStr</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-built_in">UpperCaseInPlace</span>(upperCaseStr);<br>    <span class="hljs-keyword">return</span> upperCaseStr == str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(string&amp;&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;call rvalue version&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">upperCaseStr</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-built_in">UpperCaseInPlace</span>(upperCaseStr);<br>    <span class="hljs-keyword">return</span> upperCaseStr == str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str = <span class="hljs-string">&quot;a long string&quot;</span>;<br>    <span class="hljs-built_in">compare</span>(str);<br>    <span class="hljs-built_in">compare</span>(<span class="hljs-string">&quot;a long string&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码能够取得较优的性能：对于为右值的 string ，省去一次拷贝构造（省去一次 memcpy ）</p><p>聚焦于 compare 函数的 rvalue 版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(string&amp;&amp; str)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;call rvalue version&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-function">string <span class="hljs-title">upperCaseStr</span><span class="hljs-params">(str)</span></span>;<br>    <span class="hljs-built_in">UpperCaseInPlace</span>(upperCaseStr);<br>    <span class="hljs-keyword">return</span> upperCaseStr == str;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设推翻 C++11 的设计，右值引用也是右值，compare 函数的 rvalue 版本实现起来比较困难：期望通过拷贝一个右值引用得到一个全新的字符串 <code>upperCaseStr</code></p><p>所以 C++11 现在的设计：<strong>右值引用不是右值</strong>具备一定的合理性</p><h5 id="value-category-of-function-return-value-isnt-value-category-of-function-call">value category of function return value isn't value category of function call</h5><table><thead><tr class="header"><th style="text-align: center;">value category of function return value</th><th style="text-align: center;">value catrgory of function call</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">lvalue reference</td><td style="text-align: center;">lvalue</td></tr><tr class="even"><td style="text-align: center;">rvalue reference to function</td><td style="text-align: center;">lvalue</td></tr><tr class="odd"><td style="text-align: center;">rvalue reference to object</td><td style="text-align: center;">xvalue</td></tr><tr class="even"><td style="text-align: center;">non-reference</td><td style="text-align: center;">rvalue</td></tr></tbody></table><h4 id="why-we-need-xvalue">Why we need xvalue ?</h4><p><a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues/9552880#9552880">SO</a> 的回答认为 xvalue 和 prvalue 的最大差别是 xvalue 可以出现在赋值表达式左侧而 prvalue 不可以，然而笔者认为这个说法是错的：</p><ol type="1"><li><a href="https://en.cppreference.com/w/cpp/language/value_category">cppreference</a> 明确提到：An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators. xvalue 和 prvalue 按照标准都不允许出现在赋值表达式的左侧</li><li>在 <strong>Compiler is a liar</strong> 一节讨论过 Clang 对非基础类型的 rvalue 出现在赋值表达式左侧的处理方式，非基础类型的 xvalue 和 prvalue 都可以出现在赋值表达式的左侧</li></ol><p>需要 xvalue 的原因是它既有名字又可以移动，既不是 lvalue 又不是 prvalue</p><h4 id="xvalue-如何产生">xvalue 如何产生？</h4><ol type="1"><li>a function call whose return type is rvalue reference to object, such as <code>std::move(x)</code></li><li><code>a[n]</code>, the built-in <a href="https://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_subscript_operator">subscript</a> expression, where one operand is an array rvalue</li><li><code>a.m</code>, the <a href="https://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators">member of object</a> expression, where <code>a</code> is an rvalue and <code>m</code> is a non-static data member of non-reference type</li></ol><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">has identity</th><th style="text-align: center;">can be move from</th><th style="text-align: center;">value category</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">看上去 function call 没有 identity <br>但函数返回的引用一般来自函数实参或全局变量<br>Y</td><td style="text-align: center;">Y<br>返回右值引用的目的是使得调用者获得右值</td><td style="text-align: center;">xvalue</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">n 是 identity<br>Y</td><td style="text-align: center;">Y<br>为什么可移动？</td><td style="text-align: center;">xvalue</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">m 是 identity<br>Y</td><td style="text-align: center;">Y<br>为什么可移动？</td><td style="text-align: center;">xvalue</td></tr></tbody></table><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Super</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sub</span> : <span class="hljs-keyword">public</span> Super &#123; <span class="hljs-type">int</span> a; &#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span> &#123; Sub sub; &#125;;<br><br><span class="hljs-comment">// cannot take the address of an rvalue of type &#x27;Sub&#x27;</span><br><span class="hljs-comment">// &amp;((Sub[2])&#123;Sub(), Sub()&#125;[0]);</span><br>Super&amp;&amp; a = ((Sub[<span class="hljs-number">1</span>])&#123;<span class="hljs-built_in">Sub</span>()&#125;)[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// cannot take the address of an rvalue of type &#x27;int&#x27;</span><br><span class="hljs-comment">// &amp;(Sub().a);</span><br>Super&amp;&amp; b = <span class="hljs-built_in">Test</span>().sub;<br><br>Sub c;<br><span class="hljs-comment">// cannot take the address of an rvalue of type &#x27;Sub&#x27;</span><br><span class="hljs-comment">// &amp;std::move(c);</span><br>Super&amp;&amp; rC = std::<span class="hljs-built_in">move</span>(c);<br></code></pre></td></tr></table></figure><p>为什么 <code>a[n]</code> 和 <code>a.m</code> 可移动？</p><blockquote><p>女朋友常说：”你是我的，所以你的钱也是我的“</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Money</span> &#123;&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Person</span> &#123; Money m &#125;;<br>Person you;<br>Person ry&amp;&amp; = std::<span class="hljs-built_in">move</span>(you);<br>Person yourGirlFriend;<br><span class="hljs-comment">// you.money 是一个 xvalue</span><br>youGirlFried.money = you.money;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Person <span class="hljs-title">getGoodMan</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> Person; &#125;<br>Person girlFriend;<br>grilFriend.money = getGoodMan.money<br></code></pre></td></tr></table></figure><blockquote><p>”你的钱，我要了“</p></blockquote><h3 id="copy-constructor-move-constructor">copy constructor &amp; move constructor</h3><p>左值匹配拷贝构造函数，右值匹配移动构造函数</p><p>识别左值右值的时候注意两条规则：</p><ol type="1"><li>rvalue reference 会被当做 lvalue 处理</li><li>函数调用的值类型不等于函数返回值的值类型</li></ol><h3 id="perfect-forward">perfect forward</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;copy constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;move constructor&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Test&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(t)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Test&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(move(t))</span></span>;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">(T&amp;&amp; t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Test <span class="hljs-title">t2</span><span class="hljs-params">(forward&lt;T&gt;(t))</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Test t;<br>    <span class="hljs-built_in">f</span>(t);<br>    <span class="hljs-built_in">f</span>(<span class="hljs-built_in">move</span>(t));<br>    <span class="hljs-built_in">g</span>(t);<br>    <span class="hljs-built_in">g</span>(<span class="hljs-built_in">move</span>(t));<br>&#125;<br></code></pre></td></tr></table></figure><p>代码输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;iostream&gt;</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">include &lt;utility&gt;</span><br>using namespace std;<br><br>struct Test<br>&#123;<br>    Test() = default;<br>    Test(Test&amp; other) &#123;<br>        cout &lt;&lt; &quot;copy constructor&quot; &lt;&lt; endl;<br>    &#125;<br>    Test(Test&amp;&amp; other) &#123;<br>        cout &lt;&lt; &quot;move constructor&quot; &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br>void f(Test&amp; t)<br>&#123;<br>    Test t2(t);<br>&#125;<br><br>void f(Test&amp;&amp; t)<br>&#123;<br>    Test t2(move(t));<br>&#125;<br><br>template &lt;typename T&gt;<br>void g(T&amp;&amp; t)<br>&#123;<br>    Test t2(forward&lt;T&gt;(t));<br>&#125;<br><br>int main()<br>&#123;<br>    Test t;<br>    f(t);<br>    f(move(t));<br>    g(t);<br>    g(move(t));<br>&#125;<br></code></pre></td></tr></table></figure><p>代码输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">copy constructor<br>move constructor<br>copy constructor<br>move constructor<br></code></pre></td></tr></table></figure><p>函数 <code>g</code> 调用的 <code>forward</code> 函数即是完美转发，完美转发保证将左值引用当做左值处理，将右值引用当做右值处理</p><p>函数 g 的参数类型是 <code>T&amp;&amp;</code> ，笔者认为 <code>&amp;&amp;</code> 在这里并不代表右值，而是代表 universal reference</p><p><code>T&amp;&amp;</code> 不是右值，是 universal reference （这是 C++11 的另外一个大坑）</p><h3 id="右值语义如何影响代码">右值语义如何影响代码</h3><p>在不考虑 copy elision 的情况下（编译时添加 <code>-fno-elide-constructors</code> 选项），右值语义可以大大减小返回复杂类型的成本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;* output)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<br>  vector&lt;<span class="hljs-type">int</span>&gt; x = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数 <code>f</code> 和 函数 <code>g</code> 的性能差距即使在不考虑 copy elision 的情况下，也是非常小的，而函数 <code>g</code> 的含义却比函数 <code>f</code> 的含义要清晰</p><p>顺带提一句：调用"返回值不是引用类型的函数"的表达式的值类型是右值，代码不必写成 <code>std::move(x)</code> 的形式</p><p>两个返回值的函数可以写成如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// clang++-8 -std=c++11 -fno-elide-constructors test.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vec</span><br>&#123;<br>    <span class="hljs-built_in">Vec</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">Vec</span>(Vec&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Vec</span>(Vec&amp;&amp; other) = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Pair</span><br>&#123;<br>    <span class="hljs-built_in">Pair</span>(T&amp;&amp; t, U&amp;&amp; u) : <span class="hljs-built_in">first</span>(forward&lt;T&gt;(t)), <span class="hljs-built_in">second</span>(forward&lt;U&gt;(u)) &#123;&#125;<br>    <span class="hljs-built_in">Pair</span>(Pair&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Pair</span>(Pair&amp;&amp; other) : <span class="hljs-built_in">first</span>(<span class="hljs-built_in">move</span>(other.first)), <span class="hljs-built_in">second</span>(<span class="hljs-built_in">move</span>(other.second)) &#123;&#125;<br><br>    T first;<br>    U second;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">f</span><span class="hljs-params">(Vec* v)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function">Pair&lt;<span class="hljs-type">bool</span>, Vec&gt; <span class="hljs-title">g</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Vec v;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Pair</span>&lt;<span class="hljs-type">bool</span>, Vec&gt;(<span class="hljs-literal">true</span>, <span class="hljs-built_in">move</span>(v));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Pair&lt;<span class="hljs-type">bool</span>, Vec&gt; <span class="hljs-title">result</span><span class="hljs-params">(g())</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>相较于函数 <code>f</code> ，函数 <code>g</code> 最多多调用两次移动构造函数</p><h2 id="copy-elision">copy elision</h2><p>Named Return Value Optimization = NRVO</p><p>Return Value Optimization = RVO</p><p>在 C++11 ，标准只是允许 <code>copy elision</code> 而不是强制 <code>copy elision</code> ，不过 <code>copy elision</code> 在主流编译器已经得到实现</p><h3 id="触发-nrvo-的条件">触发 NRVO 的条件</h3><p>返回相同的具名变量</p><h3 id="guaranteed-copy-elision">Guaranteed copy elision</h3><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">gcc</th><th style="text-align: center;">clang</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">support version</td><td style="text-align: center;"><a href="https://www.gnu.org/software/gcc/projects/cxx-status.html">7</a></td><td style="text-align: center;"><a href="https://clang.llvm.org/cxx_status.html">4</a></td></tr></tbody></table><p>guaranteed copy elision 由 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html">Wording for guaranteed copy elision through simplified value categories</a> 提出，在 C++17 可以使用</p><p>不过在 Guaranteed copy elision 下，临时变量和 prvalue (?) 的语义发生了变化</p><h2 id="emplace">emplace</h2><h3 id="简单介绍">简单介绍</h3><blockquote><p>Inserts a new element into the container constructed in-place with the given <code>args</code> if there is no element with the key in the container. The constructor of the new element (i.e. <a href="http://en.cppreference.com/w/cpp/utility/pair">std::pair</a>&lt;const Key, T&gt;) is called with exactly the same arguments as supplied to <code>emplace</code>, forwarded via <a href="http://en.cppreference.com/w/cpp/utility/forward">std::forward</a>&lt;Args&gt;(args)…. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</p></blockquote><p>引用自 <a href="https://en.cppreference.com/w/cpp/container/map/emplace">cppreference</a> 的这段话可以归纳为三点：</p><ol type="1"><li>原地构造</li><li>完美转发</li><li>即使元素存在也可能引发一次不必要的构造</li></ol><p>考虑下面一个禁止任何拷贝的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>) &#123;&#125;;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 c++11 之前如何为 <code>map&lt;int, Test&gt; m</code> 插入元素呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// error: use of deleted function Test::Test(const Test&amp;)</span><br><span class="hljs-comment">// template argument deduction/substitution failed</span><br>m.<span class="hljs-built_in">insert</span>(std::<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)));<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// error: use of deleted function ‘Test&amp; Test::operator=(Test&amp;&amp;)</span><br><span class="hljs-comment">// error: no matching function for call to Test::Test()</span><br>m[<span class="hljs-number">1</span>] = <span class="hljs-built_in">Test</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>笔者没有想到不 workaround 的办法：为 Test 类增加默认构造函数，放开移动拷贝构造函数的限制等</p><p>在 emplace 之后，你可以这么做：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">m.<span class="hljs-built_in">emplace</span>(<br>  std::piecewise_construct,<br>  std::forward_as_tuple(<span class="hljs-number">1</span>), <span class="hljs-comment">// 构造 key 用到的参数</span><br>  std::forward_as_tuple(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)); <span class="hljs-comment">// 构造 value 用到的参数</span><br></code></pre></td></tr></table></figure><h3 id="其它形式的-emplace">其它形式的 emplace</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">map&lt;string, string&gt; m;<br><span class="hljs-comment">// uses pair&#x27;s move constructor</span><br>m.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;a&quot;</span>), <span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;a&quot;</span>)));<br><span class="hljs-comment">// uses pair&#x27;s converting move constructor</span><br>m.<span class="hljs-built_in">emplace</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>));<br><span class="hljs-comment">// uses pair&#x27;s template constructor</span><br>m.<span class="hljs-built_in">emplace</span>(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>);<br></code></pre></td></tr></table></figure><p>如果 key 和 value 都是单参数构造函数且具备隐式转换，emplace 用起来最方便</p><h3 id="实际用途">实际用途</h3><p>在 C++11 之前，为避免多次构造，往容器里塞元素要这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Element&gt; v;<br>v.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Element</span>()); <span class="hljs-comment">// 提供一个非常轻量的无参数构造函数</span><br>Element&amp; e = v.<span class="hljs-built_in">back</span>();<br>e.field = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 其它赋值操作</span><br></code></pre></td></tr></table></figure><p>这段代码是不优雅的：提供专门为容器准备的无参数构造函数</p><p>利用 emplace 之后：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;Element&gt; v;<br>v.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>代码变得更直观，且性能没有下降，甚至还减少一次对无参数构造函数的调用</p><h3 id="emplace-是如何工作的">emplace 是如何工作的？</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Tp</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">_Allocator</span>&gt;<br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... _Args&gt;<br><span class="hljs-type">void</span> vector&lt;_Tp, _Allocator&gt;::<span class="hljs-built_in">emplace_back</span>(_Args&amp;&amp;... __args)<br>&#123;<br>  <span class="hljs-comment">// omit the relation between capacity and size</span><br>  __RAII_IncreaseAnnotator __annotator(*<span class="hljs-keyword">this</span>);<br>  __alloc_traits::<span class="hljs-built_in">construct</span>(<span class="hljs-keyword">this</span>-&gt;__alloc(),<br>                            _VSTD::__to_raw_pointer(<span class="hljs-keyword">this</span>-&gt;__end_),<br>                            _VSTD::forward&lt;_Args&gt;(__args)...);<br>  __annotator.__done();<br>&#125;<br><br><span class="hljs-keyword">using</span> __alloc_traits = allocator_traits&lt;_Allocator&gt;;<br></code></pre></td></tr></table></figure><p>根据 <a href="https://en.cppreference.com/w/cpp/memory/allocator/construct">cppreference</a> 的描述，<code>std::allocator&lt;T&gt;::construct</code> 的作用是</p><blockquote><p>Constructs an object of type <code>T</code> in allocated uninitialized storage pointed to by <code>p</code>, using placement-new</p></blockquote><p>Calls <code>::new((void *)p) U([std::forward]&lt;Args&gt;(args)…)</code></p><p>一般而言，分配内存与构建对象是绑定的，而 placement new 只负责在已分配的内存上构建对象</p><p>利用 placement new 和完美转发，emplace 的实现顺理成章：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniVec</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> mElement[<span class="hljs-built_in">sizeof</span>(E)];<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span>... Args&gt;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">emplace_back</span><span class="hljs-params">(Args&amp;&amp;... args)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">new</span> (<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">void</span>*&gt;(mElement)) <span class="hljs-built_in">E</span>(forward&lt;Args&gt;(args)...);<br>    &#125;<br><br>    <span class="hljs-function">E* <span class="hljs-title">begin</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">reinterpret_cast</span>&lt;E*&gt;(mElement);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>UniVec</code> 是一个最多只能存放一个元素的 Vector ，<code>emplace_back</code> 的实现是使用完美转发的参数调用 <code>placement new</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>        : <span class="hljs-built_in">mA</span>(a)<br>        , <span class="hljs-built_in">mB</span>(b)<br>    &#123;&#125;<br><br>    <span class="hljs-built_in">Test</span>(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-built_in">Test</span>(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Test&amp; other) = <span class="hljs-keyword">delete</span>;<br>    Test&amp; <span class="hljs-keyword">operator</span>=(Test&amp;&amp; other) = <span class="hljs-keyword">delete</span>;<br><br>    <span class="hljs-type">int</span> mA;<br>    <span class="hljs-type">int</span> mB;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    UniVec&lt;Test&gt; v;<br>    v.<span class="hljs-built_in">emplace_back</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    cout &lt;&lt; v.<span class="hljs-built_in">begin</span>()-&gt;mA &lt;&lt; endl;<br>    cout &lt;&lt; v.<span class="hljs-built_in">begin</span>()-&gt;mB &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序能正常编译运行，说明 emplace_back 确实如预期运行</p><h2 id="可打断的线程">可打断的线程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;csignal&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">onSignalTerm</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span>&#123;<br>    <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::<span class="hljs-built_in">signal</span>(SIGTERM, onSignalTerm);<br>    <span class="hljs-function">std::thread <span class="hljs-title">t</span><span class="hljs-params">([]() -&gt; <span class="hljs-type">void</span> &#123; <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;&#125; &#125;)</span></span>;<br>    <span class="hljs-type">pthread_t</span> tid = t.<span class="hljs-built_in">native_handle</span>();<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">pthread_kill</span>(tid, SIGTERM);<br>    t.<span class="hljs-built_in">join</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;join succeed&quot;</span> &lt;&lt;  std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用信号的能力，写一个超时则强制结束的线程池是可能的：杀掉一个线程再创建一个线程放进去</p><p>但要根据线程耗的 cpu 时间、当前的调用栈以及调用栈参数等详细信息来决定是否强制杀掉一个线程仍是非常有难度的，检测底层信息不是件容易的事情</p><h2 id="编译期反射-static_assert-concept">编译期反射 + static_assert = concept</h2><p>concept <span class="math inline">\(\approx\)</span> 接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> Engine&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EngineWrapper</span><br>&#123;<br>    <span class="hljs-keyword">using</span> R = <span class="hljs-keyword">typename</span> concepts::Get_Caller_MethodRT0&lt;Engine&gt;::type;<br><br>    <span class="hljs-built_in">static_assert</span>(<br>        concepts::<span class="hljs-built_in">IsStandardRandom</span>&lt;Engine&gt;() ||<br>        concepts::<span class="hljs-built_in">IsMonkeyRandom</span>&lt;Engine&gt;(),<br>        <span class="hljs-string">&quot;Engine should be a standard random or monkey random&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匹配任何调用的函数">匹配任何调用的函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(...)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以任意个数、任意类型（参数类型不需要一致）的参数调用 <code>func</code> 都是没问题的</p><h3 id="对模板参数的限制">对模板参数的限制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> R, <span class="hljs-keyword">typename</span> ...Ps&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Has_Max_Method</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> U&gt;<br>    <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">Test</span><span class="hljs-params">(U* u)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">((*u).Max(std::declval&lt;Ps&gt;()...))</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MarkType</span> &#123;&#125;;<br><br>    <span class="hljs-function"><span class="hljs-type">static</span> MarkType <span class="hljs-title">Test</span><span class="hljs-params">(...)</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = std::is_same&lt;<br>        <span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">Test</span>(std::<span class="hljs-built_in">declval</span>&lt;T*&gt;())), R&gt;::value;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上代码可以检查一个类型是否具备某个函数，举例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>&#123;<br>    <span class="hljs-built_in">static_assert</span>(Has_Max_Method&lt;E, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::value, <span class="hljs-string">&quot;E must have Max method&quot;</span>);<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Test</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> a &gt; b;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Container</code> 要求其元素类型 <code>E</code> 具备函数签名为 <code>int Max(int, int)</code> 的成员函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;<span class="hljs-type">int</span>&gt; a;<br>    Container&lt;Test&gt; b;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器报错：<code>static_assert failed due to requirement 'Has_Max_Method&lt;int, int, int, int&gt;::value' "E must have Max method"</code></p><h3 id="两种报错形式">两种报错形式</h3><p>假设我们不使用 <code>static_assert</code> 限制模板参数需要具备的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">E</span>().<span class="hljs-built_in">Max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">Max</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器报错：<code>in instantiation of member function 'Container&lt;int&gt;::Max' requested here</code></p><blockquote><p>想想看 vector 是怎么虐待你的吧！</p><p>我们需要一个看得懂模板报错的 C++ 工程师！</p></blockquote><p>但一旦使用 <code>static_assert</code> ，体验会非常接近支持 interface 的语言</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Container</span><br>&#123;<br>    <span class="hljs-built_in">static_assert</span>(Has_Max_Method&lt;E, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;::value, <span class="hljs-string">&quot;E must have Max method&quot;</span>);<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Max</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">E</span>().<span class="hljs-built_in">Max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Container&lt;<span class="hljs-type">int</span>&gt; a;<br>    a.<span class="hljs-built_in">Max</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>编译器的完整报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">test.cpp:22:5: error: static_assert failed due to requirement &#x27;Has_Max_Method&lt;int, int, int, int&gt;::value&#x27; &quot;E must have Max method&quot;<br>    static_assert(Has_Max_Method&lt;E, int, int, int&gt;::value, &quot;E must have Max method&quot;);<br>    ^             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>test.cpp:41:20: note: in instantiation of template class &#x27;Container&lt;int&gt;&#x27; requested here<br>    Container&lt;int&gt; a;<br>                   ^<br>1 error generated.<br></code></pre></td></tr></table></figure><p>编译器在 <code>static_assert</code> 失败之后，并没有继续尝试实例化 <code>static_assert</code> 之后的成员函数；同时报错信息也可以自行定制；模板报错变得简短而准确。</p><h3 id="编译器反射如何影响代码">编译器反射如何影响代码？</h3><p>abstract class vs template ：</p><ol type="1"><li>不需要付出性能损耗的代价（模板成员函数默认会 inline ？）</li><li>注入更加方便，不需要类似 <code>SetDependency</code> 的函数提供注入手段。</li></ol><p>在将 <code>Has_Max_Method</code> 类似的类用宏抽象后，编译期反射用起来的体验如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">GET_RT_MACRO_SIMPLE</span>(PublicMethod, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">static_assert</span>(std::is_same&lt;Get_PublicMethod_MethodRT0&lt;Test&gt;::type, <span class="hljs-type">bool</span>&gt;::value, <span class="hljs-string">&quot;&quot;</span>);<br></code></pre></td></tr></table></figure><p>这不妨成为 <code>abstract class</code> 的一种替代选项。</p>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
      <category>Programming Language</category>
      
      <category>C++</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
