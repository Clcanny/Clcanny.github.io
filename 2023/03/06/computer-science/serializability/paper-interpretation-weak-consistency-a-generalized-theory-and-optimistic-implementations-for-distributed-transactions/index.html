

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="JunBin">
  <meta name="keywords" content="">
  
    <meta name="description" content="Proposed Specifications for Existing Isolation Levels System Model and Terminology Database Model  When a transaction writes an object \(x\), it creates a new version of \(x\). A transaction \(T_i\) c">
<meta property="og:type" content="article">
<meta property="og:title" content="Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions">
<meta property="og:url" content="https://clcanny.github.io/2023/03/06/computer-science/serializability/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/index.html">
<meta property="og:site_name" content="On The Road">
<meta property="og:description" content="Proposed Specifications for Existing Isolation Levels System Model and Terminology Database Model  When a transaction writes an object \(x\), it creates a new version of \(x\). A transaction \(T_i\) c">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/the-two-phase-commit-protocol-in-thor.png">
<meta property="og:image" content="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/transaction-history.png">
<meta property="article:published_time" content="2023-03-05T16:12:38.000Z">
<meta property="article:modified_time" content="2025-07-30T15:39:02.327Z">
<meta property="article:author" content="JunBin">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/the-two-phase-commit-protocol-in-thor.png">
  
  
  
  <title>Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions - On The Road</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"clcanny.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.0.0-rc1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-03-06 00:12" pubdate>
          2023年3月6日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          116k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          966 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="proposed-specifications-for-existing-isolation-levels">Proposed Specifications for Existing Isolation Levels</h2>
<h3 id="system-model-and-terminology">System Model and Terminology</h3>
<h4 id="database-model">Database Model</h4>
<ul>
<li>When a transaction writes an object <span class="math inline">\(x\)</span>, it creates a new version of <span class="math inline">\(x\)</span>. A transaction <span class="math inline">\(T_i\)</span> can modify an object multiple times; its first update of object <span class="math inline">\(x\)</span> is denoted by <span class="math inline">\(x_{i.1}\)</span> , the second by <span class="math inline">\(x_{i.2}\)</span>, and so on. Version <span class="math inline">\(x_i\)</span> denotes the final modification of <span class="math inline">\(x\)</span> performed by <span class="math inline">\(T_i\)</span> before it commits or aborts. That is, <span class="math inline">\(x_i \equiv x_{i.n} \, \textrm{where} \, n = \max \{j \mid x_{i.j} \, \textrm{exists} \}\)</span>.</li>
<li>There are three kinds of objects versions:
<ul>
<li>During initialization, a transaction <span class="math inline">\(T_i\)</span> creates all objects that will ever exist in the database; at this point, each object <span class="math inline">\(x\)</span> has an initial version, <span class="math inline">\(x_{init}\)</span>, called the unborn version.</li>
<li>When an application transaction inserts an object <span class="math inline">\(x\)</span>, we model it as the creation of a visible version for <span class="math inline">\(x\)</span>.</li>
<li>When a transaction <span class="math inline">\(T_i\)</span> deletes an object <span class="math inline">\(x\)</span>, we model it as the creation of a special dead version, <span class="math inline">\(x_{dead}\)</span>.</li>
<li>Create, update, and delete operations can be modeled as update operations with the above conventions.</li>
</ul></li>
<li>All objects in the database have a unique identity that is not based on field values.
<ul>
<li>Suppose transaction <span class="math inline">\(T_i\)</span> deletes <span class="math inline">\(x\)</span> and a later transaction <span class="math inline">\(T_j\)</span> checks if this tuple exists and inserts a new tuple. Transaction <span class="math inline">\(T_j\)</span>'s insert operation overwrites the unborn version of an object <span class="math inline">\(y\)</span> that has not been used before and creates a visible version of <span class="math inline">\(y\)</span>.</li>
<li>If two transactions try to insert a tuple with the same field values, the system selects two distinct objects for insertion. The decision whether both tuples can be inserted is left to the application and the database system, i.e., our model does not require that the database contains unique tuples.</li>
</ul></li>
</ul>
<h4 id="transaction-histories">Transaction Histories</h4>
<p>A history <span class="math inline">\(H\)</span> cover a set of transactions consists of two parts:</p>
<ul>
<li>a partial order of events <span class="math inline">\(E\)</span> that reflects the operations (e.g., read, write, abort, commit) of those transactions,
<ul>
<li>The notion <span class="math inline">\(w_i(x_{i.m}, v)\)</span> denotes transaction <span class="math inline">\(T_i\)</span> performs a write operation on object <span class="math inline">\(x\)</span> as its <span class="math inline">\(m^{th}\)</span> modification (within the transaction <span class="math inline">\(T_i\)</span>) with value <span class="math inline">\(v\)</span>.</li>
<li>The notion <span class="math inline">\(r_j(x_{i.m}, v)\)</span> denotes transaction <span class="math inline">\(T_j\)</span> performs a read operation on a version of object <span class="math inline">\(x\)</span> that was written by transaction <span class="math inline">\(T_i\)</span> at its <span class="math inline">\(m^{th}\)</span> modification with value <span class="math inline">\(v\)</span> (<span class="math inline">\(T_i\)</span> could be the same as <span class="math inline">\(T_j\)</span>).</li>
<li>The partial order of events E in a history obeys the following constraints:
<ul>
<li>It preserves the order of all events within a transaction including the commit and abort events.</li>
<li>If an event <span class="math inline">\(r_j(x_{i.m})\)</span> exists in E, it should be preceded by <span class="math inline">\(w_i(x_{i.m})\)</span> in <span class="math inline">\(E\)</span>, i.e., a transaction <span class="math inline">\(T_j\)</span> cannot read version <span class="math inline">\(x_i\)</span> of object <span class="math inline">\(x\)</span> before it has been produced by <span class="math inline">\(T_i\)</span>.</li>
<li>If an event <span class="math inline">\(w_i(x_{i.m})\)</span> is followed by <span class="math inline">\(r_i(x_j)\)</span> without an intervening event <span class="math inline">\(w_i(x_{i.n})\)</span> in <span class="math inline">\(E\)</span>, <span class="math inline">\(x_j\)</span> must be <span class="math inline">\(x{i.m}\)</span>. This condition ensures that if a transaction modifies object <span class="math inline">\(x\)</span> and later reads <span class="math inline">\(x\)</span>, it will observe its last update to <span class="math inline">\(x\)</span>.</li>
</ul></li>
<li>We would add extra conditions as they are needed at each isolation level.</li>
</ul></li>
<li>and a version order, <span class="math inline">\(\ll\)</span>, that is a total order on committed object versions.
<ul>
<li>There is no constraint on versions due to uncommitted or aborted transactions.</li>
<li>The version order of committed object versions obeys the following constraints:
<ul>
<li>The version order of each object <span class="math inline">\(x\)</span> contains exactly one initial version, <span class="math inline">\(x_{init}\)</span>, and at most one dead version, <span class="math inline">\(x_{dead}\)</span>.</li>
<li><span class="math inline">\(x_{init}\)</span> is <span class="math inline">\(x\)</span>'s first version in its version order and <span class="math inline">\(x_{dead}\)</span> is its last version (if it exists); all visible versions are placed between <span class="math inline">\(x_{init}\)</span> and <span class="math inline">\(x_{dead}\)</span>.</li>
<li>If <span class="math inline">\(r_j(x_i)\)</span> occurs in a history, then <span class="math inline">\(x_i\)</span> is a visible version. This condition ensures that transactions can only read visible versions.</li>
</ul></li>
</ul></li>
</ul>
<p>The version order in a history <span class="math inline">\(H\)</span> can be different from the order of write or commit events in <span class="math inline">\(H\)</span>.</p>
<ul>
<li>e.g., <span class="math inline">\(H_{write-order}: w_1(x_1) w_2(x_2) c_1 c_2 \quad [x_2 \ll x_1]\)</span>.
<ul>
<li>The database system chooses the version order <span class="math inline">\(x_2 \ll x_1\)</span> even though <span class="math inline">\(T_1\)</span> writes <span class="math inline">\(x_1\)</span> before <span class="math inline">\(T_2\)</span> writes <span class="math inline">\(x_2\)</span>.</li>
<li>The fact that <span class="math inline">\(T_1\)</span> commits before <span class="math inline">\(T_2\)</span> does not determine the version order either.</li>
</ul></li>
<li>This flexibility is needed to allow certain optimistic and multi-version implementations.</li>
</ul>
<h4 id="predicates">Predicates</h4>
<h5 id="version-set">Version Set</h5>
<p>When a transaction executes a read or write based on a predicate <span class="math inline">\(P\)</span>, the system selects a version for <strong>each</strong> object in <span class="math inline">\(P\)</span>’s relations (where a relation corresponds to a MySQL table). The set of selected versions is called the Version set of this predicate-based operation and is denoted by <span class="math inline">\(\operatorname{Vset}(P)\)</span>.</p>
<p>Versions of objects in <span class="math inline">\(P\)</span>'s relations are selected before determining whether they match <span class="math inline">\(P\)</span> or not. Therefore, <span class="math inline">\(\operatorname{Vset}(P)\)</span> includes versions of all objects in <span class="math inline">\(P\)</span>'s relations, regardless of whether they are matched by <span class="math inline">\(P\)</span> or not. <span class="math inline">\(\operatorname{Vset}(P)\)</span> will be very large since it includes unborn and possibly dead versions of some objects.</p>
<h5 id="predicate-based-reads">Predicate-based Reads</h5>
<p>We denote a predicate-based read as <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>.</p>
<p>After the predicate-base read, <span class="math inline">\(T_i\)</span> can execute operations on the matched objects, e.g., it could read <span class="math inline">\(x_1\)</span>'s value. These reads will show up as <strong>separate</strong> events in the history. If <span class="math inline">\(T_i\)</span> does not read <span class="math inline">\(x_1\)</span>, we do not add a read event to the history. Thus, the history only shows reads of versions that were actually observed by transaction <span class="math inline">\(T_i\)</span>.</p>
<h5 id="predicate-based-modifications">Predicate-based Modifications</h5>
<p>We denote a medicate-based modification as <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>.</p>
<p>Note that a predicate-based modification can also be modeled as a predicate-based read followed by a set of writes on the matched objects:</p>
<ul>
<li>e.g., <span class="math inline">\(r_i(P:\operatorname{Vset}(P)) w_i(x_i)\)</span>. The paper "Generalized Isolation Level Definitions" employs this approach to define isolation levels.</li>
<li>Under the same constraints on histories, this technique provides weaker guarantees (than the approach given above) to predicate-based modifications at lower isolation levels.</li>
<li>However, it is possible to introduce additional constraints on histories to provide same guarantees.</li>
</ul>
<h4 id="conflicts-and-serialization-graphs">Conflicts and Serialization Graphs</h4>
<p>We define three kinds of direct conflicts that capture conflicts of two different <strong>committed</strong> transactions on the same object or intersecting predicates:</p>
<ul>
<li>Directly Read-Depends, <span class="math inline">\(T_i \stackrel{wr}{\longrightarrow} T_j\)</span>.
<ul>
<li>Directly item-read-depends: We say that <span class="math inline">\(T_j\)</span> directly item-read-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs some object version <span class="math inline">\(x_i\)</span> and <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(x_i\)</span>.</li>
<li>Directly predicate-read-depends: Transaction <span class="math inline">\(T_j\)</span> directly predicate-read-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_j\)</span> performs an operation <span class="math inline">\(r_j(P:\operatorname{Vset}(P))\)</span> and <span class="math inline">\(x_i \in \operatorname{Vset}(P)\)</span>.
<ul>
<li>Transaction <span class="math inline">\(T_j\)</span> directly predicate-read-depends on the initialization transaction <span class="math inline">\(T_{init}\)</span> since <span class="math inline">\(T_j\)</span> observes the unborn versions of objects that have yet not been inserted in <span class="math inline">\(P\)</span>'s relations.</li>
<li>If <span class="math inline">\(T_j\)</span> observes a dead version of some object, it directly read-depends on the transaction that deleted that object.</li>
</ul></li>
</ul></li>
<li>Directly Anti-Depends, <span class="math inline">\(T_i \stackrel{rw}{\longrightarrow} T_j\)</span>.
<ul>
<li>Directly item-anti-depends: We say that <span class="math inline">\(T_j\)</span> directly item-anti-depends on transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> reads some object version <span class="math inline">\(x_k\)</span> and <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x\)</span>'s <strong>next</strong> version (after <span class="math inline">\(x_k\)</span>) in the <strong>version order</strong>.</li>
<li>Directly predicate-anti-depends: We say that <span class="math inline">\(T_j\)</span> directly predicate-anti-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>. That is, if <span class="math inline">\(T_j\)</span> installs a <strong>later (but not necessarily the next)</strong> version of some object that <strong>changes the matches</strong> of a predicate-based read performed by <span class="math inline">\(T_i\)</span>.
<ul>
<li>Overwriting a predicate-based operation: We say that a transaction <span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> (or <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>) based on predicate <span class="math inline">\(P\)</span> if <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x_j\)</span> such that <span class="math inline">\(x_k \ll x_j\)</span>, <span class="math inline">\(x_k \in \operatorname{Vset}(P)\)</span> and <span class="math inline">\(x_k\)</span> matches <span class="math inline">\(P\)</span> whereas <span class="math inline">\(x_j\)</span> does not match <span class="math inline">\(P\)</span> or vice-versa. That is, <span class="math inline">\(T_j\)</span> makes a modification that changes the set of objects matched by <span class="math inline">\(T_i\)</span>'s predicate-based operation.</li>
</ul></li>
</ul></li>
<li>Directly Write-Depends, <span class="math inline">\(T_i \stackrel{ww}{\longrightarrow} T_j\)</span>.
<ul>
<li>Directly item-write-depends: We say that <span class="math inline">\(T_j\)</span> directly item-write-depends on transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs a version <span class="math inline">\(x_i\)</span> and <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x\)</span>'s <strong>next</strong> version (after <span class="math inline">\(x_i\)</span>) in the version order.</li>
<li>Directly predicate-write-depends: We say that <span class="math inline">\(T_j\)</span> directly predicate-write-depends on <span class="math inline">\(T_i\)</span> if either
<ol type="1">
<li><span class="math inline">\(T_j\)</span> executes an operation <span class="math inline">\(w_j(Q:\operatorname{Vset}(Q))\)</span> and <span class="math inline">\(x_i \in \operatorname{Vset}(Q)\)</span>. In other words, the system selects a version <span class="math inline">\(x_i\)</span> in <span class="math inline">\(T_j\)</span>'s predicate-based write.</li>
<li><span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>. This means that <span class="math inline">\(T_j\)</span> installs a later version of an object that changes the matches of a predicate-based write performed by <span class="math inline">\(T_i\)</span>.</li>
</ol></li>
</ul></li>
</ul>
<p>The definition of predicate-write-dependencies is similar to the definitions of predicate-read-dependencies (the first part) and predicate-anti-dependencies (the second part).</p>
<p>We can define the direct serialization graph (DSG) of a given history <span class="math inline">\(H\)</span> as follows:</p>
<ul>
<li>Each node in <span class="math inline">\(\operatorname{DSG}(H)\)</span> corresponds to a committed transaction in <span class="math inline">\(H\)</span>.</li>
<li>Directed edges correspond to different types of direct conflicts.</li>
</ul>
<h5 id="refine-direct-predicate-anti-dependency">Refine: Direct Predicate-Anti-Dependency</h5>
<p>If <span class="math inline">\(T_j\)</span> installs a <strong>later</strong> version of an object that changes the matches of a predicate-based read performed by <span class="math inline">\(T_i\)</span>, but it is not the <strong>next</strong> version of that object in the version order, this still results in direct predicate-anti-dependency between <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>. Here's an example from the thesis.</p>
<p>When <span class="math inline">\(T_1\)</span> performs its query there are exactly two employees, <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, both in Sales. <span class="math inline">\(T_1\)</span> sums up the salaries of these employees and compares it with the sum-of-salaries maintained for this department. However, before it performs the final check, <span class="math inline">\(T_2\)</span> inserts a new employee in the Sales department, updates the sum-of-salaries, and commits. Thus, when <span class="math inline">\(T_1\)</span> reads the new sum-of-salaries value, it finds an inconsistency.</p>
<p><span class="math inline">\(H_{phantom}\)</span> is ruled out by PL-3 because the direct serialization graph contains a cycle with a predicate-anti-dependency edge.</p>
<p><span class="math display">\[\begin{align*}
H_{phantom}: r_1(Dept=Sales:x_0,10;y0,10) &amp;\\
             r_2(Sum_0,20)                &amp;\\
             w_2(z_2=10)                  &amp;\\
             w_2(Sum_2,30)                &amp;\\
             c_2                          &amp;\\
             r_1(Sum_2,30)                &amp;\\
             c_1                          &amp;\\
[Sum_0 \ll Sum_2, z_{init} \ll z_2]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T0 --&gt;|wr| T1;
  T0 --&gt;|wr| T2;
  T1 -.-&gt;|predicate-rw| T2;
  T2 --&gt;|wr| T1;
</code></pre>
<p>Let's consider a modification to <span class="math inline">\(H_{phantom}\)</span>:</p>
<ul>
<li>Change <span class="math inline">\(Sum\)</span> to <span class="math inline">\(SumMoreThan15\)</span>.</li>
<li>Add transaction <span class="math inline">\(T_3\)</span>, which increases employee <span class="math inline">\(z\)</span>'s salary from 10 to 20 and updates the sum-of-salaries after <span class="math inline">\(T_2\)</span> is committed.</li>
</ul>
<p><span class="math display">\[\begin{align*}
H_{phantom}: r_1(Dept=Sales:x_0,10;y0,10;z_{init}) &amp;\\
             r_2(SumMoreThan15_0,0)                &amp;\\
             w_2(z_2=10)                           &amp;\\
             w_2(SumMoreThan15_2,0)                &amp;\\
             c_2                                   &amp;\\
             r_3(SumMoreThan15_2,0)                &amp;\\
             r_3(z_2=10)                           &amp;\\
             w_3(z_3=20)                           &amp;\\
             w_3(SumMoreThan15_3,20)               &amp;\\
             c_3                                   &amp;\\
             r_1(SumMoreThan15_3,20)               &amp;\\
             c_1                                   &amp;\\
[SumMoreThan15_0 \ll SumMoreThan15_2 \ll SumMoreThan15_3, z_{init} \ll z_2 \ll z_3]
\end{align*}\]</span></p>
<p>If the answer is no, since <span class="math inline">\(z_3\)</span> is not the next version of <span class="math inline">\(z_{init}\)</span>, there is no predicate-anti-dependency relationship between <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_3\)</span>, and there is no cycle in the direct serialization graph. However, this scenario is nonsensical because <span class="math inline">\(T_1\)</span> would get an inconsistent result.</p>
<pre><code class=" mermaid">graph LR;
  T0 --&gt;|wr| T1;
  T0 --&gt;|wr| T2;
  T2 --&gt;|wr| T3;
  T3 --&gt;|wr| T1;
</code></pre>
<p>To ensure the correctness of the theory, a predicate-anti-dependency between <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_3\)</span> should exist, even if <span class="math inline">\(z_3\)</span> is not considered the next version of <span class="math inline">\(z_{init}\)</span>.</p>
<pre><code class=" mermaid">graph LR;
  T0 --&gt;|wr| T1;
  T0 --&gt;|wr| T2;
  T1 -.-&gt;|predicate-rw| T3;
  T2 --&gt;|wr| T3;
  T3 --&gt;|wr| T1;
</code></pre>
<h3 id="isolation-levels-for-committed-transactions">Isolation Levels for Committed Transactions</h3>
<table>

<thead>
<tr class="header">
<th>Phenomena</th>
<th>Histories Described in tr-95-51</th>
<th>Histories Described in adya-phd</th>
<th>Isolation Levels in tr-95-51</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dirty Write</td>
<td>P0: <code>w1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>G0</td>
<td>PL-1</td>
</tr>
<tr class="odd">
<td>Dirty Read</td>
<td>P1: <code>w1[x]...r2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>A1: <code>w1[x]...r2[x]...(a1 and c2 in any order)</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>G1a + G1b + G1c</td>
<td>PL-2</td>
</tr>
<tr class="even">
<td></td>
<td></td>
<td>G1a + G1b + G1c + G1-predA</td>
<td>PL-2'</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>G1a + G1b + G1c + G1-predB</td>
<td>PL-2''</td>
</tr>
<tr class="even">
<td>Non-repeatable or Fuzzy Read</td>
<td>P2: <code>r1[x]...w2[x]...((c1 or a1) and (c2 or a2) in any order)</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>A2: <code>r1[x]...w2[x]...c2...r1[x]...c1</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Phantom</td>
<td>P3: <code>r1[P]...w2[y in P]...((c1 or a1) and (c2 or a2) any order)</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td>A3: <code>r1[P]...w2[y in P]...c2...r1[P]...c1</code></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Lost Update</td>
<td>P4: <code>r1[x]...w2[x]...w1[x]...c1</code></td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td></td>
<td></td>
<td>G2</td>
<td>PL-3</td>
</tr>
</tbody>
</table>
<h4 id="isolation-level-pl-1">Isolation Level PL-1</h4>
<p><strong>G0: Write Cycles.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G0 if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle consisting entirely of write-dependency edges.</p>
<p>PL-1, which disallows G0, is considered to be more permissive than Read Uncommitted, which disallows P0, since G0 allows concurrent transactions to modify the same object while P0 does not. Thus, non-serializable interleaving of write operations is possible among uncommitted transactions as long as such interleavings are disallowed among committed transactions (e.g., by aborting some transactions).</p>
<p>According to tr-95-51, Dirty Writes (P0) are considered problematic for two main reasons:</p>
<ul>
<li>They can violate database consistency. Assume there is a constraint between <code>x</code> and <code>y</code> (e.g., <code>x</code> = <code>y</code>), and <code>T1</code> and <code>T2</code> each maintain the consistency of the constraint if run alone. However, the constraint can easily be violated if the two transactions write <code>x</code> and <code>y</code> in <strong>different orders</strong>, which can only happen if there are Dirty writes.</li>
<li>Without protection from P0, the system can't undo updates by restoring before images. Consider the history: <code>w1[x] w2[x] a1</code>. You don’t want to undo <code>w1[x]</code> by restoring its before-image of <code>x</code>, because that would wipe out <code>w2</code>'s update. But if you don't restore its before-image, and transaction <code>T2</code> later aborts, you can't undo <code>w2[x]</code> by restoring its before-image either!</li>
</ul>
<p>However, these two reasons have been criticized in adya-phd:</p>
<ul>
<li>... as such interleavings are disallowed among committed transactions (e.g., by aborting some transactions).</li>
<li>We believe that <span class="math inline">\(H_{recovery}\)</span> is a valid history and our consistency condition for no-dirty-writes (G0) allows it. Implementations can handle the aborts of <code>T1</code> and <code>T2</code> in a variety of ways. For example, when <code>T1</code> aborts, the system can let <code>x2</code> be the version that is stored in the database. If <code>T2</code> also aborts, the system reverts the value of <code>x</code> to <code>x0</code>. Furthermore, some client-server systems such as Thor do not install modifications into the committed state until the commit point of transactions. In such systems, we do not even have to revert the value of <code>x</code> when either transaction aborts.</li>
</ul>
<h4 id="isolation-level-pl-2">Isolation Level PL-2</h4>
<ul>
<li>PL-2: Disallow G1a, G1b and G1c.</li>
<li>PL-2': Disallow G1a, G1b, G1c and G1-predA.</li>
<li>PL-2'': Disallow G1a, G1b, G1c and G1-predB.</li>
</ul>
<h5 id="g1a-aborted-reads">G1a: Aborted Reads</h5>
<p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1a if it contains an aborted transaction <span class="math inline">\(T_i\)</span> and a committed transaction <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_j\)</span> has read some object (maybe via a predicate) modified by <span class="math inline">\(T_i\)</span>. Phenomenon G1a can be represented using the following history fragments:</p>
<ul>
<li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(x_{i.m}) \ldots (a_i \text{ and } c_j \text{ in any order })\)</span></li>
<li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(P:x_{i.m}, \dots) \ldots (a_i \text{ and } c_j \text{ in any order })\)</span></li>
</ul>
<p>Proscribing G1a ensures that if <span class="math inline">\(T_j\)</span> reads from <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_i\)</span> aborts, <span class="math inline">\(T_j\)</span> must also abort; these aborts are also called cascaded aborts. In a real implementation, the condition also implies that if <span class="math inline">\(T_j\)</span> reads from an uncommitted transaction <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_j\)</span>'s commit must be delayed until <span class="math inline">\(T_i\)</span>'s commit has succeeded.</p>
<h5 id="g1b-intermediate-reads">G1b: Intermediate Reads</h5>
<p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1b if it contains a committed transaction <span class="math inline">\(T_j\)</span> that has read a version of object <span class="math inline">\(x\)</span> (maybe via a predicate) written by transaction <span class="math inline">\(T_i\)</span> that was not <span class="math inline">\(T_i\)</span>'s final modification of <span class="math inline">\(x\)</span>. The following history fragments represent this phenomenon:</p>
<ul>
<li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(x_{i.m}) \ldots w_i(x_{i.n}) c_j\)</span></li>
<li><span class="math inline">\(w_i(x_{i.m}) \ldots r_j(P:x_{i.m}, \ldots) \ldots w_i(x_{i.n}) c_j\)</span></li>
</ul>
<p>Like our other conditions, G1b does not constrain the behavior of uncommitted transactions.</p>
<h5 id="g1c-circular-information-flow">G1c: Circular Information Flow</h5>
<p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1c if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle consisting entirely of dependency edges, where a dependency edge is defined as either a read-dependency edge or a write-dependency edge.</p>
<h5 id="g1">G1</h5>
<p>Our condition that captures the essence of no-dirty-reads is G1, which is comprised of G1a, G1b, and G1c. We define isolation level PL-2 as one in which phenomenon G1 is disallowed. (Note that G1c includes G0. We could have defined a weaker version of G1c that only concerned cycles having at least one read-dependency edge, but it seems simpler not to do this.)</p>
<p>Proscribing G1 is clearly weaker than proscribing P1 since G1 allows transactions to read from uncommitted transactions.</p>
<h5 id="g1-preda-non-atomic-predicate-based-reads">G1-predA: Non-atomic Predicate-based Reads</h5>
<p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1-predA if <span class="math inline">\(H\)</span> contains distinct committed transactions <span class="math inline">\(T_j\)</span> and <span class="math inline">\(T_i\)</span>, and operations <span class="math inline">\(w_j(Q:\operatorname{Vset}(Q)), w_j(x_j) \ldots w_j(y_j)\)</span> and <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> such that <span class="math inline">\(w_j(x_j)\)</span> and <span class="math inline">\(w_j(y_j)\)</span> are events generated due to <span class="math inline">\(w_j(Q:\operatorname{Vset}(Q))\)</span>, <span class="math inline">\(x_j \in \operatorname{Vset}(P)\)</span>, and <span class="math inline">\(w_j(y_j)\)</span> <strong>overwrites</strong> (refer to the following explanation for more details) <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>.</p>
<p>PL-2' can be defined as a level that disallows G1a, G1b, G1c, and G1-predA.</p>
<ul>
<li><p>In the context of overwriting a predicate-based operation:</p>
<blockquote>
<p>We say that a transaction <span class="math inline">\(T_j\)</span> overwrites an operation <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> (or <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span>) based on predicate <span class="math inline">\(P\)</span> if <span class="math inline">\(T_j\)</span> installs <span class="math inline">\(x_j\)</span> such that <span class="math inline">\(x_k \ll x_j\)</span>, <span class="math inline">\(x_k \in \operatorname{Vset}(P)\)</span> and <span class="math inline">\(x_k\)</span> matches <span class="math inline">\(P\)</span> whereas <span class="math inline">\(x_j\)</span> does not match <span class="math inline">\(P\)</span> or vice-versa. That is, <span class="math inline">\(T_j\)</span> makes a modification that changes the set of objects matched by <span class="math inline">\(T_i\)</span>'s predicate-based operation.</p>
</blockquote></li>
<li><p>Based on my understanding, in the context of G1-predA, it is possible that <span class="math inline">\(w_j(x_j)\)</span> overwrites <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> if <span class="math inline">\(x_k \ll x_j\)</span>, <span class="math inline">\(x_k \in \operatorname{Vset}(P)\)</span>, regardless of whether <span class="math inline">\(x_j\)</span> is a modification that changes the set of objects matched by <span class="math inline">\(P\)</span>. However, it is important to note that this is only my interpretation and I am not entirely certain if it aligns with the author's intention. If my understanding is indeed correct, the author's assertion makes sense:</p>
<blockquote>
<p>Disallowing G1-predA guarantees that if <span class="math inline">\(T_i\)</span>'s predicate-based read observes an update by <span class="math inline">\(T_j\)</span>'s predicate-based write, it does not see any version older than the ones installed by <span class="math inline">\(T_j\)</span>'s write. Thus, disallowing G1-predA ensures that all read/write operations are indivisible with respect to each other.</p>
</blockquote></li>
<li><p>When the meaning of "overwrite" varies, it becomes difficult to definitively determine the relationship between PL-2' and PL-3. Is PL-3 remains more restrictive than PL-2' under these conditions?</p></li>
</ul>
<h5 id="g1-predb-non-atomic-predicate-based-reads-with-respect-to-transactions">G1-predB: Non-atomic Predicate-based Reads with respect to Transactions</h5>
<p>A history <span class="math inline">\(H\)</span> exhibits phenomenon G1-predB if <span class="math inline">\(H\)</span> contains distinct committed transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_i\)</span> <strong>overwrites</strong> (refer to the following explanation for more details) an operation <span class="math inline">\(r_j(P:\operatorname{Vset}(P))\)</span> and there exists a version <span class="math inline">\(x_i\)</span> in <span class="math inline">\(\operatorname{Vset}(P)\)</span>.</p>
<p><span class="math display">\[\begin{align*}
H_{atomic-read}: w_1(\text{Dept=Sales}:x_0;y_0;z_0)               &amp;\\
                 w_1(x_1)                                         &amp;\\
                 w_1(y_1)                                         &amp;\\
                 w_1(z_1)                                         &amp;\\
                 r_2(\text{Dept=Sales or Dept=Legal}:x_1;y_1;z_0) &amp;\\
                 r_2(x_1)                                         &amp;\\
                 r_2(y_1)                                         &amp;\\
                 c1                                               &amp;\\
                 c2                                               &amp;\\
[x_0 \ll x_1, y_0 \ll y_1, z_0 \ll z_1]
\end{align*}\]</span></p>
<p>In this case, <span class="math inline">\(z_0\)</span> represents an employee record in the legal department, and <span class="math inline">\(w_1(z_1)\)</span> is a regular write, not one generated by <span class="math inline">\(w_1(\text{Dept=Sales}:x_0;y_0;z_0)\)</span>. Disallowing G1-predB will prohibit <span class="math inline">\(H_{atomic-read}\)</span>, but it would be allowed if only G1-predA is disallowed. This is because G1-predA requires <span class="math inline">\(w_1(z_1)\)</span> to be generated by <span class="math inline">\(w_1(\text{Dept=Sales}:x_0;y_0;z_0)\)</span>, while G1-predB has no such requirement.</p>
<p>In my opinion, the overwriting concept in G1-predB appears similar to that in G1-predA. This is reflected in the fact that:</p>
<ul>
<li>Disallowing G1-predB will prohibit <span class="math inline">\(H_{atomic-read}\)</span>, implies</li>
<li><span class="math inline">\(T_1\)</span> overwrites <span class="math inline">\(r_2(\text{Dept=Sales or Dept=Legal}:x_1;y_1;z_0)\)</span>, implies</li>
<li><span class="math inline">\(w_1(z_1)\)</span> overwrites <span class="math inline">\(r_2(\text{Dept=Sales or Dept=Legal}:x_1;y_1;z_0)\)</span>, implies</li>
<li>Overwriting in G1-predB does not require <span class="math inline">\(w_1(z_1)\)</span> is a modification that changes the set of objects matched by <span class="math inline">\(\text{Dept=Sales or Dept=Legal}\)</span>.</li>
</ul>
<h4 id="isolation-level-pl-3">Isolation Level PL-3</h4>
<p><strong>G2: Anti-dependency Cycles.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G2 if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle having one or more <strong>anti-dependency</strong> edges.</p>
<p>We define PL-3 as an isolation level that proscribes G1 and G2. Thus, all cycles are precluded at this level.</p>
<h4 id="pl-3-provides-conflict-serializability">PL-3 provides conflict-serializability</h4>
<p>The author claims that PL-3 provides conflict-serializability, but there is no detailed verification provided:</p>
<p>The conditions given in [BHG87] provides view-serializability whereas our specification for PL-3 provides conflict-serializability (this can shown using theorems presented in [GR93, BHG87]).</p>
<p><span class="math inline">\(\operatorname{DSG}(H)\)</span> is acyclic, and G1a, and G1b are satisfied for a history <span class="math inline">\(H\)</span> iff <span class="math inline">\(H\)</span> is conflict-serializable.</p>
<p>The Wormhole Theorem, as described in section 7.5.8.1 of "Transaction Processing: Concepts and Techniques" by J. N. Gray and A. Reuter (Morgan Kaufmann Publishers Inc., 1993), states:</p>
<p>A history achieves isolation if and only if it contains no wormhole transactions.</p>
<ul>
<li>Proof: (Isolated =&gt; no wormholes). This proof is by contradiction.
<ol type="1">
<li>Suppose <span class="math inline">\(H\)</span> is an isolated history of the execution of the set of transactions <span class="math inline">\(\left\{T_i \mid i=1, \ldots, n\right\}\)</span>. By definition, then, <span class="math inline">\(H\)</span> is equivalent to some serial execution history, <span class="math inline">\(SH\)</span>, for that same set of transactions.</li>
<li>Without loss of generality, assume that the transactions are numbered so that <span class="math inline">\(SH = T_1 \| T_2 \| \ldots \| T_n\)</span>.</li>
<li>Suppose, for the sake of contradiction, that <span class="math inline">\(H\)</span> has a wormhole; that is, there is some sequence of transactions <span class="math inline">\(T, T^\prime, T^{\prime\prime}, \ldots, T^{\prime\prime\prime}\)</span> such that each is BEFORE the other (i.e., <span class="math inline">\(T \ll_H T^\prime\)</span>), and the last is BEFORE the first (i.e., <span class="math inline">\(T^{\prime\prime\prime} \ll_H T\)</span>).</li>
<li>Let <span class="math inline">\(i\)</span> be the minimum transaction index such that <span class="math inline">\(T_i\)</span> is in this wormhole, and let <span class="math inline">\(T_j\)</span> be its predecessor in the wormhole (i.e., <span class="math inline">\(T_j \ll_H T_i\)</span>).</li>
<li>By the minimality of <span class="math inline">\(i\)</span>, <span class="math inline">\(T_j\)</span> comes completely AFTER <span class="math inline">\(T_i\)</span> in the execution history <span class="math inline">\(SH\)</span> (recall assumption of step 2), so that <span class="math inline">\(T_j \ll_{SH} T_i\)</span> is impossible (recall that <span class="math inline">\(SH\)</span> is a serial history). But since <span class="math inline">\(H\)</span> and <span class="math inline">\(SH\)</span> are equivalent, <span class="math inline">\(\ll_{H} = \ll_{SH}\)</span>; therefore, <span class="math inline">\(T_j \ll_H T_i\)</span> is also impossible. This contradiction proves that if <span class="math inline">\(H\)</span> isisolated, it has no wormholes.</li>
</ol></li>
<li>Proof: (No wormholes =&gt; isolated). This proof is by induction on the number of transactions, <span class="math inline">\(n\)</span>, that appear in the history, <span class="math inline">\(H\)</span>. The induction hypothesis is that any <span class="math inline">\(n\)</span> transaction history <span class="math inline">\(H\)</span> having no wormholes is isolated (equivalent to some serial history, <span class="math inline">\(SH\)</span>, for that set of transactions).
<ul>
<li>If <span class="math inline">\(n &lt; 2\)</span>, then any history is a serial history, since only zero or one transaction appears in the history. In addition, any serial history is an isolated history. The basis of the induction, then, is trivially true.</li>
<li>Suppose the induction hypothesis is true for <span class="math inline">\(n-1\)</span> transactions, and consider some history <span class="math inline">\(H\)</span> of <span class="math inline">\(n\)</span> transactions that has no wormholes.
<ol type="1">
<li>Pick any transaction <span class="math inline">\(T\)</span>, then pick any other transaction <span class="math inline">\(T^\prime\)</span>, such that <span class="math inline">\(T \ll T^\prime\)</span>, and continue this construction as long as possible, building the sequence <span class="math inline">\(S = (T, T^\prime, \ldots)\)</span>. Either <span class="math inline">\(S\)</span> is infinite, or it is not. If <span class="math inline">\(S\)</span> is infinite, then some transaction <span class="math inline">\(T^{\prime\prime}\)</span> must appear in it twice. This, in turn, implies that <span class="math inline">\(T^{\prime\prime} \ll T^{\prime\prime}\)</span>; thus, <span class="math inline">\(T^{\prime\prime}\)</span> is a wormhole of <span class="math inline">\(H\)</span>. But since <span class="math inline">\(H\)</span> has no wormholes, <span class="math inline">\(S\)</span> cannot be infinite. The last transaction in <span class="math inline">\(S\)</span> - call it <span class="math inline">\(T^*\)</span> - has the property <span class="math inline">\(\operatorname{AFTER}(T^*) = \varnothing\)</span>, since the sequence cannot be continued past <span class="math inline">\(T^*\)</span>.</li>
<li>Consider the history, <span class="math inline">\(H^\prime = \left\langle\left\langle t_i, a_i, o_i\right\rangle \in H \mid t_i \neq T^*\right\rangle\)</span>. <span class="math inline">\(H^\prime\)</span> is the history <span class="math inline">\(H\)</span> with all the actions of transaction <span class="math inline">\(T^*\)</span> removed. By the choice of <span class="math inline">\(T^*\)</span>, <span class="math inline">\(\operatorname{DEP}(H^\prime) = \left\{\langle T, \langle o, i\rangle, T^\prime\rangle \in \operatorname{DEP}(H) \mid T^\prime \neq T^*\right\}\)</span>.
<ol type="1">
<li><span class="math inline">\(H^\prime\)</span> has no wormholes (since <span class="math inline">\(H\)</span> has no wormholes, and <span class="math inline">\(\operatorname{DEP}(H) \supseteq \operatorname{DEP}(H^\prime)\)</span>). The induction hypothesis, then, applies to <span class="math inline">\(H^\prime\)</span>. Hence, <span class="math inline">\(H^\prime\)</span> is isolated and has an equivalent serial history <span class="math inline">\({SH}^\prime = T_1 \| T_2 \| \ldots \| T_{n-1}\)</span> for some numbering of the other transactions.</li>
<li>The serial history <span class="math inline">\(SH = {SH}^\prime \| T^* = T_1 \| T_2 \| \ldots \| T_{n-1} \| T^*\)</span> is equivalent to <span class="math inline">\(H\)</span>. To prove this, it must be shown that <span class="math inline">\(\operatorname{DEP}(SH) = \operatorname{DEP}(H)\)</span>. By construction, <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:by-construction}\)</span>. By definition, <span class="math inline">\(\operatorname{DEP}({SH}^\prime) = \operatorname{DEP}(H^\prime)\)</span>. Using Equation <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:h-prime-depend}\)</span> to substitute into Equation <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:by-construction}\)</span> gives: <span class="math inline">\(\eqref{the-wormhole-theorem:no-wormholes-infer-isolated:final}\)</span>. Thus, the identity <span class="math inline">\(DEP(SH)= DEP(H)\)</span> is established, and the induction step is proven.</li>
</ol></li>
</ol></li>
<li>The notion <span class="math inline">\(\langle t_i, a_i, o_i\rangle\)</span> represents that transaction <span class="math inline">\(t_i\)</span> performs action <span class="math inline">\(a_i\)</span> (e.g., read) on object <span class="math inline">\(o_i\)</span>. The notion <span class="math inline">\(\left\langle T, \langle o, i\rangle, T^\prime\right\rangle\)</span> represents that <span class="math inline">\(T^\prime\)</span> depends on <span class="math inline">\(T\)</span>, where <span class="math inline">\(o\)</span> is the object creating the dependency, and <span class="math inline">\(i\)</span> indicates the version of <span class="math inline">\(o\)</span> being read or written by <span class="math inline">\(T^\prime\)</span>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{align}
  \operatorname{DEP}(SH)
= \operatorname{DEP}({SH}^\prime \| T^*)
=   \operatorname{DEP}({SH}^\prime)
  \cup
    \left\{
      \left\langle T^\prime, \langle o, i\rangle, T^*\right\rangle
      \in \operatorname{DEP}(H)
    \right\}
\label{the-wormhole-theorem:no-wormholes-infer-isolated:by-construction}
\end{align}\]</span></p>
<p><span class="math display">\[\begin{align}
    \operatorname{DEP}({SH}^\prime)
  = \operatorname{DEP}(H^\prime)
  = \left\{
        \left\langle T, \langle o, i\rangle, T^\prime\right\rangle
        \in \operatorname{DEP}(H)
      \mid
        T^\prime \neq T^*
    \right\}
\label{the-wormhole-theorem:no-wormholes-infer-isolated:h-prime-depend}
\end{align}\]</span></p>
<p><span class="math display">\[\begin{align}
&amp;\phantom{=} \operatorname{DEP}(SH)           \\
          &amp;= \phantom{\cup}&amp;
               \left\{
                   \left\langle T, \langle o, i\rangle, T^\prime\right\rangle
                   \in \operatorname{DEP}(H)
                 \mid
                  T^\prime \neq T^*
               \right\}             \nonumber \\
             &amp;\phantom{=} &amp;\cup
               \left\{
                 \left\langle T^\prime, \langle o, i\rangle, T^*\right\rangle
                 \in \operatorname{DEP}(H)
               \right\}             \nonumber \\
          &amp;= \operatorname{DEP}(H)  \nonumber
\label{the-wormhole-theorem:no-wormholes-infer-isolated:final}
\end{align}\]</span></p>
<p>The Serializability Theorem, as described in Section 2.3 of "Concurrency Control and Recovery in Database Systems" by Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman, states:</p>
<p>A history <span class="math inline">\(H\)</span> is serializable iff <span class="math inline">\(\operatorname{SG}(H)\)</span> is acyclic.</p>
<ul>
<li>Proof: (Acyclic =&gt; serializable).
<ol type="1">
<li>Suppose <span class="math inline">\(H\)</span> is a history over <span class="math inline">\(T = \left\{T_1, T_2, \ldots, T_n\right\}\)</span>. Without loss of generality, assume <span class="math inline">\(\operatorname{C}(T) = \left\{T_1, T_2, \ldots, T_m \mid m \le n\right\}\)</span> are all of the transactions in <span class="math inline">\(T\)</span> that are committed in <span class="math inline">\(H\)</span>. Thus <span class="math inline">\(T_1, T_2, \ldots, T_m\)</span> are the nodes of <span class="math inline">\(\operatorname{SG}(H)\)</span>.</li>
<li>Since <span class="math inline">\(\operatorname{SG}(H)\)</span> is acyclic it may be topologically sorted (See Section A.3 of the Appendix for a definition of "topological sort of a directed acyclic graph"). Let <span class="math inline">\(i_1, i_2, \ldots, i_m\)</span> be a permutation of <span class="math inline">\(1, 2, \ldots, m\)</span> such that <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span> is a topological sort of <span class="math inline">\(\operatorname{SG}(H)\)</span>. Let <span class="math inline">\(H_s\)</span> be the serial history <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span>.</li>
<li>We claim that <span class="math inline">\(\operatorname{C}(H) \equiv H_s\)</span>. To see this, let <span class="math inline">\(p_i \in T_i\)</span> and <span class="math inline">\(q_j \in T_j\)</span>, where <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_j\)</span> are committed in <span class="math inline">\(H\)</span>. Suppose <span class="math inline">\(p_i\)</span>, <span class="math inline">\(q_j\)</span> conflict and <span class="math inline">\(p_i \lt_H q_j\)</span>. By definition of <span class="math inline">\(\operatorname{SG}(H)\)</span>, <span class="math inline">\(T_i \rightarrow T_j\)</span> is an edge in <span class="math inline">\(\operatorname{SG}(H)\)</span>. Therefore in any topological sort of <span class="math inline">\(\operatorname{SG}(H)\)</span>, <span class="math inline">\(T_i\)</span> must appear before <span class="math inline">\(T_j\)</span>. Thus in <span class="math inline">\(H_s\)</span> all operations of <span class="math inline">\(T_i\)</span> appear before any operation of <span class="math inline">\(T_j\)</span>, and in particular, <span class="math inline">\(p_i \lt_H q_j\)</span>. We have proved that any two conflicting operations are ordered in <span class="math inline">\(\operatorname{C}(H)\)</span> in the same way as <span class="math inline">\(H_s\)</span>. Thus <span class="math inline">\(\operatorname{C}(H) \equiv H_s\)</span> and, because <span class="math inline">\(H_s\)</span> is serial by construction, <span class="math inline">\(H\)</span> is serializable as was to be proved.</li>
</ol></li>
<li>Proof: (Serializable =&gt; acyclic).
<ol type="1">
<li>Suppose history <span class="math inline">\(H\)</span> is serializable. Let <span class="math inline">\(H_s\)</span> be a serial history equivalent to <span class="math inline">\(\operatorname{C}(H)\)</span>. Consider an edge <span class="math inline">\(T_i \rightarrow T_j\)</span> in <span class="math inline">\(\operatorname{SG}(H)\)</span>. Thus there are two conflicting operations <span class="math inline">\(p_i\)</span>, <span class="math inline">\(q_j\)</span> of <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_j\)</span> (respectively), such that <span class="math inline">\(p_i \lt_H q_j\)</span>. Because <span class="math inline">\(\operatorname{C}(H) \equiv H\)</span>, <span class="math inline">\(p_i \lt_{H_s} q_j\)</span>. Because <span class="math inline">\(H_s\)</span> is serial and <span class="math inline">\(p_i\)</span> in <span class="math inline">\(T_i\)</span> precedes <span class="math inline">\(q_j\)</span> in <span class="math inline">\(T_j\)</span>, it follows that <span class="math inline">\(T_i\)</span> appears before <span class="math inline">\(T_j\)</span> in <span class="math inline">\(H_s\)</span>. Thus, we've shown that if <span class="math inline">\(T_i \rightarrow T_j\)</span> is in <span class="math inline">\(\operatorname{SG}(H)\)</span> then <span class="math inline">\(T_i\)</span> appears before <span class="math inline">\(T_j\)</span> in <span class="math inline">\(H_s\)</span>.</li>
<li>Now suppose there is a cycle in <span class="math inline">\(\operatorname{SG}(H)\)</span>, and without loss of generality let that cycle be <span class="math inline">\(T_1 \rightarrow T_2 \rightarrow \ldots \rightarrow T_k \rightarrow T_1\)</span>. These edges imply that in <span class="math inline">\(H_s\)</span>, <span class="math inline">\(T_1\)</span> appears before <span class="math inline">\(T_2\)</span> which appears before <span class="math inline">\(T_3\)</span> appears before <span class="math inline">\(\ldots\)</span> before <span class="math inline">\(T_k\)</span> which appears before <span class="math inline">\(T_1\)</span>. Thus, the existence of the cycle implies that each of <span class="math inline">\(T_1, T_2, \ldots, T_k\)</span> appears before itself in the serial history <span class="math inline">\(H_s\)</span>, an absurdity. So no cycle can exist in <span class="math inline">\(\operatorname{SG}(H)\)</span>. That is, <span class="math inline">\(\operatorname{SG}(H)\)</span> is an acyclic directed graph, as was to be proved.</li>
</ol></li>
</ul>
<h4 id="isolation-level-pl-2.99">Isolation Level PL-2.99</h4>
<p><strong>G2-item: Item Anti-dependency Cycles.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G2-item if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle having one or more <strong>item</strong>-anti-dependency edges.</p>
<p>Level PL-2.99 is defined as one that proscribes G1 and G2-item.</p>
<p><span class="math inline">\(H_{phantom}\)</span> is ruled out by PL-3 but permitted by PL-2.99 because the DSG contains a cycle only if predicate anti-dependency edges are considered.</p>
<p><span class="math display">\[\begin{align*}
H_{phantom}: r_1(\text{Dept=Sales}:x0,10;y0,10) &amp;\\
             r_2(Sum0,20)                       &amp;\\
             w_2(z_2=10 \text{ in Dept=Sales})  &amp;\\
             w_2(Sum_2,30)                      &amp;\\
             c_2                                &amp;\\
             r_1(Sum_2,30)                      &amp;\\
             c_1                                &amp;\\
[Sum_0 \ll Sum_2, z_{init} \ll z_2]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T0 --&gt;|wr| T1;
  T0 --&gt;|wr| T2;
  T1 -.-&gt;|predicate-rw| T2;
  T2 --&gt;|wr| T1;
</code></pre>
<h3 id="mixing-of-isolation-levels">Mixing of Isolation Levels</h3>
<h3 id="correctness-and-flexibility-of-the-new-specifications">Correctness and Flexibility of the New Specifications</h3>
<h3 id="consistency-guarantees-for-executing-transactions">Consistency Guarantees for Executing Transactions</h3>
<p>All definitions presented in this chapter till now provide guarantees to committed transactions only. In this section, we discuss how the isolation levels presented in this chapter can be extended to provide guarantees to executing transactions. To ensure that there is no confusion regarding isolation levels for committed and executing transactions, we prefix all levels for executing transactions by "E".</p>
<h4 id="motivation">Motivation</h4>
<ul>
<li>Suppose that a programmer writes code under the assumption that certain integrity constraints will hold. If these constraints are violated, the transaction will be aborted when it tries to commit. However, before the transaction reaches its commit point, the program may behave in an unexpected manner, e.g., it may crash, go into an infinite loop, or output unexpected results on a user’s display.</li>
<li>Debugging also becomes more difficult for an application programmer; if the transaction observes a broken invariant, it may be difficult for the programmer to determine whether the invariant was violated due to a code bug or due to weak consistency guarantees provided to executing transactions by the system.</li>
</ul>
<p>If a transaction <span class="math inline">\(T_i\)</span> requires execution-time isolation guarantee <span class="math inline">\(L\)</span>, the system must ensure that <span class="math inline">\(T_i\)</span> does not detect that it is running below level <span class="math inline">\(L\)</span> at any given instant. Transaction <span class="math inline">\(T_i\)</span> can detect that it is running below level <span class="math inline">\(L\)</span> if it <strong>reads</strong> objects in a manner that is not allowed by that level. Since a transaction can determine whether it is executing below a certain degree only by observing the state of the database, our conditions will provide guarantees <strong>only for reads of uncommitted transactions and not for their writes</strong>.</p>
<p>For the purpose of providing consistency guarantees to an executing transaction <span class="math inline">\(T_i\)</span>, we consider <span class="math inline">\(T_i\)</span>'s predicate-based writes as predicate-based reads. This approach is taken so that appropriate guarantees can be provided for version sets of predicate-based writes performed by <span class="math inline">\(T_i\)</span> (ghost writes performed by <span class="math inline">\(T_i\)</span> are essentially reads).</p>
<h4 id="isolation-levels-epl-1-and-epl-2">Isolation Levels EPL-1 and EPL-2</h4>
<p>Isolation level PL-1 provides guarantees with respect to writes. Since our execution time guarantees are provided only for reads, level EPL-1 does not place any constraints on executing transactions.</p>
<p>Isolation level PL-2 guarantees that a transaction is allowed to commit if it observes values that existed in the committed state and there is unidirectional flow of information. To ensure that a transaction <span class="math inline">\(T_j\)</span> (while executing) reads from a transaction <span class="math inline">\(T_i\)</span> that does not later abort or modify the objects read by <span class="math inline">\(T_j\)</span> , we disallow reads from uncommitted transactions; furthermore, <strong>no dirty reads also ensure unidirectional information flow</strong>. We define EPL-2 as a level that disallows phenomenon P1.</p>
<h4 id="isolation-level-epl-3">Isolation Level EPL-3</h4>
<p>To specify EPL-3 for a history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span>, we use a new graph called the <strong>Direct Transaction Graph</strong> that is denoted by <span class="math inline">\(\operatorname{DTG}(H,T_i)\)</span>; recall that a DSG was defined for a history only. The DTG is exactly the same as DSG with one addition: it also contains a node for executing transaction <span class="math inline">\(T_i\)</span> and we add all edges corresponding to the <strong>reads</strong> of <span class="math inline">\(T_i\)</span> . Recall that we treat all predicate-based writes of <span class="math inline">\(T_i\)</span> as predicate-based reads so that consistency guarantees can be provided for version sets of predicate-based writes. Thus, we get some extra read-dependency and anti-dependency edges due to such "reads", e.g., if executing transaction <span class="math inline">\(T_i\)</span> performs <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span> and <span class="math inline">\(\operatorname{Vset}(P)\)</span> contains <span class="math inline">\(x_j\)</span>, we add a read-dependency edge from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(T_i\)</span> in the DTG.</p>
<p><span class="math display">\[\begin{align*}
H_{incons-view}: w_0(x_0) &amp;\\
                 w_0(y_0) &amp;\\
                 c_0      &amp;\\
                 w_1(x_1) &amp;\\
                 w_1(y_1) &amp;\\
                 c_1      &amp;\\
                 r_2(x_0) &amp;\\
                 r_2(y_1) &amp;\\
[x_0 \ll x_1; y_0 \ll y_1]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T1[T1-committed];
  T2[T2-executing];
  T1 --&gt;|wr| T2;
  T2 -.-&gt;|rw| T1;
</code></pre>
<p><strong>E2: Anti-dependency Cycles at Runtime.</strong> A history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span> exhibit phenomenon E2 if <span class="math inline">\(\operatorname{DTG}(H,T_i)\)</span> contains a directed cycle involving <span class="math inline">\(T_i\)</span> that consists of dependency edges and one or more anti-dependency edges.</p>
<p>EPL-3 is defined as an isolation level that disallows phenomena P1 and E2. It is more restrictive than PL-3:</p>
<ul>
<li>P1 is more stringent than G1a: Aborted Reads, G1b: Intermediate Reads, G1c: Circular Information Flow.
<ul>
<li>No dirty reads also ensure unidirectional information flow.</li>
</ul></li>
<li>E2: Anti-dependency Cycles at Runtime is more stringent than G2: Anti-dependency Cycles because E2 takes executing transactions into account.</li>
</ul>
<p>Note that we are ignoring anti-dependency edges due to writes by uncommitted transactions. This is in accordance with our goal of providing execution time guarantees for reads only. However, it also turns out that such writes must be ignored so that optimistic schemes can be allowed. To provide EPL-3, one might be tempted to say that all cycles are disallowed in the direct transaction graph. However, this condition is overly restrictive as shown by the following history:</p>
<p><span class="math display">\[\begin{align*}
H_{antidep-cycle}: r_1(x_0) &amp;\\
                   w_2(x_2) &amp;\\
                   r_2(y_0) &amp;\\
                   c_2      &amp;\\
                   w_1(y_1) &amp;\\
[x_0 \ll x_2, y_0 \ll y_1]
\end{align*}\]</span></p>
<p>In this example, <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span> overwrite an object that the other transaction has read.</p>
<pre><code class=" mermaid">graph LR;
  T0[T0-committed];
  T1[T1-executing];
  T2[T2-committed];
  T0 --&gt;|ww,wr| T1;
  T0 --&gt;|ww,wr| T2;
  T1 -.-&gt;|rw| T2;
  T2 -.-&gt;|rw| T1;
</code></pre>
<p>Transaction <span class="math inline">\(T_1\)</span> is doomed to abort since a cycle with two anti-dependency edges has been formed.</p>
<ul>
<li>However, since it does not observe a non-serializable database state, there is no harm in executing it.</li>
<li>Furthermore, this situation can occur with an optimistic scheme in a client-server distributed system where <span class="math inline">\(T_1\)</span> may read <span class="math inline">\(x_0\)</span> and write <span class="math inline">\(y_1\)</span> in its client's cache before information about <span class="math inline">\(T_2\)</span>'s commit arrives at <span class="math inline">\(T_1\)</span>'s client.</li>
</ul>
<h2 id="specifications-for-intermediate-isolation-levels">Specifications for Intermediate Isolation Levels</h2>
<p>There is a wide gap between PL-2, which provides neither consistent reads nor consistent writes, and PL-3, which provides both (this is analogous to the gap between degrees 2 and 3).</p>
<pre><code class=" mermaid">graph BT;
  PL-1;
  PL-2;
  PL-2L[PL-2L: Monotonic View];
  PL-2+[PL-2+: Consistent View];
  PL-FCV[PL-FCV: Forward Consistent View];
  PL-3U[PL-3U: Update Serializability];
  PL-3[PL-3: Full Serializability];
  PL-SS[PL-SS: Strict Serializability];
  PL-MSR[PL-MSR: Monotonic Snapshot Reads];
  PL-SI[PL-SI: Snapshot Isolation];
  PL-CS[PL-CS: Cursor Stability];
  PL-2.99[PL-2.99: Repeatable Read];

  style PL-1 fill:#ffffba;
  style PL-2 fill:#ffffba;
  style PL-2+ fill:#ffffba;
  style PL-3 fill:#ffffba;
  style PL-SI fill:#ffffba;

  PL-1 --&gt; PL-2;
  PL-2 --&gt; PL-2L;
  PL-2L --&gt; PL-2+;
  PL-2L --&gt; PL-MSR;
  PL-2+ --&gt; PL-FCV;
  PL-FCV --&gt; PL-3U;
  PL-FCV --&gt; PL-SI;
  PL-3U --&gt; PL-3;
  PL-3 --&gt; PL-SS;

  PL-2 --&gt; PL-CS;
  PL-CS --&gt; PL-2.99;
  PL-CS --&gt; PL-2+;
  PL-2.99 --&gt; PL-3;

  PL-2 --&gt; PL-MSR;
  PL-MSR --&gt; PL-SI;
  PL-SI --&gt; PL-SS;
</code></pre>
<h3 id="isolation-level-pl-2-1">Isolation Level PL-2+</h3>
<p>Isolation level PL-2+ is motivated by the fact that certain applications only need to observe a consistent state of the database and serializability may not be required. In simpler terms, PL-2+ delivers consistent reads, a feature not offered by PL-2.</p>
<p>Consider the following history <span class="math inline">\(H_{broken}\)</span> where transaction <span class="math inline">\(T_1\)</span> observes an inconsistent state of the database. The consistency constraint, <span class="math inline">\(x + y \le 0\)</span>, is preserved by <span class="math inline">\(T_2\)</span>. However, transaction <span class="math inline">\(T_1\)</span> observes a state reflecting both before and after results of <span class="math inline">\(T_2\)</span> and erroneously concludes that the constraint is broken.</p>
<p><span class="math display">\[\begin{align*}
H_{broken}: r_1(x_0,-50) &amp;\\
            r_2(x_0,-50) &amp;\\
            r_2(y_0,100) &amp;\\
            w_2(x_2,100) &amp;\\
            w_2(y_2,-50) &amp;\\
            c_2          &amp;\\
            r_1(y_2,-50) &amp;\\
            c_1          &amp;\\
[x_0 \ll x_2, y_0 \ll y_2]
\end{align*}\]</span></p>
<p>The following <span class="math inline">\(\operatorname{DSG}(H_{broken})\)</span> shows that history <span class="math inline">\(H_{broken}\)</span> is allowed by PL-2 because the only cycle in <span class="math inline">\(\operatorname{DSG}(H_{broken})\)</span> involves an anti-dependency edge (for simplicity, <span class="math inline">\(T_0\)</span> is not shown); however, it is disallowed by PL-3. Note that P0 and P1 also allow <span class="math inline">\(H_{broken}\)</span>.</p>
<pre><code class=" mermaid">graph LR;
  T1 -.-&gt;|rw| T2;
  T2 --&gt;|wr| T1;
</code></pre>
<p>The author introduces the no-depend-misses property, demonstrated by Chan and Gray to guarantee transaction <span class="math inline">\(T_j\)</span> does not observe violated integrity constraints if update transactions are serializable (i.e., commit at PL-3). The author then proves that disallowing G-single is equivalent to no-depend-misses, and presents PL-2+, which ensures consistent reads but not consistent writes.</p>
<h4 id="specification">Specification</h4>
<p><strong>Basic-Consistency.</strong> A transaction <span class="math inline">\(T_j\)</span> is provided basic-consistency if the values read by <span class="math inline">\(T_j\)</span> are the result of a serial execution of <strong>some subset of committed update transactions</strong> and each update transaction in the serial execution <strong>executes the same steps</strong> as it did in the concurrent execution.</p>
<p>In my understanding, "executing the same steps" implies that, within <strong>a subset of update transactions</strong>, each update transaction in the serial execution <strong>observes the same versions of objects</strong> and <strong>produces the same versions (values) of objects</strong> as it did in the concurrent execution of all update transactions.</p>
<p>It's important to note that we can't select arbitrary subsets of committed update transactions for <span class="math inline">\(T_j\)</span>. Basic consistency necessitates each update transaction in the serial execution to <strong>execute same steps</strong> (possibly <strong>observe the same versions of objects</strong> and <strong>produce the same versions (values) of objects</strong>) as in the concurrent execution. Consequently, update transaction <span class="math inline">\(T_i\)</span> must yields the same write operations in both serial and concurrent executions if it observes the same state. However, if <span class="math inline">\(T_i\)</span> observes a different state in the serial executions due to an incorrect subset of committed update transactions, it may not execute the same write operations. For example, if <span class="math inline">\(T_j\)</span> observes the updates of <span class="math inline">\(T_i\)</span>, it must not "miss the effects" of a transaction <span class="math inline">\(T_k\)</span> whose updates were observed by <span class="math inline">\(T_i\)</span>, i.e., basic-consistency requires that if the subset of transactions chosen for <span class="math inline">\(T_j\)</span>'s observed view includes <span class="math inline">\(T_i\)</span>, it must include <span class="math inline">\(T_k\)</span> as well.</p>
<p>We assume that the committed database state is consistent if the integrity constraints as defined by an application are valid. Furthermore, if an update transaction <span class="math inline">\(T_i\)</span> observes valid integrity constraints and runs alone to completion, we assume that it transforms the committed database state such that the integrity constraints continue to hold after <span class="math inline">\(T_i\)</span> commits.</p>
<p>As discussed in <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/323596.323607">W. E. Weihl. Distributed Version Management for Read-only Actions</a>, basic-consistency ensures that <span class="math inline">\(T_j\)</span> observes a consistent state of the database because the result of a serial execution of update transactions always results in a consistent state.</p>
<p><strong>Missing Transaction Updates.</strong> A transaction <span class="math inline">\(T_j\)</span> misses the effects of a transaction <span class="math inline">\(T_i\)</span> if <span class="math inline">\(T_i\)</span> installs <span class="math inline">\(x_i\)</span> and an event <span class="math inline">\(r_j(x_k)\)</span> exists such that <span class="math inline">\(x_k \ll x_i\)</span>, i.e., <span class="math inline">\(T_j\)</span> reads a version of <span class="math inline">\(x\)</span> that is older than the version that was installed by <span class="math inline">\(T_i\)</span>.</p>
<p><strong>No-Depend-Misses</strong>. If <span class="math inline">\(T_j\)</span> depends on <span class="math inline">\(T_i\)</span>, it does not miss the effects of <span class="math inline">\(T_i\)</span>. This property (along with P1) has been shown by <a target="_blank" rel="noopener" href="https://ieeexplore.ieee.org/document/1702133">W. E. Weihl. Distributed Version Management for Read-only Actions</a> to ensure that transaction <span class="math inline">\(T_j\)</span> does not observe violated integrity constraints if update transactions are serializable (i.e., commit at PL-3). We give a synopsis of this proof in <a href="#relationship-between-pl-2+-and-basic-consistency">Relationship between PL-2+ and Basic-Consistency</a>.</p>
<p><strong>G-single</strong>: Single Anti-dependency Cycles. A history <span class="math inline">\(H\)</span> exhibits phenomenon G-single if <span class="math inline">\(\operatorname{DSG}(H)\)</span> contains a directed cycle with <strong>exactly one anti-dependency edge</strong>.</p>
<p>We now prove Theorem 2+, which states that disallowing G-single is equivalent to no-depend-misses:</p>
<ul>
<li>Disallowing G-single implies no-depend-misses.
<ul>
<li>Suppose that a history <span class="math inline">\(H\)</span> does not exhibit G-single but the no-depend-misses property is violated. Then there exist transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_j\)</span> depends on <span class="math inline">\(T_i\)</span>, yet it misses some effect of <span class="math inline">\(T_i\)</span>; recall that missing <span class="math inline">\(T_i\)</span>'s effects implies that history <span class="math inline">\(H\)</span> contains events <span class="math inline">\(r_j(x_k)\)</span> and <span class="math inline">\(w_i(x_i)\)</span> such that <span class="math inline">\(xk \ll xi\)</span>. This situation is shown in the following figure where <span class="math inline">\(T_u\)</span> overwrites <span class="math inline">\(x_k\)</span> and hence there is an anti-dependency edge from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(T_u\)</span>; a "*" denotes 0 or more edges and a "+" denotes 1 or more edges. In this figure, <span class="math inline">\(T_i\)</span> could be the same as <span class="math inline">\(T_u\)</span>, i.e., <span class="math inline">\(T_i\)</span> could have overwritten the version that <span class="math inline">\(T_j\)</span> read. Thus, the DSG has a cycle with one anti-dependency edge, which is a contradiction. Therefore, if history <span class="math inline">\(H\)</span> does not exhibit phenomenon G-single, it satisfies the no-depend-misses property.</li>
</ul></li>
<li>No-depend-misses implies that phenomenon G-single cannot occur.
<ul>
<li>Suppose that a history <span class="math inline">\(H\)</span> satisfies no-depend-misses but exhibits phenomenon G-single. The existence of a cycle with one anti-dependency edge implies that there must be transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that <span class="math inline">\(T_i\)</span> depends on <span class="math inline">\(T_j\)</span> and also <span class="math inline">\(T_j\)</span> <strong>directly</strong> anti-depends on <span class="math inline">\(T_i\)</span>. Because of the direct anti-dependency, there must be some object <span class="math inline">\(x\)</span> such that <span class="math inline">\(T_j\)</span> overwrote the version of <span class="math inline">\(x\)</span> that <span class="math inline">\(T_i\)</span> read, i.e., <span class="math inline">\(T_i\)</span> missed <span class="math inline">\(T_j\)</span>'s effects even though it depends on <span class="math inline">\(T_j\)</span>. But this contradicts the no-depend-misses property. Therefore, if <span class="math inline">\(H\)</span> satisfies the no-depend-misses property, phenomenon G-single cannot occur in <span class="math inline">\(H\)</span>.</li>
</ul></li>
</ul>
<pre><code class=" mermaid">graph LR;
  Tk --&gt;|ww| Tu;
  Tk --&gt;|wr| Tj;
  Tj -.-&gt;|rw| Tu;
  Tu --&gt;|ww*| Ti;
  Ti --&gt;|ww+/wr+| Tj;
</code></pre>
<p>Level PL-2+ proscribes G1 and G-single. Intuitively, PL-2+ provides consistency because cycles with one anti-dependency edge occur exactly when some transaction both observes and misses modifications of another transaction.</p>
<h4 id="relationship-between-pl-2-and-basic-consistency">Relationship between PL-2+ and Basic-Consistency</h4>
<p id=relationship-between-pl-2+-and-basic-consistency>
<p>We now show that PL-2+ is the <strong>weakest</strong> level that ensures basic-consistency provided update transactions modify the database consistently and are serializable.</p>
<p>Theorem: In a history that contains a set of transactions <span class="math inline">\(\Phi\)</span>, <strong>such that</strong> all update transactions in <span class="math inline">\(\Phi\)</span> are serializable, each transaction is provided basic-consistency iff it is committed with at least PL-2+ guarantees.</p>
<p>We will prove this theorem with respect to the reads of a transaction <span class="math inline">\(Q\)</span> in <span class="math inline">\(\Phi\)</span>; <span class="math inline">\(Q\)</span>'s writes are not considered since basic-consistency is only concerned with what a transaction observes. Of course, if <span class="math inline">\(Q\)</span> is an update transaction, it must be serializable (by assumption).</p>
<ul>
<li>PL-2+ is sufficient: Given that all update transactions in <span class="math inline">\(\Phi\)</span> are serializable and <span class="math inline">\(Q\)</span> is committed at level PL-2+ (at least), <span class="math inline">\(Q\)</span> must be provided basic-consistency.
<ul>
<li>Suppose that transaction <span class="math inline">\(Q\)</span> depends on a sequence of transactions <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span> in <span class="math inline">\(\Phi\)</span> (these transactions are serialized from left to right); we call these transactions <span class="math inline">\(Q\)</span>'s depend-set. Transaction <span class="math inline">\(Q\)</span> misses the effects of the rest of the transactions in <span class="math inline">\(\Phi\)</span>; these transactions are called <span class="math inline">\(Q\)</span>'s missed-set; <span class="math inline">\(Q\)</span> <strong>may anti-depend on</strong> some of the transactions in its missed-set.</li>
<li>We can prove <span class="math inline">\(Q\)</span> is provided basic-consistency with the following two steps:
<ul>
<li>Each update transaction in <span class="math inline">\(Q\)</span>'s depend-set executes the same steps (observes the same versions of objects and produces the same versions (values) of objects) as it did in the concurrent execution.
<ul>
<li>Consider any transaction <span class="math inline">\(T_{i_p}\)</span> in <span class="math inline">\(Q\)</span>'s depend-set; <span class="math inline">\(T_{i_p}\)</span>'s depend-set is a subset of <span class="math inline">\(Q\)</span>'s depend-set because depends is a transitive relationship. Since <span class="math inline">\(T_{i_p}\)</span> does not depend on any transaction <span class="math inline">\(T_{k_h}\)</span> in <span class="math inline">\(Q\)</span>'s missed-set, <span class="math inline">\(T_{k_h}\)</span> has no impact on <span class="math inline">\(T_{i_p}\)</span>'s behavior, i.e., <span class="math inline">\(T_{i_p}\)</span>'s modifications (which are based on its reads) are unaffected by the presence or absence of any transaction in <span class="math inline">\(Q\)</span>'s missed-set. Considering a history with only <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span> (in this order), the database state observed by any transaction in this history remains unchanged.</li>
</ul></li>
<li>The values read by <span class="math inline">\(Q\)</span> are the result of a serial execution of its depend-set.
<ul>
<li>Since <span class="math inline">\(Q\)</span> commits with at least PL-2+ guarantees, none of the transactions in its depend-set could have aborted (property G1a).</li>
<li>Furthermore, <span class="math inline">\(Q\)</span> must read the final modifications of each object (property G1b).</li>
<li>Since <span class="math inline">\(Q\)</span> commits with at least PL-2+ guarantees, G-single cannot occur for <span class="math inline">\(Q\)</span>. We have proven that disallowing G-single is equivalent to no-depend-misses, then <span class="math inline">\(Q\)</span> does not miss the effects of <span class="math inline">\(T_{i_1}, T_{i_2}, \ldots, T_{i_m}\)</span>.</li>
</ul></li>
</ul></li>
</ul></li>
<li>PL-2+ is necessary: Given that all update transactions in <span class="math inline">\(\Phi\)</span> are serializable (i.e., commit at PL-3), <span class="math inline">\(Q\)</span> is provided basic-consistency only if it is committed with at least PL-2+ guarantees.
<ul>
<li>We have to prove that <span class="math inline">\(Q\)</span> will not be provided basic-consistency if it is committed below PL-2+. For this purpose, we will show that if any phenomenon of PL-2+ is allowed, it results in violation of basic-consistency.
<ul>
<li>Phenomena G1a and G1b: The definition of basic-consistency requires a transaction to read from a set of committed transactions. Thus, G1a and G1b must be disallowed for providing basic-consistency.</li>
<li>Phenomenon G1c: Phenomenon G1c can occur only when update transactions form a cycle consisting of dependency edges. However, since we are given that all update transactions in <span class="math inline">\(\Phi\)</span> are serializable and we are only concerned with <span class="math inline">\(Q\)</span>'s reads, phenomenon G1c cannot occur in the history.</li>
<li>Phenomenon G-single: <span class="math inline">\(H_{n-cycle}\)</span> is a counter-example which shows that basic-consistency can be violated if G-single is allowed. Each transaction <span class="math inline">\(T_i\)</span> maintains the invariant <span class="math inline">\(x&lt;y\)</span> but <span class="math inline">\(Q\)</span> observes it as broken.
<ul>
<li>The author provides a counter-example, but this does not form a complete proof. It is still uncertain whether any histories exist that are both disallowed by G-single and do not violate basic-consistency. Further research is required to definitively answer this question.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{align*}
H_{n-cycle}: r_1(x_0,5)     &amp;\\
             r_1(y_0,7)     &amp;\\
             w_1(x_1,10)    &amp;\\
             w_1(y_1,14)    &amp;\\
             \ldots         &amp;\\
             w_n(x_n,5*2^n) &amp;\\
             w_n(y_n,7*2^n) &amp;\\
             r_Q(y0,7)      &amp;\\
             r_Q(x_n,5*2^n) &amp;\\
[x_0 \ll \ldots x_n, y_0 \ll \ldots y_n]
\end{align*}\]</span></p>
<h4 id="why-g-single-emphasizes-exactly-one-anti-dependency-edge">Why G-single Emphasizes Exactly One Anti-dependency Edge</h4>
<p>Why does G-single specifically emphasize having exactly one anti-dependency edge, rather than allowing one or more anti-dependency edges? As an example, let's consider <span class="math inline">\(H_{anti-dependency-edges}\)</span>. Notice that all update transactions in <span class="math inline">\(H_{anti-dependency-edges}\)</span> are serializable.</p>
<p><span class="math display">\[\begin{align*}
H_{anti-dependency-edges}: w_0(x_0) &amp;\\
                           w_0(y_0) &amp;\\
                           c_0      &amp;\\
                           r_1(x_0) &amp;\\
                           r_2(x_0) &amp;\\
                           r_2(y_0) &amp;\\
                           w_2(x_2) &amp;\\
                           c_2      &amp;\\
                           r_3(y_0) &amp;\\
                           w_3(y_3) &amp;\\
                           c_3      &amp;\\
                           r_1(y_3) &amp;\\
                           c1       &amp;\\
[x_0 \ll x_2, y_0 \ll y_3]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T0 --&gt;|wr| T1;
  T0 --&gt;|wr,ww| T2;
  T0 --&gt;|wr,ww| T3;
  T1 -.-&gt;|rw| T2;
  T2 -.-&gt;|rw| T3;
  T3 --&gt;|wr| T1;
</code></pre>
<p>Based on the wormhole theorem, a cycle in <span class="math inline">\(\operatorname{DSG}(H_{anti-dependency-edges})\)</span> containing two anti-dependency edges, indicates <span class="math inline">\(H_{anti-dependency-edges}\)</span> is non-serializable. Despite <span class="math inline">\(T_1\)</span> reading object versions that might not be present in any serializable schedule, basic consistency is preserved.</p>
<p>By removing <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span> from <span class="math inline">\(H_{anti-dependency-edges}\)</span>, we obtain <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>. We can demonstrate that the final state <span class="math inline">\(\{x_0, y_3\}\)</span> of <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span> satisfies the integrity constraints as follows:</p>
<ul>
<li><span class="math inline">\(T_3\)</span> is a valid transaction in <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span> because:
<ul>
<li><span class="math inline">\(T_3\)</span> must be valid or invalid in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span> since it reads and writes the same versions of objects in both histories:
<ul>
<li><span class="math inline">\(T_3\)</span> observes <span class="math inline">\(\{y_0\}\)</span> in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>.</li>
<li>We assume that if a transaction reads the same versions of objects, it must execute the same steps and write the same versions of objects. Based on this assumption, <span class="math inline">\(T_3\)</span> writes <span class="math inline">\(\{y_3\}\)</span> in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>.</li>
</ul></li>
<li><span class="math inline">\(T_3\)</span> is a valid transaction in <span class="math inline">\(H_{anti-dependency-edges}\)</span>.</li>
</ul></li>
<li><span class="math inline">\(\{x_0, y_3\}\)</span> is a a state that satisfies the integrity constraints:
<ul>
<li>We assume that:
<ul>
<li>The committed database state is consistent if the integrity constraints as defined by an application are valid.</li>
<li>Furthermore, if a valid update transaction <span class="math inline">\(T_i\)</span> observes valid integrity constraints and runs alone to completion, it transforms the committed database state such that the integrity constraints continue to hold after <span class="math inline">\(T_i\)</span> commits.</li>
</ul></li>
<li>Therefore:
<ul>
<li><span class="math inline">\(\{x_0, y_0\}\)</span> is a state that satisfies the integrity constraints in both <span class="math inline">\(H_{anti-dependency-edges}\)</span> and <span class="math inline">\(H_{anti-dependency-edges}^\prime\)</span>.</li>
<li>Since <span class="math inline">\(T_3\)</span> observes a state that satisfies the integrity constraints and runs independently to completion, and it is a <strong>valid</strong> transaction, the integrity constraints must hold after <span class="math inline">\(T_3\)</span> commits.</li>
</ul></li>
</ul></li>
</ul>
<p>Drawing inspiration from the above example, let's consider a history <span class="math inline">\(H\)</span> that consists of serializable update transactions and exactly one read transaction <span class="math inline">\(Q\)</span> committed at PL-2+. Let <span class="math inline">\(H^\prime\)</span> be a subset of <span class="math inline">\(H\)</span> containing <span class="math inline">\(Q\)</span> and the depend-set of <span class="math inline">\(Q\)</span>. If <span class="math inline">\(Q\)</span> reads only the versions of objects written by its depend-set, then <span class="math inline">\(H\)</span> can be considered serializable. However, if this condition is not met, <span class="math inline">\(H\)</span> might not be serializable, and <span class="math inline">\(Q\)</span> could potentially read versions of objects not found in any serializable schedule of <span class="math inline">\(H\)</span>. Despite this possibility, <span class="math inline">\(Q\)</span> still maintains basic consistency. Please note that this statement serves as an intuitive understanding derived from the example, rather than a formal proof.</p>
<p>From a programmer’s perspective, PL-2+ provides a useful guarantee since it allows an application to <strong>rely on invariants without full serializability</strong>. As demonstrated in the case of <span class="math inline">\(H_{anti-dependency-edges}\)</span>, <span class="math inline">\(T_1\)</span> reads <span class="math inline">\(x_0\)</span> and <span class="math inline">\(y_3\)</span>, which are not present in any serializable schedule. Nevertheless, all integrity constraints remain intact.</p>
<h4 id="discussion">Discussion</h4>
<p>In <a href="#relationship-between-pl-2+-and-basic-consistency">Relationship between PL-2+ and Basic-Consistency</a>, the assumption is that all update transactions are serializable (e.g., committed at PL-3). However, if an update transaction is not committed at PL-3 but instead at PL-2+, there is a possibility that it may update the database inconsistently. For instance, in <span class="math inline">\(H_{wskew}\)</span>, transactions break the constraint <span class="math inline">\(x + y &lt; 10\)</span> because their operations are interleaved in a non-serializable manner.</p>
<p><span class="math display">\[\begin{align*}
H_{wskew}: r_1(x_0,1) &amp;\\
           r_1(y_0,5) &amp;\\
           r_2(x_0,1) &amp;\\
           r_2(y_0,5) &amp;\\
           w_1(x_1,4) &amp;\\
           c_1        &amp;\\
           w_2(y_2,8) &amp;\\
           c_2        &amp;\\
[x_0 \ll x_1, y_0 \ll y_2]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T0 --&gt;|ww,wr| T1;
  T0 --&gt;|ww,wr| T2;
  T1 -.-&gt;|rw| T2;
  T2 -.-&gt;|rw| T1;
</code></pre>
<p>Nevertheless:</p>
<ul>
<li>PL-2+ is useful for read-only transactions and update transactions where the application programmer knows that the writes will not destroy the consistency of the database, e.g., if the updates are performed to a private part of the database.</li>
<li>Level PL-2+ also rules out inconsistencies due to phantom reads, since these also give rise to cycles containing one anti-dependency edge. For example, it disallows history <span class="math inline">\(H_{phantom}\)</span>.</li>
<li>Another advantage of PL-2+ over PL-2 is that it avoids the lost updates problem. For example, it disallows history <span class="math inline">\(H_{lost-update}\)</span>.</li>
<li>PL-2+ provides a notion of "causal consistency" since it ensures that a transaction is placed after all transactions that causally affect it.</li>
</ul>
<p><span class="math display">\[\begin{align*}
H_{lost-update}: r_1(x_0,10) &amp;\\
                 r_2(x_0,10) &amp;\\
                 w_2(x_2,15) &amp;\\
                 c_2         &amp;\\
                 w_1(x_1,14) &amp;\\
                 c_1         &amp;\\
[x_0 \ll x_2 \ll x_1]
\end{align*}\]</span></p>
<h3 id="isolation-level-pl-2l">Isolation Level PL-2L</h3>
<h4 id="specification-1">Specification</h4>
<p>A lock-based implementation of degree 2 (i.e., long write-locks and short read-locks) provides stronger guarantees than what is specified by degree 2 (READ COMMITTED). Our new isolation level, PL-2L, characterizes one such guarantee, the lock-monotonicity property.</p>
<p><strong>Lock-monotonicity.</strong> Suppose that an event <span class="math inline">\(r_i(x_j)\)</span> exists in a history. <strong>After</strong> this point, <span class="math inline">\(T_i\)</span> will not miss the effects of <span class="math inline">\(T_j\)</span> and all transactions that <span class="math inline">\(T_j\)</span> depends on.</p>
<p>This property says that a transaction observes a <strong>monotonically increasing prefix</strong> of the database history as it executes (in accordance with write/read-dependencies). For example, if <span class="math inline">\(T_i\)</span> modifies objects <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, and <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(x_i\)</span> and then <span class="math inline">\(y\)</span>, this property ensures that <span class="math inline">\(T_j\)</span> observes <span class="math inline">\(y_i\)</span> or a later version of <span class="math inline">\(y\)</span> <strong>after</strong> reading <span class="math inline">\(x_i\)</span>. However, if <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(y\)</span> before it reads <span class="math inline">\(x_i\)</span>, it could have read a version of <span class="math inline">\(y\)</span> that is older than <span class="math inline">\(y_i\)</span>. Thus, the lock-monotonicity property is <strong>weaker</strong> than the no-depends-misses property and does not guarantee that <span class="math inline">\(T_j\)</span> observes a consistent database state; recall that the no-depend-misses property ensures that <span class="math inline">\(T_j\)</span> does not miss <span class="math inline">\(T_i\)</span>'s effects irrespective of when <span class="math inline">\(T_j\)</span> reads <span class="math inline">\(x_i\)</span>.</p>
<p>We use a graph called the Unfolded Serialization Graph or USG that is a variation of the DSG. The USG is specified for the transaction of interest, <span class="math inline">\(T_i\)</span>, and a history, <span class="math inline">\(H\)</span>, and is denoted by <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span>; recall that a DSG is specified over a history.</p>
<ul>
<li>For the USG, we retain all nodes and edges of the DSG except for <span class="math inline">\(T_i\)</span> and the edges incident on it.
<ul>
<li>For each edge from node <span class="math inline">\(p\)</span> to node <span class="math inline">\(q\)</span> in <span class="math inline">\(\operatorname{DSG}(H)\)</span>, where <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are different from <span class="math inline">\(T_i\)</span>, we draw a corresponding edge in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span>.</li>
</ul></li>
<li>Instead, we split the node for <span class="math inline">\(T_i\)</span> into multiple nodes — one node for every read/write event in <span class="math inline">\(T_i\)</span>, these nodes are called read nodes and write nodes respectively.
<ul>
<li>Any edge that was incident on <span class="math inline">\(T_i\)</span> in the DSG is now incident on the relevant event of <span class="math inline">\(T_i\)</span> in the USG, e.g.,if <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) exists in <span class="math inline">\(H\)</span>, a read-dependency edge is added from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) in the USG.</li>
<li>Finally, consecutive events in <span class="math inline">\(T_i\)</span> are connected by order edges, e.g., if an action (e.g., SQL statement) reads object <span class="math inline">\(y_j\)</span> and immediately follows a write on object <span class="math inline">\(x\)</span> in transaction <span class="math inline">\(T_i\)</span>, we add an order-edge from <span class="math inline">\(w_i(x_i)\)</span> to <span class="math inline">\(r_i(y_j)\)</span>. These edges are needed to maintain the order of events in a transaction; we denote such order edges between events <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> as <span class="math inline">\(p \stackrel{\text{order}}{\longrightarrow} q\)</span>.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{align*}
H_{non-2L}: w_1(x_1) &amp;\\
            w_1(y_1) &amp;\\
            c_1      &amp;\\
            w_2(y_2) &amp;\\
            w_2(x_2) &amp;\\
            w_2(z_2) &amp;\\
            r_3(x_2) &amp;\\
            w_3(z_3) &amp;\\
            r_3(y_1) &amp;\\
            c_2      &amp;\\
            c_3      &amp;\\
[x_1 \ll x_2, y_1 \ll y_2, z_2 \ll z_3]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T1 --&gt;|ww| T2;
  T1 --&gt;|wr| T3;
  T2 --&gt;|wr,ww| T3;
  T3 -.-&gt;|rw| T2;
</code></pre>
<pre><code class=" mermaid">graph LR;
  T1 --&gt;|ww| T2;
  T1 --&gt;|wr| r3_y1;
  T2 --&gt;|wr| r3_x2;
  T2 --&gt;|ww| w3_z3;
  r3_x2 --&gt;|order| w3_z3;
  w3_z3 --&gt;|order| r3_y1;
  r3_y1 -.-&gt;|rw| T2;
</code></pre>
<p>Since the lock-monotonicity property is defined from the perspective of a particular transaction <span class="math inline">\(T_i\)</span> as it executes, we define PL-2L with respect to <span class="math inline">\(T_i\)</span>. Isolation Level PL-2L for transaction <span class="math inline">\(T_i\)</span> is defined such that phenomena G1 and G-monotonic are disallowed:</p>
<p><strong>G-monotonic: Monotonic Reads.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G-monotonic for transaction <span class="math inline">\(T_i\)</span> if there exists a cycle in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span> containing <strong>exactly one anti-dependency edge from a read node</strong> <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) to some transaction node <span class="math inline">\(T_k\)</span> (and any number of order or dependency edges).</p>
<p>Disallowing phenomenon G-monotonic is identical to the lock-monotonicity property given above and their equivalence can be proved in a way similar to Theorem 2+ where we showed that the no-depend-misses condition and disallowing G-single are identical.</p>
<p>Since PL-2L is weaker than PL-2+, it's easy to find a history that breaks G-single but doesn't break G-monotonic. Indeed, by merely changing the sequence of <span class="math inline">\(r_3(y_1)\)</span> and <span class="math inline">\(r_3(x_2)\)</span> in <span class="math inline">\(H_{non-2L}\)</span>, the resulting history <span class="math inline">\(H_{non-2L}^\prime\)</span> will not breach G-monotonic, yet it will still breach G-single.</p>
<p><span class="math display">\[\begin{align*}
H_{non-2L}^\prime: w_1(x_1) &amp;\\
                   w_1(y_1) &amp;\\
                   c_1      &amp;\\
                   w_2(y_2) &amp;\\
                   w_2(x_2) &amp;\\
                   w_2(z_2) &amp;\\
                   r_3(y_1) &amp;\\
                   w_3(z_3) &amp;\\
                   r_3(x_2) &amp;\\
                   c_2      &amp;\\
                   c_3      &amp;\\
[x_1 \ll x_2, y_1 \ll y_2, z_2 \ll z_3]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T1 --&gt;|ww| T2;
  T1 --&gt;|wr| r3_y1;
  T2 --&gt;|wr| r3_x2;
  T2 --&gt;|ww| w3_z3;
  r3_y1 --&gt;|order| w3_z3;
  w3_z3 --&gt;|order| r3_x2;
  r3_y1 -.-&gt;|rw| T2;
</code></pre>
<h4 id="consistency-guarantees-for-predicate-based-reads-at-pl-2l">Consistency Guarantees for Predicate-based Reads at PL-2L</h4>
<p>To enhance the guarantees for predicate-based reads in PL-2, the author suggests introducing two phenomenons, G1-predA and G1-predB. By disallowing G1-predA, indivisibility is ensured with respect to any predicate-based write. Similarly, disallowing G1-predB guarantees indivisibility with respect to all transaction writes of a transaction. The following consistency guarantees can also be provided to such reads:</p>
<ul>
<li>If a predicate-based read observes the effects of transaction <span class="math inline">\(T_i\)</span>, it observes the complete effects of <span class="math inline">\(T_i\)</span> and all transactions that <span class="math inline">\(T_i\)</span> depends on. This guarantee is provided by level PL-2L because of the following reason.
<ul>
<li>When a transaction <span class="math inline">\(T_i\)</span> performs a read based on a predicate <span class="math inline">\(P\)</span>, we represent this read event, <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>, in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span> by a single read node; this node captures conflicts with respect to all object versions accessed by <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>. Since G-monotonic ensures that there is no single anti-dependency cycle originating from <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>, PL-2L ensures that this event does not miss the effects of some transaction <span class="math inline">\(T_j\)</span> that it depends on, i.e., <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> observes a consistent view of the database (assuming that transactions modify the database consistently).</li>
<li>In the extreme case, when transaction <span class="math inline">\(T_i\)</span> contains only one action, the whole transaction observes a consistent database state, i.e., we get isolation level PL-2+.</li>
<li>Isolation level PL-2+ provides stronger guarantees for normal and predicate-based reads; it ensures that if a read by transaction <span class="math inline">\(T_j\)</span> observes <span class="math inline">\(T_i\)</span>'s effects, <strong>all</strong> reads by <span class="math inline">\(T_j\)</span> observe the complete effects of <span class="math inline">\(T_i\)</span> and all transactions that <span class="math inline">\(T_i\)</span> depends on.</li>
</ul></li>
<li>Each predicate-based read executes as a PL-3 transaction. While this guarantee is not provided by PL-2L by default, it can be achieved by treating each predicate-based read as a sub-transaction that requires PL-3. For a more in-depth understanding and details on this approach, refer to the original paper.</li>
<li>We can also provide guarantees to predicate-based writes such that the version set of such operations is consistent. For this purpose, we can treat predicate-based writes as predicate-based reads and add the corresponding edges in the USG for these operations, e.g., if transaction <span class="math inline">\(T_i\)</span> performs <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span> and <span class="math inline">\(\operatorname{Vset}(P)\)</span> contains <span class="math inline">\(x_j\)</span>, we can treat <span class="math inline">\(w_i(P:\operatorname{Vset}(P))\)</span> as a predicate-based read, <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span>, and add a read-dependency edge from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(r_i(P:\operatorname{Vset}(P))\)</span> in the USG.</li>
</ul>
<h3 id="snapshot-isolation">Snapshot Isolation</h3>
<p>Snapshot Isolation was first defined in <a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels, by Hal Berenson, Phil Bernstein, Jim Gray, Jim Melton, Elizabeth O'Neil and Patrick O'Neil</a>, but the definition in is both informal and operational: it comes very close to describing how an implementation would work.</p>
<p><strong>Snapshot Isolation.</strong> A transaction <span class="math inline">\(T_1\)</span> executing with Snapshot Isolation always reads data from a <strong>snapshot</strong> of committed data valid as of the (logical) time <span class="math inline">\(T_1\)</span> started, called the start-timestamp. (The snapshot could be at the time when <span class="math inline">\(T_1\)</span> started or some point in logical time before it.) Updates of other transactions active after <span class="math inline">\(T_1\)</span> started are not visible to <span class="math inline">\(T_1\)</span>. When <span class="math inline">\(T_1\)</span> is ready to commit, it is assigned a commit-timestamp and allowed to commit if no other concurrent transaction <span class="math inline">\(T_2\)</span> (i.e., one whose active period (start-timestamp, commit-timestamp) overlaps with that of <span class="math inline">\(T_1\)</span>) has already written data that <span class="math inline">\(T_1\)</span> intends to write; this is called the First-committer-wins rule to prevent lost updates.</p>
<p>Snapshot isolation offers several key features:</p>
<ul>
<li>Snapshot isolation ensures that the objects read by a transaction represent a consistent state of the data at some point in time before the transaction began.</li>
<li>First-committer-wins.</li>
<li>Imagine a two-dimensional table with time on the x-axis and objects on the y-axis. Suppose a committed transaction has an active period of t1, t2, and t3, and writes to objects x and y. This results in marking the points (t1, x), (t1, y), (t2, x), ..., (t3, y) black on the table. Snapshot isolation guarantees that no point will be marked black twice. I refer to this principle as the "<strong>no-time-objects conflicts</strong>" rule.</li>
</ul>
<h4 id="specification-2">Specification</h4>
<p><strong>Time-Precedes Order.</strong> The time-precedes order, <span class="math inline">\(\prec_t\)</span>, is a partial order specified for history <span class="math inline">\(H\)</span> such that:</p>
<ul>
<li><span class="math inline">\(s_i \prec_t c_i\)</span>, i.e., the start point of a transaction precedes its commit point.</li>
<li>for all <span class="math inline">\(i\)</span> and <span class="math inline">\(j\)</span>, if the scheduler chooses <span class="math inline">\(T_j\)</span>'s start point after <span class="math inline">\(T_i\)</span>'s commit point, we have <span class="math inline">\(c_i \prec_t s_j\)</span>; otherwise, we have <span class="math inline">\(s_j \prec_t c_i\)</span>.</li>
</ul>
<p><strong>Concurrent Transactions.</strong> Two transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> are concurrent if <span class="math inline">\(s_i \prec_t c_j\)</span> and <span class="math inline">\(s_j \prec_t c_i\)</span>. Thus, concurrent transactions overlap; neither starts after the other one commits.</p>
<p>To capture the system's choice of ordering start and commit events of different transactions, we include the time-precedes order in a history (along with the version order and the partial order of events). For convenience, in our examples we will <strong>only</strong> show time-precedes constraints of the type <span class="math inline">\(c_i \prec_t s_j\)</span>; <strong>no relationship is shown for a pair of concurrent transactions</strong> <span class="math inline">\(T_a\)</span> and <span class="math inline">\(T_b\)</span>, i.e., <span class="math inline">\(s_a \prec_t c_b\)</span> and <span class="math inline">\(s_b \prec_t c_a\)</span> holds for these cases. Please notice an important point: the order of events in the history does not specify the relationship between commit and start points of transactions.</p>
<p><strong>Start-Depends.</strong> <span class="math inline">\(T_j\)</span> start-depends on <span class="math inline">\(T_i\)</span> if <span class="math inline">\(c_i \prec_t s_j\)</span>, i.e., if it starts after Ti commits.</p>
<p><strong>Start-ordered Serialization Graph or SSG.</strong> For a history <span class="math inline">\(H\)</span>, <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains the same nodes and edges as <span class="math inline">\(\operatorname{DSG}(H)\)</span> along with start-dependency edges.</p>
<p>Level PL-SI proscribes G1 and G-SI, and property G-SI consists of G-SIa and G-SIb:</p>
<ul>
<li><strong>G-SIa: Interference.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G-SIa if <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains a read/write-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span> <strong>without</strong> there also being a start-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span>.</li>
<li><strong>G-SIb: Missed Effects.</strong> A history <span class="math inline">\(H\)</span> exhibits phenomenon G-SIb if <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains a directed cycle with <strong>exactly one anti-dependency edge</strong>. G-SIb is similar to condition G-single but provides stronger guarantees because of the extra start-dependency edges in the SSG.</li>
</ul>
<p>We now show that our specification for level PL-SI is correct. A history <span class="math inline">\(H\)</span> consisting of committed transactions executes under Snapshot Isolation iff G1 and G-SI are disallowed.</p>
<ul>
<li>First, we can formally redefine Snapshot Isolation using two distinct properties, Snapshot Read and Snapshot Write. These properties, when combined, provide a complete definition of Snapshot Isolation.
<ul>
<li><strong>Snapshot Write.</strong> If <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> are concurrent, they cannot both modify the same object. That is, if <span class="math inline">\(w_i(x_i)\)</span> and <span class="math inline">\(w_j(x_j)\)</span> both occur in history <span class="math inline">\(H\)</span>, then either <span class="math inline">\(c_i \prec_t s_j\)</span> or <span class="math inline">\(c_j \prec_t s_i\)</span>. This is the first-committer-wins property.</li>
<li><strong>Snapshot Read.</strong> All reads performed by a transaction <span class="math inline">\(T_i\)</span> That is, if <span class="math inline">\(r_i(x_j)\)</span> occurs in history <span class="math inline">\(H\)</span>, then:
<ul>
<li><ol type="1">
<li><span class="math inline">\(c_j \prec_t s_i\)</span>, and</li>
</ol></li>
<li><ol start="2" type="1">
<li>if <span class="math inline">\(w_k(x_k)\)</span> also occurs in <span class="math inline">\(H(j \neq k)\)</span>, then either</li>
</ol>
<ul>
<li>(2a) <span class="math inline">\(s_i \prec_t c_k\)</span>, or</li>
<li>(2b) <span class="math inline">\(c_k \prec_t s_i\)</span> and <span class="math inline">\(x_k \ll x_j\)</span></li>
</ul></li>
<li>My understanding of snapshot reads is that transaction <span class="math inline">\(T_i\)</span> always reads the latest committed state of the database at a slightly earlier time, <span class="math inline">\(s_i - \delta\)</span>. Here, <span class="math inline">\(\delta\)</span> represents an extremely short duration that can often be disregarded, as it is typically less than 1 nanosecond.</li>
</ul></li>
</ul></li>
<li>Next, we prove that if G1 and G-SI are disallowed for history <span class="math inline">\(H\)</span>, <span class="math inline">\(H\)</span> must have executed under Snapshot Isolation.
<ul>
<li>Suppose Snapshot Write is not satisfied. Then <span class="math inline">\(H\)</span> contains two concurrent transactions <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> such that one of them, say <span class="math inline">\(T_i\)</span>, overwrites <span class="math inline">\(T_j\)</span>'s modification of some object <span class="math inline">\(x\)</span>. This implies that a write-dependency edge exists from <span class="math inline">\(T_j\)</span> to <span class="math inline">\(T_i\)</span>, but no start-dependency edge, which violates G-SIa. Therefore, the Snapshot Write property is satisfied.</li>
<li>Now suppose that the Snapshot Read property is violated.
<ul>
<li>Property G-SIa guarantees that a transaction can only observe modifications of transactions that committed before it started, this handles properties (1) and (2a) of Snapshot Read.</li>
<li>Now we consider the other part of Snapshot Read concerning missed updates (Snapshot Read 2b). Suppose transaction <span class="math inline">\(T_i\)</span> reads <span class="math inline">\(x\)</span> but does not observe the updates to <span class="math inline">\(x\)</span> made by transactions that committed before <span class="math inline">\(T_i\)</span> started; assume <span class="math inline">\(T_k\)</span> made the first of these updates. This means that there exists an anti-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_k\)</span>. Furthermore, since <span class="math inline">\(c_k \prec_t s_i\)</span>, there exists a start-dependency edge from <span class="math inline">\(T_k\)</span> to <span class="math inline">\(T_i\)</span>. Therefore, phenomenon G-SIb exists in the history, which is a contradiction.</li>
</ul></li>
</ul></li>
<li>Lastly, we prove that if a history <span class="math inline">\(H\)</span> executes under Snapshot Isolation, G1 and G-SI are disallowed.
<ul>
<li>It is straightforward to determine that both G1a and G1b are disallowed.</li>
<li>Suppose G-SIa is allowed, i.e., there is a read/write-dependency from some <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span> without a corresponding start-dependency. If there is no start-dependency, <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span> must be concurrent and neither a read-dependency (by Snapshot Read property) nor a write-dependency (by Snapshot Write property) can exist between <span class="math inline">\(T_i\)</span> and <span class="math inline">\(T_j\)</span>. So we have a contradiction and G-SIa must be disallowed.</li>
<li>Suppose G1c is allowed, then <span class="math inline">\(\operatorname{SSG}(H)\)</span> contains a cycle with 0 anti-dependency edges. Let this cycle have the form <span class="math inline">\(\langle T_1, T_2, T_3, \ldots, T_n, T_1\rangle\)</span>. Under PL-SI, if there is a dependency edge (i.e., start/read/write-dependency) from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_{i+1}\)</span>, we must have <span class="math inline">\(c_i \prec_t s_{i+1} \prec_t c_{i+1}\)</span> and hence <span class="math inline">\(c_i \prec_t c_{i+1}\)</span>. Thus, we get <span class="math inline">\(c_1 \prec_t c_2 \prec_t \ldots \prec_t c_1\)</span>, which is impossible, and therefore G1c is disallowed.</li>
<li>Suppose G-SIb is allowed, i.e., there is a cycle with exactly one anti-dependency edge. Let this cycle have the form <span class="math inline">\(\langle T_1, T_2, T_3, \ldots, T_n, T_1\rangle\)</span>. Without loss of generality, suppose this edge is from <span class="math inline">\(T_1\)</span> to <span class="math inline">\(T_2\)</span> and the rest are dependency edges. Then we have: <span class="math inline">\(s_1 \prec_t c_2 \prec_t c_3 \prec_t \ldots \prec_t c_n \prec_t s_1\)</span>, i.e., <span class="math inline">\(s_1 \prec_t s_1\)</span>, which again is impossible, and therefore G-SIb is disallowed.
<ul>
<li>Under PL-SI, if there is an anti-dependency edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span>, then <span class="math inline">\(s_i \prec_t c_j\)</span>. This is because an anti-dependency edge implies that <span class="math inline">\(T_i\)</span> did not see <span class="math inline">\(T_j\)</span>'s update. Therefore, we cannot have <span class="math inline">\(c_j \prec_t s_i\)</span>. By property (2) of <strong>Time-Precedes Order</strong>, we must have <span class="math inline">\(s_i \prec_t c_j\)</span>.</li>
<li>Under PL-SI, if there is a dependency edge (i.e., start/read/write-dependency) from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_{i+1}\)</span>, we must have <span class="math inline">\(c_i \prec_t s_{i+1} \prec_t c_{i+1}\)</span>.</li>
</ul></li>
</ul></li>
</ul>
<h4 id="discussion-1">Discussion</h4>
<p>Snapshot Isolation is incomparable with PL-3. It both accepts some non-serializable histories, and rejects certain serializable histories.</p>
<ul>
<li>Snapshot Isolation accepts some non-serializable histories.</li>
<li>Snapshot Isolation rejects certain serializable histories:
<ul>
<li>Some serializable histories are rejected because of the Snapshot Write property. This property was introduced to rule out lost updates; however, it also prevents blind writes by concurrent transactions. (Recall that a blind write occurs when a transaction modifies an object without first reading it.) For example, <span class="math inline">\(H_{blind-nonSI}\)</span> is not permitted by Snapshot Isolation (phenomenon G-SIa occurs) but is allowed by PL-3.</li>
<li>The Snapshot Read property also rules out certain serializable histories. It prohibits a transaction <span class="math inline">\(T_j\)</span> from reading a modification made by a transaction <span class="math inline">\(T_i\)</span> that committed after the start point chosen for <span class="math inline">\(T_j\)</span> or from missing updates of transactions that committed before <span class="math inline">\(T_j\)</span>'s start point. <span class="math inline">\(H_{serial-nonSI}\)</span> is an example, it is serializable in the order <span class="math inline">\(T_0, T_2, T_1\)</span> but Snapshot Isolation disallows it since <span class="math inline">\(T_2\)</span> misses <span class="math inline">\(T_1\)</span>'s updates even though <span class="math inline">\(c_1 \prec_t s_2\)</span>.
<ul>
<li>Note that the system could have chosen a different time-precedes order (e.g., in consonance with the serial order) and allowed the above history. This is similar to the case with version orders where the database system could choose a version order that allows a history to be serializable.</li>
</ul></li>
<li><strong>Real Time Guarantees.</strong> The definition of Snapshot Isolation has a notion of logical time that we have captured with the time-precedes order. If this ordering is consistent with real-time, an application can be provided useful guarantees that are not provided by PL-2+ or even PL-3.</li>
</ul></li>
</ul>
<p><span class="math display">\[\begin{align*}
H_{blind-nonSI}: r_1(x_0) &amp;\\
                 r_2(x_0) &amp;\\
                 w_1(z_1) &amp;\\
                 w_2(z_2) &amp;\\
                 c_1      &amp;\\
                 c_2      &amp;\\
[z_1 \ll z_2; c_0 \prec_t s_1, c_0 \prec_t s_2]
\end{align*}\]</span></p>
<p><span class="math display">\[\begin{align*}
H_{serial-nonSI}: w_1(x_1) &amp;\\
                  c_1      &amp;\\
                  r_2(x_0) &amp;\\
                  c_2      &amp;\\
[x_0 \ll x_1; c_0 \prec_t s_1, c_1 \prec_t s_2]
\end{align*}\]</span></p>
<h3 id="forward-consistent-view">Forward Consistent View</h3>
<p>We define an isolation level called Forward Consistent View or PL-FCV by precluding G1 and G-SIb. PL-FCV is strictly stronger than PL-2+ because G-SIb is strictly stronger than G-single.</p>
<p>In the opening of the section titled "Specifications for Intermediate Isolation Levels," the author presents a graph called "A Partial Order to Relate Various Isolation Levels." According to this graph, PL-FCV is considered weaker than PL-3, implying that all histories allowed by PL-3 should also be permitted by PL-FCV. However, I believe the author's assertion is incorrect. I identified a specific history that is permitted by PL-3 but not by PL-FCV, which contradicts the author's claim.</p>
<p><span class="math display">\[\begin{align*}
H_{FCV-nonSer}: w_0(x_0) &amp;\\
                c_0      &amp;\\
                w_1(x_1) &amp;\\
                c_1      &amp;\\
                r_2(x_0) &amp;\\
                c_2      &amp;\\
[x_0 \ll x_1; c_0 \prec_t s_1, c_0 \prec_t s_2, c_1 \prec_t s_2]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T0 --&gt;|ww,s| T1;
  T0 --&gt;|wr,s| T2;
  T1 --&gt;|s| T2;
  T2 -.-&gt;|rw| T1;
</code></pre>
<p>The history <span class="math inline">\(H_{FCV-nonSer}\)</span> can be serialized as <span class="math inline">\(T_0, T_2, T_1\)</span>, yet it is not permitted by PL-FCV. The reason for this disallowance is related to "time": <span class="math inline">\(T_2\)</span> reads a stale version of object <span class="math inline">\(x\)</span>, specifically <span class="math inline">\(x_0\)</span>.</p>
<h3 id="monotonic-snapshot-reads">Monotonic Snapshot Reads</h3>
<h3 id="cursor-stability">Cursor Stability</h3>
<h3 id="update-serializability">Update Serializability</h3>
<p>In this section, we present an isolation level, PL-3U, for <strong>read-only transactions</strong> that is stronger than PL-2+ but weaker than serializability.</p>
<h4 id="specification-3">Specification</h4>
<p><strong>No-update-conflict-misses.</strong> If <span class="math inline">\(T_i\)</span> depends on <span class="math inline">\(T_j\)</span>, it must not miss the effects of <span class="math inline">\(T_j\)</span> and all update transactions that <span class="math inline">\(T_j\)</span> <strong>depends or anti-depends on</strong>. Note that the no-update-conflict-misses condition imposes stronger constraints than the no-depend-misses condition since it takes anti-dependencies into account as well. The no-update-conflict-misses condition is sufficient to ensure PL-3U for a transaction <span class="math inline">\(T_i\)</span> (<span class="math inline">\(T_i\)</span> could be a read-only transaction).</p>
<p><strong>G-update: Single Anti-Dependency Cycles with Update Transactions.</strong> A history <span class="math inline">\(H\)</span> and transaction <span class="math inline">\(T_i\)</span> show phenomenon G-update if a DSG containing all update transactions of <span class="math inline">\(H\)</span> and transaction <span class="math inline">\(T_i\)</span> contains a cycle with <strong>1 or more</strong> anti-dependency edges.</p>
<p>A transaction <span class="math inline">\(T_i\)</span> is provided PL-3U if phenomena G1 and G-update are disallowed; we can prove the equivalence of G-update and the no-update-conflict-misses using an argument similar to the one presented for Theorem 2+.</p>
<h4 id="differentiating-between-levels-pl-2-and-pl-3u">Differentiating Between Levels PL-2+ and PL-3U</h4>
<p>PL-2+ ensures that a transaction observes a <strong>consistent</strong> state of the database and PL-3U states that the transaction observes a <strong>serializable</strong> state of the database.</p>
<ul>
<li>In the section "Why G-single Emphasizes Exactly One Anti-dependency Edge", I mention <span class="math inline">\(H_{anti-dependency-edges}\)</span>. <span class="math inline">\(T_1\)</span> is the exactly one read transaction that commits at PL-2+ in the history. Even though the final state <span class="math inline">\(x_0, y_3\)</span> reached by serially executing a specific subset of transactions from <span class="math inline">\(H_{anti-dependency-edges}\)</span> and read by <span class="math inline">\(T_1\)</span> is not serializable, it is consistent.</li>
<li><span class="math inline">\(H_{non-3U}\)</span> is another history that can distinguish between PL-2+ and PL-3U. <span class="math inline">\(H_{non-3U}\)</span> depicts what occurred in a stock reporting system. We know that stock prices will not change after the stock market has closed. We assume that there is an object called <span class="math inline">\(\text{Market-status}\)</span> that indicates whether the market is open or not. Suppose there are companies <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> whose stock prices are always the same. Transactions <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_2\)</span> check that the market is open and update the stock prices to be 50 and 55 respectively and transaction <span class="math inline">\(T_3\)</span> closes the market. Suppose that a read-only transaction <span class="math inline">\(T_q\)</span> reads the stock market status and the stock prices of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>. PL-2+ guarantees that <span class="math inline">\(T_q\)</span> will see the same prices for <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, e.g., the two observed values will be 50 or both will be 55. However, with PL-2+, it is possible that <span class="math inline">\(T_q\)</span> observes the stock market to be closed and reads the stock prices to be 50, i.e., it observes T3's updates but misses the effects of transaction <span class="math inline">\(T_2\)</span> that <span class="math inline">\(T_3\)</span> anti-depends on; this is what happens in history <span class="math inline">\(H_{non-3U}\)</span>.</li>
</ul>
<p><span class="math display">\[\begin{align*}
H_{non-3U}: r_1(M_0,Open)   &amp;\\
            w_1(X_1,50)     &amp;\\
            w_1(Y_1,50)     &amp;\\
            c_1             &amp;\\
            r_2(M_0,Open)   &amp;\\
            w_2(X_2,55)     &amp;\\
            w_2(Y_2,55)     &amp;\\
            c_2             &amp;\\
            w_3(M_3,Closed) &amp;\\
            c_3             &amp;\\
            r_q(M_3,Closed) &amp;\\
            r_q(X_1,50)     &amp;\\
            r_q(Y_1,50)     &amp;\\
            c_q             &amp;\\
[M_0 \ll M_3, X_1 \ll X_2, Y_1 \ll Y_2]
\end{align*}\]</span></p>
<pre><code class=" mermaid">graph LR;
  T1 --&gt;|ww| T2;
  T1 -.-&gt;|rw| T3;
  T1 --&gt;|wr| Tq;
  T2 -.-&gt;|rw| T3;
  T3 --&gt;|wr| Tq;
  Tq -.-&gt;|rw| T2;
</code></pre>
<h4 id="differentiating-between-levels-pl-3u-and-pl-3">Differentiating Between Levels PL-3U and PL-3</h4>
<p>Consider a variation on the above stock-market example that shows a history that executes at PL-3U but not at PL-3. Notice that we are no longer maintaining the invariant that the stock prices of <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span> are the same.</p>
<p><span class="math display">\[\begin{align*}
H_{3U}: r_1(M_0,Open) &amp;\\
        w_1(X_1,50)   &amp;\\
        w_1(Y_1,50)   &amp;\\
        c_1           &amp;\\
        r_4(M_0,Open) &amp;\\
        w_4(X_4,70)   &amp;\\
        c_4           &amp;\\
        r_5(M_0,Open) &amp;\\
        w_5(Y_5,75)   &amp;\\
        c_5           &amp;\\
        r_a(X_4,70)   &amp;\\
        r_a(Y_1,50)   &amp;\\
        c_a           &amp;\\
        r_b(X_1,50)   &amp;\\
        r_b(Y_5,75)   &amp;\\
        c_b           &amp;\\
[X_1 \ll X_4, Y_1 \ll Y_5]
\end{align*}\]</span></p>
<p>Transaction <span class="math inline">\(T_a\)</span> observes the updates of <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_4\)</span> but misses <span class="math inline">\(T_5\)</span>'s effects. Transaction <span class="math inline">\(T_b\)</span> reads the updates of <span class="math inline">\(T_1\)</span> and <span class="math inline">\(T_5\)</span> but misses <span class="math inline">\(T_4\)</span>'s effects. Thus, each read-only transaction "forces" transactions <span class="math inline">\(T_4\)</span> and <span class="math inline">\(T_5\)</span> to be serialized in the opposite order to what the other transaction requires: transaction <span class="math inline">\(T_a\)</span> forces the serialization order <span class="math inline">\(\langle T_1, T_4, T_a, T_5\rangle\)</span> whereas <span class="math inline">\(T_b\)</span> forces an order where <span class="math inline">\(T_5\)</span> must be serialized before <span class="math inline">\(T_4\)</span>, e.g., <span class="math inline">\(\langle T_1, T_5, T_b , T_4\rangle\)</span>.</p>
<p>The DSG of history <span class="math inline">\(H_{3U}\)</span> is shown below (for simplicity, we do not show <span class="math inline">\(T_1\)</span>):</p>
<pre><code class=" mermaid">graph LR;
  T4 --&gt;|wr| Ta;
  Ta -.-&gt;|rw| T5;
  T5 --&gt;|wr| Tb;
  Tb -.-&gt;|rw| T4;
</code></pre>
<p>The DSG contains a cycle but if we remove either <span class="math inline">\(T_a\)</span> or <span class="math inline">\(T_b\)</span> from the graph, the cycle no longer exists. Thus, each read-only transaction is at level PL-3U but the whole system is not serializable. If clients/entities that execute <span class="math inline">\(T_a\)</span> and <span class="math inline">\(T_b\)</span> communicate with each other, they may be confused about the relative order in which the stock prices went up. Thus, this departure from serializability matters only when clients of read-only transactions communicate with each other directly; otherwise, PL-3U is as good as serializability.</p>
<h3 id="intermediate-degrees-for-running-transactions">Intermediate Degrees for Running Transactions</h3>
<p><strong>E-single: Single Anti-dependency Cycles at Runtime.</strong> A history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span> exhibit phenomenon E-single if <span class="math inline">\(\operatorname{DTG}(H,T_i)\)</span> contains a directed cycle involving <span class="math inline">\(T_i\)</span> with exactly one anti-dependency edge.</p>
<p><strong>E-monotonic: Monotonic Reads at Runtime.</strong> A history <span class="math inline">\(H\)</span> and an executing transaction <span class="math inline">\(T_i\)</span> exhibit phenomenon E-monotonic if there is a cycle in <span class="math inline">\(\operatorname{USG}(H,T_i)\)</span> containing exactly one anti-dependency edge from a read node <span class="math inline">\(r_i(x_j)\)</span> (or <span class="math inline">\(r_i(P:x_j,\ldots)\)</span>) to some transaction node <span class="math inline">\(T_k\)</span> (and any number of order or dependency edges).</p>
<p>In a similar manner, other levels such EPL-SI, EPL-FCV, EPL-CS, EPL-MSR and EPL-3U can be defined by extending the relevant graph and phenomena conditions.</p>
<h2 id="optimistic-implementations-for-client-server-systems">Optimistic Implementations for Client-Server Systems</h2>
<p>Our schemes have been designed for a system where database objects may be <strong>distributed over multiple servers and clients</strong> may cache some of the objects on their machines for better performance.</p>
<p>Further reading materials:</p>
<ul>
<li>CLOCC, Clock-based Lazy Optimistic Concurrency Control: Work well for environments where all operations are executed by clients.
<ul>
<li><a target="_blank" rel="noopener" href="https://citeseerx.ist.psu.edu/doc/10.1.1.72.8778">A. Adya. Transaction Management for Mobile Objects Using Optimistic Concurrency Control. Master’s thesis, Massachusetts Institute of Technology, Jan. 1994.</a></li>
<li><a target="_blank" rel="noopener" href="https://users.cs.utah.edu/~stutsman/cs6963/public/papers/thor.pdf">A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks</a></li>
<li><a target="_blank" rel="noopener" href="https://dspace.mit.edu/handle/1721.1/10762">R. Gruber. Optimism vs. Locking: A Study of Concurrency Control for Client-Server Object-Oriented Databases</a></li>
</ul></li>
<li>Weak-CLOCC: Our optimistic mechanism for providing PL-2.</li>
<li>AACC, Asynchronous Avoidance-based Cache Consistency: Outperform in environments where servers may perform part of the work.</li>
<li>Mechanisms perform well in workloads where there are hotspots.
<ul>
<li>Field calls, <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/588111.588126">A. Reuter. Concurrency on High-Traffic Data Elements</a>.</li>
<li>Escrow reads, <a target="_blank" rel="noopener" href="https://www.cs.umb.edu/~poneil/EscrowTM.pdf">P. O'Neil. The Escrow Transactional Method</a></li>
</ul></li>
</ul>
<h3 id="serializability-for-committed-transactions-clocc">Serializability for Committed Transactions: CLOCC</h3>
<p>I aim to connect Adya's CLOCC mechanism and theoretical isolation levels framework to gain a better understanding of CLOCC and the spectrum of isolation levels in this section.</p>
<ul>
<li>The master's thesis "Transaction Management for Mobile Objects Using Optimistic Concurrency Control" by Atul Adya introduces CLOCC, an optimistic concurrency control mechanism that ensures serializability.</li>
<li>Adya's PhD dissertation "Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions" presents a theoretical framework for defining isolation levels.</li>
<li>However, these two works do not seem to have been connected well in subsequent literature.</li>
</ul>
<h4 id="the-two-phase-commit-protocol-in-thor">The Two-Phase Commit Protocol in Thor</h4>
<figure>
<img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/the-two-phase-commit-protocol-in-thor.png" srcset="/img/loading.gif" lazyload alt="" /><figcaption>The two phase commit proto col in Thor</figcaption>
</figure>
<ul>
<li>When an application commits a transaction <span class="math inline">\(T\)</span>, the frontend sends the following information to the coordinator server:
<ul>
<li>Read Object Set or ROS - Set of objects read by <span class="math inline">\(T\)</span>.</li>
<li>Modified Object Set or MOS - Set of objects modified by <span class="math inline">\(T\)</span>.</li>
</ul></li>
<li>The coordinator assigns a globally unique timestamp to <span class="math inline">\(T\)</span> and initiates the 2-phase commit protocol.
<ul>
<li>In the first phase of the 2-phase commit protocol, the coordinator sends prepare messages to all participants. Each participant runs a serializability check and sends its vote to the coordinator. If the coordinator receives a yes vote from all participants, it decides to commit the transaction; otherwise, it aborts the transaction. It informs the frontend about the decision and the latter conveys the transaction's commit result to the application.
<ul>
<li>Phase 1 includes two log updates to stable storage, but the optimizations suggested by Stamos can reduce this to a single log update.</li>
</ul></li>
<li>As part of the second phase, the coordinator informs the participants about the transaction's commit result. Each participant logs the coordinator's decision and sends an acknowledgement to the coordinator.</li>
<li>As an optimization, each participant sends invalidation messages to frontends that have cached objects modified by this transaction; these messages ask frontends to flush old copies of the modified objects from their cache. If the currently executing transaction at a frontend has read any of the objects, it is aborted. Thus, invalidation messages prevent transactions from doing wasted work.</li>
</ul></li>
<li>To make the protocol resilient to crashes, each participant must log a prepare record on stable storage before sending its vote to the coordinator. It must also log a commit record on stable storage before sending its acknowledgement message to the coordinator. Similarly, the coordinator needs to log a commit record before informing the application about the commit/abort decision.</li>
<li>Note that the frontend waits only while the first phase of the protocol is being executed. Thus, this phase of the commit protocol is said to have executed in the foreground. The second phase proceeds in the background, i.e., the application does not wait for this phase to be completed.</li>
<li>The messages and log forces involved in committing a transaction are shown above. Numbers indicate the order of messages, i.e., message <span class="math inline">\(i\)</span> precedes message <span class="math inline">\(i+1\)</span>. Messages with the same numbers can be sent in parallel. A force to the backup has a superscript <span class="math inline">\(i/j\)</span> indicating that it is done after receiving message <span class="math inline">\(i\)</span> but before sending message <span class="math inline">\(j\)</span>.</li>
</ul>
<h4 id="a-theorem-for-ros-and-mos-tests">A Theorem for ROS and MOS Tests</h4>
<p>In a distributed system, transactions that have accessed objects at multiple servers must be <strong>serialized in the same order</strong> at all servers, although this order may not necessarily align with the real-world sequence of events. In CLOCC, transactions are serialized in timestamp order where timestamps are taken from real clocks. When a client wants to commit transaction <span class="math inline">\(T\)</span>, it assigns a timestamp <span class="math inline">\(\operatorname{ts}(T)\)</span> that contains the client's local clock value augmented with the client's identity to make it globally unique. The timestamp of each committed transaction <span class="math inline">\(T\)</span> can be viewed as the time when <span class="math inline">\(T\)</span> executed in an equivalent serial schedule <span class="math inline">\(H\)</span>. That is, if <span class="math inline">\(T\)</span> had been executed at time <span class="math inline">\(\operatorname{ts}(T)\)</span> (instantaneously), it would have read the same values as it did while running concurrently with other transactions. The timestamp is <strong>a predictor of the commit order</strong> for validating transactions.</p>
<ul>
<li>We assume that clocks are loosely synchronized, i.e., clocks at different nodes in the network may differ by at most a small skew (say, a few tens of milliseconds). In CLOCC, loose synchronization is needed only for performance reasons and not for correctness.</li>
<li>We assume that server clocks never run backwards, and advance rapidly enough that each transaction can be assigned a distinct timestamp; these assumptions are easy to guarantee.</li>
</ul>
<p>The start-depends conflict from Snapshot Isolation can help in understanding Read Object Set (ROS) and Modified Object Set (MOS) tests more effectively. This is particularly useful when utilizing the Start-ordered Serialization Graph. If the timestamp of transaction <span class="math inline">\(T_i\)</span> is less than the timestamp of transaction <span class="math inline">\(T_j\)</span> (<span class="math inline">\(\operatorname{ts}(T_i) &lt; \operatorname{ts}(T_j)\)</span>), then we draw a Start-Depends edge from <span class="math inline">\(T_i\)</span> to <span class="math inline">\(T_j\)</span>, denoted as <span class="math inline">\(T_i \stackrel{s}{\longrightarrow} T_j\)</span>.</p>
<p>The TM maintains sufficient validation information about prepared and committed transactions by keeping the complete history of committed and prepared transactions sorted by timestamp order. For each prepared or committed transaction <span class="math inline">\(S\)</span>, it keeps an entry in the history list with the following attributes - <span class="math inline">\(\operatorname{MOS}(S)\)</span>, <span class="math inline">\(\operatorname{ROS}(S)\)</span>, <span class="math inline">\(\operatorname{ts}(S)\)</span> and a boolean that indicates whether <span class="math inline">\(S\)</span> is prepared or committed. When transaction <span class="math inline">\(T\)</span> reads object <span class="math inline">\(x\)</span>, a tuple of the form <span class="math inline">\(\langle x, \text{install_ts}\rangle\)</span> is inserted in <span class="math inline">\(\operatorname{ROS}(T)\)</span>; <span class="math inline">\(\text{install_ts}\)</span> is the timestamp of the transaction that has installed the version of <span class="math inline">\(x\)</span> read by <span class="math inline">\(T\)</span>. When <span class="math inline">\(T\)</span> modifies <span class="math inline">\(x\)</span>, a tuple of the form <span class="math inline">\(\langle x, \text{newval}\rangle\)</span> is added to <span class="math inline">\(\operatorname{MOS}(T)\)</span> where <span class="math inline">\(\text{newval}\)</span> is the modified value of <span class="math inline">\(x\)</span>.</p>
<figure>
<img src="http://junbin-hexo-img.oss-cn-beijing.aliyuncs.com/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/transaction-history.png" srcset="/img/loading.gif" lazyload alt="" /><figcaption>Validation using transaction history</figcaption>
</figure>
<p>Suppose transaction <span class="math inline">\(T\)</span> reaches the server for validation such that <span class="math inline">\(\operatorname{ts}(S_i) &lt; \operatorname{ts}(T) &lt; \operatorname{ts}(S_j)\)</span>. Notice that every transaction in the transaction history must be validated against <span class="math inline">\(T\)</span>, not only adjacent transactions.</p>
<ul>
<li>To simplify our algorithm, we arrange the read set to always contain the write set (no blind writes), i.e., if a transaction modifies an object but does not read it, the client enters the object in the read set anyway. As a result, we don't need to consider Direct Write-Depends, since accounting for Direct Read-Depends achieves the same effect when determining whether any cycles exist in the SSG. Thus, we need not consider the following four conflicts:
<ul>
<li><span class="math inline">\(S_i \stackrel{ww}{\longrightarrow} T\)</span></li>
<li><span class="math inline">\(T \stackrel{ww}{\longrightarrow} S_i\)</span></li>
<li><span class="math inline">\(T \stackrel{ww}{\longrightarrow} S_j\)</span></li>
<li><span class="math inline">\(S_j \stackrel{ww}{\longrightarrow} T\)</span></li>
</ul></li>
<li>The following three conflicts are valid because they have the same directions as the start-dependence conflicts in the SSG.
<ul>
<li><span class="math inline">\(S_i \stackrel{wr}{\longrightarrow} T\)</span>
<ul>
<li>However, if transaction <span class="math inline">\(S_i\)</span> is prepared but not yet committed, transaction <span class="math inline">\(T\)</span> should not read versions of objects written by <span class="math inline">\(S_i\)</span>. If <span class="math inline">\(T\)</span> reads versions of objects written by <span class="math inline">\(S_i\)</span> before <span class="math inline">\(S_i\)</span> commits, it would constitute a dirty read if the coordinator ultimately aborts <span class="math inline">\(S_i\)</span>.</li>
</ul></li>
<li><span class="math inline">\(S_i \stackrel{rw}{\longrightarrow} T\)</span></li>
<li><span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_j\)</span></li>
</ul></li>
<li>Since <span class="math inline">\(S_i\)</span> is prepared/committed, it could not have observed <span class="math inline">\(T\)</span>'s updates (there are no dirty reads in CLOCC). In simpler terms, <span class="math inline">\(T \stackrel{wr}{\longrightarrow} S_i\)</span> is not possible. Similarly, <span class="math inline">\(T \stackrel{wr}{\longrightarrow} S_j\)</span> is not possible.</li>
<li>(1) <strong>ROS test.</strong> This test validates the objects that have been read by <span class="math inline">\(T\)</span>. Let <span class="math inline">\(S_k\)</span> be the transaction from which <span class="math inline">\(T\)</span> has read <span class="math inline">\(x\)</span>, i.e., <span class="math inline">\(\operatorname{ts}(S_k)\)</span> is equal to the value of <span class="math inline">\(\text{install_ts}\)</span> in <span class="math inline">\(x\)</span>'s ROS tuple.
<ul>
<li>(1a) If <span class="math inline">\(\operatorname{ts}(S_k) &lt; \operatorname{ts}(S_i)\)</span>, then the transaction manager (TM) verifies that <span class="math inline">\(S_i\)</span> has not modified <span class="math inline">\(x\)</span>. This rule disables <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span>.</li>
<li>(1b) Furthermore, the TM also verifies that <span class="math inline">\(\operatorname{ts}(T)\)</span> is greater than <span class="math inline">\(\operatorname{ts}(S_k)\)</span>. This rule disables <span class="math inline">\(S_j \stackrel{wr}{\longrightarrow} T\)</span>.</li>
</ul></li>
<li>(2) <strong>MOS test</strong>. The TM validates <span class="math inline">\(\operatorname{MOS}(T)\)</span> by verifying that <span class="math inline">\(T\)</span> has not modified any object <span class="math inline">\(y\)</span> that has been read by <span class="math inline">\(S_j\)</span>. This rule disables <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span>.</li>
</ul>
<pre><code class=" mermaid">graph LR;
  Sk --&gt;|s,ww,wr| Si;
  Sk --&gt;|wr| T;
  Si --&gt;|s| T;
  T -.-&gt;|rw| Si;
</code></pre>
<p>SSG when condition (1a) is violated.</p>
<pre><code class=" mermaid">graph LR;
  T --&gt;|s| Sj;
  Sj --&gt;|wr| T;
</code></pre>
<p>SSG when condition (1b) is violated.</p>
<pre><code class=" mermaid">graph LR;
  Si --&gt;|s,ww,wr| T;
  Si --&gt;|wr| Sj;
  T --&gt;|s| Sj;
  Sj -.-&gt;|rw| T;
</code></pre>
<p>SSG when condition (2) is violated.</p>
<h4 id="improvements-to-clocc-to-truncate-the-transaction-history">Improvements to CLOCC to Truncate the Transaction History</h4>
<p>The last section described the validation scheme at an abstract level without considering the space or logging requirements. To cut down on space requirements, the TM needs some way of truncating the transaction history while maintaining sufficient validation information about prepared and committed transactions. <strong>Once a transaction has committed</strong>, its modifications are installed at the relevant servers. At this point, its entry can be deleted from the history list.</p>
<h5 id="validation-against-prepared-transactions">Validation Against Prepared Transactions</h5>
<p>The transaction manager validates incoming transaction <span class="math inline">\(T\)</span> against the set of prepared transactions; this is called the Validation Queue Check (VQ-check).</p>
<p>Since there are no dirty reads in CLOCC, then transaction <span class="math inline">\(T\)</span> will not read any versions written by prepared (but not committed) transactions. Therefore, if there is a prepared transaction <span class="math inline">\(S_i\)</span> such that <span class="math inline">\(\operatorname{ts}(S_i) &lt; \operatorname{ts}(T)\)</span> and <span class="math inline">\(T\)</span> read some objects modified by <span class="math inline">\(S_i\)</span>, then there must be <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span>, which violates (1a) in the ROS test.</p>
<p>In conclusion, the TM performs the ROS test for <span class="math inline">\(T\)</span> against prepared transactions that have a timestamp value less than <span class="math inline">\(\operatorname{ts}(T)\)</span>. To pass the ROS test, <span class="math inline">\(T\)</span> should not have read any object being modified by such a transaction.</p>
<p>Similarly, prepared transactions will not read any version written by <span class="math inline">\(T\)</span>. Therefore, if there is a transaction <span class="math inline">\(S_j\)</span> such that <span class="math inline">\(\operatorname{ts}(T) &lt; \operatorname{ts}(S_j)\)</span> and <span class="math inline">\(S_j\)</span> read some objects modified by <span class="math inline">\(T\)</span>, then there must be <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span>, which violates (2) in the MOS test.</p>
<p>In conclusion, to pass the MOS test, <span class="math inline">\(T\)</span> should not modify any object that has been read by a prepared transaction whose timestamp is greater than <span class="math inline">\(\operatorname{ts}(T)\)</span>.</p>
<ol type="1">
<li>ROS test: If <span class="math inline">\(\operatorname{ts}(S) &lt; \operatorname{ts}(T)\)</span>, then <span class="math inline">\(\operatorname{MOS}(S) \cap \operatorname{ROS}(T) = \phi\)</span>.</li>
<li>MOS test: If <span class="math inline">\(\operatorname{ts}(S) &gt; \operatorname{ts}(T)\)</span>, then <span class="math inline">\(\operatorname{ROS}(S) \cap \operatorname{MOS}(T) = \phi\)</span>.</li>
</ol>
<h5 id="validating-the-ros-against-committed-transactions">Validating the ROS Against Committed Transactions</h5>
<p>Once a transaction has committed, its modifications are installed at the relevant servers. At this point, <strong>its entry can be deleted from the history list</strong>. The TM captures the ROS and MOS information of committed transactions by maintaining two attributes for each object - rstamp and version. The version field of object <span class="math inline">\(x\)</span> stores the timestamp of the transaction that has installed <span class="math inline">\(x\)</span>'s current base version.</p>
<p>The version field of object <span class="math inline">\(x\)</span> truncates modification history of <span class="math inline">\(x\)</span>. It only maintains the timestamp of the transaction that has installed x's current base version. As a result, the TM does not have information about older versions of <span class="math inline">\(x\)</span>; it must abort any incoming transaction that has read an older version of <span class="math inline">\(x\)</span>.</p>
<p>For example, there is no difference between <span class="math inline">\(H_1: w_1(x_1) c_1 w_5 (x_5) c_5\)</span> and <span class="math inline">\(H_2: w_1(x_1) c_1 w_3(x_3) c_3 w_5(x_5) c_5\)</span> when <span class="math inline">\(T_4: r_4(x_1) c_4\)</span> reaches the server in the TM's sight. This is because the version fields in the two histories of <span class="math inline">\(x\)</span> are both 5. While <span class="math inline">\(T_4\)</span> should be aborted in <span class="math inline">\(H_2\)</span> but not in <span class="math inline">\(H_1\)</span>, the TM must abort <span class="math inline">\(T_4\)</span> in both <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span>.</p>
<p>We call the process to validate the ROS against committed transactions the "version check." The pseudocode for the version check is shown as follows:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">% Version Check<br>for each object x in ROS(T) do<br>  if ts(T) &lt; base_version(x) or<br>     install_ts(x) != base_version(x)<br>    Abort T<br></code></pre></td></tr></table></figure>
<p>To perform the version check, the TM first verifies that <span class="math inline">\(T\)</span> does not read any versions from truncated transactions (otherwise the TM does not know if it is safe to commit <span class="math inline">\(T\)</span>). Then, it verifies that an incoming transaction <span class="math inline">\(T\)</span> has read the current base version (which is also the latest version of committed transactions) of each object <span class="math inline">\(x\)</span> in <span class="math inline">\(\operatorname{ROS}(T)\)</span>.</p>
<ul>
<li>The TM aborts <span class="math inline">\(T\)</span> if <code>install_ts(x) &lt; base_version(x)</code> because <span class="math inline">\(T\)</span> has not read the latest version of <span class="math inline">\(x\)</span>. This means there exists <span class="math inline">\(S_i\)</span> such that <code>ts(Si) = base_version(x) &lt; ts(T)</code> and <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span>, which violates ROS test (1a).</li>
<li>We use <code>install_ts(x) != base_version(x)</code> instead of <code>install_ts(x) &gt;= base_version(x)</code> because:
<ul>
<li><span class="math inline">\(T\)</span> will not read any versions from prepared but not yet committed transactions (there are no dirty reads in CLOCC).</li>
<li><code>base_version(x)</code> is the latest version of x which is written by committed transactions.</li>
</ul></li>
</ul>
<h5 id="validating-the-mos-against-committed-transactions">Validating the MOS Against Committed Transactions</h5>
<p>Once a transaction has committed, its modifications are installed at the relevant servers. At this point, <strong>its entry can be deleted from the history list</strong>. The TM captures the ROS and MOS information of committed transactions by maintaining two attributes for each object - rstamp and version. The rstamp attribute denotes the highest timestamp among committed transactions that have read that object.</p>
<p>The rstamp field of object <span class="math inline">\(x\)</span> truncates read history of <span class="math inline">\(x\)</span>. As a result, the TM does not have information about older versions of <span class="math inline">\(x\)</span>; it must abort any incoming transaction that has written an older version of <span class="math inline">\(x\)</span>.</p>
<p>For example, there is no difference between <span class="math inline">\(H_1: w_2(x_2) c_2 w_5(x_5) c_5 r_6(x_5) c_6\)</span> and <span class="math inline">\(H_2: w_2(x_2) c_2 r_4(x_2) c_4 w_5(x_5) c_5 r_6(x_5) c_6\)</span> when <span class="math inline">\(T_3: w_3(x_3) c_3\)</span> reaches the server in the TM's sight. This is because the rstamp fields in the two histories of <span class="math inline">\(x\)</span> are both 5. While <span class="math inline">\(T_3\)</span> should be aborted in <span class="math inline">\(H_2\)</span> but not in <span class="math inline">\(H_1\)</span>, the TM must abort <span class="math inline">\(T_3\)</span> in both <span class="math inline">\(H_1\)</span> and <span class="math inline">\(H_2\)</span>.</p>
<p>We call the process to validate the MOS against committed transactions the "rstamp check." The pseudocode for the rstamp check is shown as follows:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">% Rstamp Check<br>for each object x in MOS(T) do<br>  if ts(T) &lt;= rstamp(x)<br>    Abort T<br></code></pre></td></tr></table></figure>
<ul>
<li>The TM aborts <span class="math inline">\(T\)</span> if <code>ts(T) &lt; rstamp(x)</code>. Without this check, histories like <span class="math inline">\(H_2\)</span> are possible, which violates MOS test (2).</li>
<li>Noticeably, the version of <span class="math inline">\(x\)</span> written by <span class="math inline">\(T\)</span> (which is equal to <code>ts(T)</code>) is greater than the rstamp of <span class="math inline">\(x\)</span>.</li>
</ul>
<h4 id="improvements-to-clocc-to-reduce-space-and-logging-overheads">Improvements to CLOCC to Reduce Space and Logging Overheads</h4>
<h5 id="storing-an-upper-bound-on-the-read-times-of-all-objects">Storing an upper bound on the read times of all objects</h5>
<p>This bound is called the read watermark or <span class="math inline">\(X_r\)</span> for the server. Since the TM has lost the read information for each object, it must assume that all objects at the server were read at time <span class="math inline">\(X_r\)</span>. Thus, to ensure that an update-at-site transaction <span class="math inline">\(T\)</span> does not invalidate a read operation of a committed transaction, the TM has to verify that <span class="math inline">\(\operatorname{ts}(T)\)</span> is greater than <span class="math inline">\(X_r\)</span>. This test is called the Read-watermark Check.</p>
<p>However, lack of per-object information can cause spurious aborts. But we expect such aborts to be rare since loosely synchronized clocks are being used to generate timestamps; transactions reaching a server will usually have timestamp values greater than the read-watermark at that server.</p>
<h5 id="implementing-the-version-field">Implementing the Version Field</h5>
<p>Similar to the previous section, we propose using a single write-watermark <span class="math inline">\(X_w\)</span> to represent the versions of all objects and implement the Write-watermark Check.</p>
<p>However, it is important to note that the Version Check has two conditions: <code>ts(T) &gt;= base_version(x)</code> and <code>install_ts(x) == base_version(x)</code>. If we simplify the second condition to <code>install_ts(x) == write_watermark</code>, then all write transactions would have to be executed sequentially.</p>
<p>Consider the following history <span class="math inline">\(H: w_1(x_1) w_1(y_1) c_1\)</span> and two transactions <span class="math inline">\(T_3: r_3(x_1) w_3(x_3) c_3\)</span> and <span class="math inline">\(T_2: r_2(y_1) w_2(y_2) c_2\)</span>. Suppose <span class="math inline">\(T_3\)</span> and then <span class="math inline">\(T_2\)</span> arrive at the server in that order. After <span class="math inline">\(T_3\)</span> commits, <span class="math inline">\(T_2\)</span> begins processing but will abort because the write-watermark is now 3, and <code>install_ts(y)</code> is 2, which does not equal 3.</p>
<p>This approach would not optimistically achieve serializability. We still need a version field for each object even with the write-watermark approach, but we can use a shorter version field instead of a timestamp. Suppose that the local timestamp and server ID require <span class="math inline">\(n\)</span> and <span class="math inline">\(d\)</span> bits of storage respectively. Then, the version field has a space overhead of <span class="math inline">\(n+d\)</span> bits per object. Another way to implement this attribute is to use a <span class="math inline">\(k\)</span>-bit counter where <span class="math inline">\(k&lt;n+d\)</span>, i.e., every object update causes the version field to increment by 1. The version field implemented using a counter is also referred to as the object's version number or vnum.</p>
<h4 id="the-serial-validation-algorithm">The Serial Validation Algorithm</h4>
<p>The author is proposing two enhancements to the CLOCC database consistency method. Given this, I suggests that three tests (labeled 1a, 1b and 2) should be performed separately on committed transactions and prepared transactions. After performing the three tests on committed and prepared transactions separately, this results in six total test cases:</p>
<ul>
<li>(1a-committed) The Write-watermark Check and the Version Check ensure that transaction <span class="math inline">\(T\)</span> will always read the latest versions installed by committed transactions.</li>
<li>(1b-committed) The Write-watermark Check ensures that <span class="math inline">\(T\)</span>'s timestamp is later than all committed update transactions, so <span class="math inline">\(\operatorname{ts}(T)\)</span> is greater than <span class="math inline">\(\operatorname{ts}(S_k)\)</span> if <span class="math inline">\(T\)</span> reads versions of objects written by transaction <span class="math inline">\(S_k\)</span>.</li>
<li>(2-committed) The Read-watermark Check ensures that transaction <span class="math inline">\(T\)</span>'s timestamp is later than all committed transactions, so there does not exist any committed transaction <span class="math inline">\(S_j\)</span> whose timestamp is later than <span class="math inline">\(T\)</span> and <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span> exists.</li>
<li>(1a-prepared) The ROS test against prepared transactions.</li>
<li>(1b-prepared) Transaction <span class="math inline">\(T\)</span> will not read any versions of objects written by prepared transactions because these versions have not yet been installed.</li>
<li>(2-prepared) The MOS test against prepared transactions.</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs text">// T Enters Validation<br>Lock(VQ-lock)<br>  // Write-watermark Check<br>  if ts(T) &lt; Xw<br>    Ask the coordinator to retry with a timestamp greater than Xw<br>  // Read-watermark Check<br>  if ts(T) &lt; Xr and MOS(T) is not empty set<br>    // A non-read-only-at-site transaction has failed the read-watermark test.<br>    Ask the coordinator to retry with a timestamp greater than Xr<br>  // Version Check<br>  for each object x in ROS(T) do<br>    Read-lock(x)<br>      if vnum(x) != vnum(base(x))<br>        Abort T<br>    Unlock(x)<br>  // Validation Queue Check<br>    // ROS test<br>    if ts(S) &lt; ts(T) and (MOS(S) and ROS(T) have at least one element in common)<br>      Abort T<br>    // MOS test<br>    if ts(S) &gt; ts(T) and (MOS(T) and ROS(S) have at least one element in common)<br>      Ask the coordinator to raise T&#x27;s timestamp<br>  // Validation Succeeded<br>  if MOS(T) is empty set<br>    Xr = max(Xr, T.ts)<br>  else<br>    // Add T to the VQ.<br>    insert_in_queue(VQ, T)<br>Unlock(VQ-lock)<br></code></pre></td></tr></table></figure>
<h4 id="proposed-enhancements-to-clocc-in-the-current-thesis">Proposed Enhancements to CLOCC in the Current Thesis</h4>
<h5 id="providing-external-consistency">Providing External Consistency</h5>
<p>Suppose <span class="math inline">\(S_j\)</span> has a timestamp later than <span class="math inline">\(T\)</span>. If <span class="math inline">\(T\)</span> has read an object that <span class="math inline">\(S_j\)</span> has modified, <span class="math inline">\(T\)</span> can still be serialized. However, as discussed in <a target="_blank" rel="noopener" href="https://users.cs.utah.edu/~stutsman/cs6963/public/papers/thor.pdf">A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks</a>, we abort <span class="math inline">\(T\)</span> in this case also to provide external consistency (so that transaction commit order as observed by clients is the same as the real time order).</p>
<p>External consistency: The serialization order is such that, if transaction <span class="math inline">\(S\)</span> committed before <span class="math inline">\(T\)</span> began (in real time), <span class="math inline">\(S\)</span> is ordered before <span class="math inline">\(T\)</span>.</p>
<p>Since different transactions may be timestamped at different coordinators, and clocks are only loosely synchronized, a transaction <span class="math inline">\(T\)</span> that begins after some other transaction <span class="math inline">\(S_j\)</span> committed may actually receive a timestamp that is earlier than that of <span class="math inline">\(S_j\)</span> (although this situation is very unlikely). In this case, <span class="math inline">\(T\)</span> must not be committed if it read any object that <span class="math inline">\(S_j\)</span> modified, since that would violate external consistency.</p>
<p>The reader may wonder why transaction <span class="math inline">\(T\)</span> could commit if it did not read any object modified by transaction <span class="math inline">\(S_j\)</span> or modify any object read by <span class="math inline">\(S_j\)</span>, even though <span class="math inline">\(S_j\)</span> has a later timestamp than <span class="math inline">\(T\)</span>. In my understanding, this is because even if the server internally ordered <span class="math inline">\(T\)</span> before <span class="math inline">\(S_j\)</span> by timestamp order, contrary to the real-time order (<span class="math inline">\(S_j\)</span> before <span class="math inline">\(T\)</span>), the clients could not conclusively prove this was the case. However, if <span class="math inline">\(T\)</span> read an older version of an object and <span class="math inline">\(S_j\)</span> modified a newer version of that same object, the clients could irrefutably prove the mistake. Since <span class="math inline">\(T\)</span> read the older version rather than the newer version written by <span class="math inline">\(S_j\)</span>, the clients could conclusively prove the server ordered <span class="math inline">\(T\)</span> before <span class="math inline">\(S_j\)</span> incorrectly, despite <span class="math inline">\(S_j\)</span> executing earlier in real time.</p>
<p>To guarantee external consistency, the author specifies a more stringent validation test for transactions with later timestamps than the MOS condition proposed in <a target="_blank" rel="noopener" href="https://citeseerx.ist.psu.edu/doc/10.1.1.72.8778">A. Adya. Transaction Management for Mobile Objects Using Optimistic Concurrency Control. Master’s thesis, Massachusetts Institute of Technology, Jan. 1994.</a> The stricter test is:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">if ts(S) &gt; ts(T) and<br>  ((MOS(T) and ROS(S) have at least one element in common) or<br>   (ROS(T) and MOS(S) have at least one element in common))<br></code></pre></td></tr></table></figure>
<h5 id="other-enhancements">Other Enhancements</h5>
<p>The author also suggests some enhancements for CLOCC, such as implementing version checks without relying on version numbers and incorporating watermark checks as an additional improvement.</p>
<h3 id="mechanisms-for-isolation-level-pl-2">Mechanisms for Isolation Level PL-2</h3>
<p>We implement a variant of CLOCC, called Weak-CLOCC, to achieve PL-2 isolation. The serial validation algorithm of Weak-CLOCC is similar to CLOCC's, except that Weak-CLOCC simply considers a PL-2 transaction's read set to be empty for validation checks.</p>
<p>Since PL-2 isolation prohibits Aborted Reads (G1a), Intermediate Reads (G1b), and Circular Information Flow (G1c), Weak-CLOCC does not consider anti-dependency edges when validating transactions. Therefore, Weak-CLOCC skips (1a) which disable <span class="math inline">\(T \stackrel{rw}{\longrightarrow} S_i\)</span> and (2) which disable <span class="math inline">\(S_j \stackrel{rw}{\longrightarrow} T\)</span>, as described in the "Theorem for ROS and MOS Tests" section. Thus, Weak-CLOCC skips (1a-committed) (2-committed) (1a-prepared) (2-prepared), as described in the "Serial Validation Algorithm" section. As a result, Weak-CLOCC does not perform the Version Check, the Read-watermark Check, the ROS test and the MOS test, only performs the Write-watermark Check. Therefore, Weak-CLOCC's validation algorithm equals PL-3's if it considers transactions' read sets to be empty.</p>
<h3 id="multistamp-based-mechanism-for-pl-2-and-epl-2">Multistamp-Based Mechanism for PL-2+ and EPL-2+</h3>
<p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/259380.259425">A. Adya and B. Liskov. Lazy Consistency Using Loosely Synchronized Clocks. In Proceedings of the ACM Symposium on Principles of Distributed Computing, pages 73–82, Santa Barbara, CA, Aug. 1997.</a> provides a more detailed description of the multistamp-based mechanism. There are several key points to note that will aid our understanding of the multistamp-based mechanism:</p>
<ul>
<li>In the section "Serializability for Committed Transactions: CLOCC", the author mentions that a transaction <span class="math inline">\(T\)</span> is assigned a timestamp by the client, and this timestamp is the same across all servers. This implies that transactions are serialized in the same order at all servers. However, in this section, each server assigns a different timestamp to incoming transactions based on its own clock. Therefore, there is no global order of transactions across servers. Consequently, we cannot use the start-depends conflict relation and the Start-ordered Serialization Graph any longer.</li>
<li>We assume that server clocks monotonically increase and advance sufficiently quickly to assign each transaction a unique timestamp. Therefore, the timestamp order of transactions corresponds to their arrival order at a given server (though the arrival order may differ across servers).</li>
<li>The author has proven that disallowing G-single schedules is equivalent to enforcing the no-depend-misses property. Unlike the use of direct serialization graphs (DSG) and start-ordered serialization graphs (SSG) to guide the implementation of serializability for committed transactions, we would not use them to implement PL-2+. Instead, we would use the no-depend-misses property to guide the implementation of PL-2+.</li>
</ul>
<h4 id="a-theorem-for-multistamp-based-mechanism">A Theorem for Multistamp-Based Mechanism</h4>
<p>The fundamental idea is this: if a client running transaction <span class="math inline">\(U\)</span> observes a modification made by transaction <span class="math inline">\(T\)</span>, then it must already have received all the invalidations of <span class="math inline">\(T\)</span> and any transactions <span class="math inline">\(T\)</span> depended on.</p>
<p>The information about invalidations is conveyed to clients using multistamps. <strong>Each committed transaction has a multistamp</strong> that indicates its invalidations and those of all transactions it depends on. A multistamp is <strong>a set of tuples</strong> <span class="math inline">\(\langle C, S, ts\rangle\)</span>; each tuple <span class="math inline">\(\langle C, S, ts\rangle\)</span> means that an invalidation was generated for client <span class="math inline">\(C\)</span> at server <span class="math inline">\(S\)</span> at time <span class="math inline">\(ts\)</span>. The timestamp <span class="math inline">\(ts\)</span> is the value of <span class="math inline">\(S\)</span>'s clock at the time it <strong>prepared</strong> a transaction that caused invalidations for <span class="math inline">\(C\)</span>.</p>
<h4 id="base-algorithm">Base Algorithm</h4>
<h5 id="processing-at-the-server">Processing at the Server</h5>
<p>When a client requests a page, the server responds with a fetch response containing the page with modifications from transactions, as well as the merge of the multistamps of those transactions. There is an obvious merge operation on multistamps: if two input multistamps have a tuple for the same client/server pair, the merge retains the larger timestamp value for that pair.</p>
<ul>
<li>To provide a fetch response with the multistamps of updated transactions, the server maintains a <strong>PSTAMP</strong> table that maps pages to multistamps: the multistamp of a page is the merge of the multistamps of all transactions that modified that page.</li>
<li>To maintain the PSTAMP table, the server also maintains a <strong>VQ</strong> that records <strong>the multistamps of committed transactions</strong>, along with information about <strong>the reads and writes of prepared and committed transactions</strong>. The VQ information is used to calculate the multistamp of prepared transactions and ultimately the PSTAMP table.</li>
<li>Servers store the database objects in pages on disk, objects are typically smaller than pages. Clients maintain a page cache. When a client receives an invalidation message, it discards invalid <strong>objects but not the entire page</strong>. To achieve this, the server maintains an <strong>ILIST</strong> that maps clients to invalidation information. Each element of ILIST(C) is a timestamp <span class="math inline">\(ts\)</span> and a list of object ids, indicating that these objects were invalidated for <span class="math inline">\(C\)</span> at time <span class="math inline">\(ts\)</span>.</li>
</ul>
<h6 id="commit-processing">Commit Processing</h6>
<p>In the <strong>prepare</strong> phase, if validation of transaction <span class="math inline">\(T\)</span> succeeds, participant <span class="math inline">\(S\)</span> computes multistamp <span class="math inline">\(m\)</span> as follows:</p>
<ul>
<li><span class="math inline">\(S\)</span> initializes <span class="math inline">\(T\)</span>'s multistamp <span class="math inline">\(m\)</span> to be empty.</li>
<li>If the commit of <span class="math inline">\(T\)</span> would cause invalidations for any other clients, <span class="math inline">\(S\)</span>:
<ul>
<li>Sets <span class="math inline">\(ts\)</span> to <strong>the current time of its clock</strong>.</li>
<li>For each potentially invalidated client <span class="math inline">\(C\)</span> (the server maintains a per-client directory listing pages cached at each client; the directory may list pages no longer actually cached, as the server has not yet been informed they were dropped):
<ul>
<li><span class="math inline">\(S\)</span> adds tuple <span class="math inline">\(\langle C, S, ts\rangle\)</span> to <span class="math inline">\(m\)</span>.</li>
<li><span class="math inline">\(S\)</span> adds <span class="math inline">\(\langle ts, \text{olist}\rangle\)</span> to the ILIST for <span class="math inline">\(C\)</span>, where <span class="math inline">\(\text{olist}\)</span> contains ids of all objects modified by <span class="math inline">\(T\)</span> that are in pages listed in <span class="math inline">\(S\)</span>'s directory for <span class="math inline">\(C\)</span>.</li>
</ul></li>
</ul></li>
<li>For each transaction <span class="math inline">\(U\)</span> that <span class="math inline">\(T\)</span> depends on, <span class="math inline">\(S\)</span> merges <span class="math inline">\(U\)</span>'s multistamp with <span class="math inline">\(m\)</span>. The dependencies are determined using <span class="math inline">\(S\)</span>'s VQ.</li>
</ul>
<p>Then <span class="math inline">\(S\)</span> sends <span class="math inline">\(m\)</span> in the vote message to the coordinator. If the coordinator decides to commit <span class="math inline">\(T\)</span>, it <strong>merges multistamps received from participants</strong> to obtain <span class="math inline">\(T\)</span>'s multistamp. This multistamp is sent to participants in the commit messages. The participants store it in VQ(T).mstamp. Furthermore, for each page <span class="math inline">\(P\)</span> modified by <span class="math inline">\(T\)</span>, the participant <strong>merges this multistamp into PSTAMP(P)</strong>. If the coordinator decides to abort, it sends this information to the participants. The participant then removes information about <span class="math inline">\(T\)</span> from the ILIST.</p>
<h6 id="fetch-processing">Fetch Processing</h6>
<p>The author states that when a server receives a fetch request for object <span class="math inline">\(x\)</span> on page <span class="math inline">\(P\)</span>, if there is a prepared transaction <span class="math inline">\(T_i\)</span> that modified <span class="math inline">\(x\)</span>, the server <strong>waits for <span class="math inline">\(T_i\)</span> to complete</strong> before responding. It then sends the fetch reply containing <span class="math inline">\(P\)</span> and PSTAMP(P). Waiting for <span class="math inline">\(T_i\)</span> to complete ensures that the client receives <span class="math inline">\(T_i\)</span>'s <strong>final multistamp</strong> rather than an intermediate value.</p>
<p>The author seems to imply that <span class="math inline">\(T_i\)</span>'s multistamp at participant server <span class="math inline">\(S\)</span> is an intermediate value before <span class="math inline">\(S\)</span> receives the multistamp sent by the coordinator and merged from all participants, which is <span class="math inline">\(T_i\)</span>'s final multistamp. However, if <span class="math inline">\(S\)</span> instead returns <span class="math inline">\(P\)</span> without <span class="math inline">\(T_i\)</span>'s modifications and PSTAMP(P) without merging <span class="math inline">\(T_i\)</span>'s multistamp, would that be a valid option?</p>
<h6 id="invalidations">Invalidations</h6>
<ul>
<li>The server can produce an invalidation message <strong>proactively</strong> by traversing the ILIST <strong>in timestamp order</strong> from smallest to largest, stopping either when it has processed the entire list or reaches an entry for a prepared (but uncommitted) transaction. The message contains the ids of all objects in the processed entries and the <strong>largest timestamp</strong> from those entries.</li>
<li>Alternatively, a client may request invalidation information by providing a timestamp <span class="math inline">\(ts\)</span>. The server responds with an invalidation message containing a timestamp <strong>greater than or equal to</strong> <span class="math inline">\(ts\)</span>.
<ul>
<li>It is possible that some entry in the table with a timestamp less than or equal to <span class="math inline">\(ts\)</span> exists for a transaction that has not yet committed (it is still prepared); in this case, the server delays the response until the outcome for that transaction is known.</li>
<li>If <span class="math inline">\(ts\)</span> is greater than the timestamp of all entries in the ILIST, the server responds with its current time.</li>
<li>Furthermore, the server waits for its clock to advance past <span class="math inline">\(ts\)</span> if necessary. We assume server clocks monotonically increase, so no entries with timestamp less than or equal to <span class="math inline">\(ts\)</span> can be added to PSTAMP, VQ or ILIST after the clock passes <span class="math inline">\(ts\)</span>.</li>
</ul></li>
</ul>
<h5 id="processing-at-the-client">Processing at the Client</h5>
<p>A client <span class="math inline">\(C\)</span> is responsible for using multistamps to <strong>ensure that it receives invalidations</strong> before their absence could lead to the current transaction viewing an inconsistency.</p>
<ul>
<li><span class="math inline">\(C\)</span> maintains two tables that store information about servers it is connected to. LATEST(S) stores the timestamp of the latest invalidation message it has received from server <span class="math inline">\(S\)</span> and REQ(S) is the largest timestamp for <span class="math inline">\(S\)</span> that <span class="math inline">\(C\)</span> <strong>is required to hear about</strong>. If REQ(S) &gt; LATEST(S), this means <span class="math inline">\(S\)</span> has invalidations for <span class="math inline">\(C\)</span> that <span class="math inline">\(C\)</span> has not yet heard about.</li>
<li>The client also maintains a set CURR that identifies all servers used by the currently running transaction. For each such server <span class="math inline">\(S\)</span> in CURR, it guarantees that LATEST(S) &gt;= REQ(S). In other words, for all servers used by the current transaction, the invalidation information is <strong>as recent as is required</strong>.</li>
</ul>
<p>Client <span class="math inline">\(C\)</span> does the following when a transaction first uses object <span class="math inline">\(x\)</span>:</p>
<ul>
<li>Adds <span class="math inline">\(x\)</span>'s server <span class="math inline">\(S\)</span> to CURR.</li>
<li>Fetches <span class="math inline">\(x\)</span> if necessary. When the fetch reply arrives it processes the invalidations as described above. Then it updates the information in REQ to reflect the multistamp in the fetch response: for each multistamp entry <span class="math inline">\(\langle C, R, ts\rangle\)</span> such that <span class="math inline">\(ts\)</span> is larger than REQ(R), it stores <span class="math inline">\(ts\)</span> in REQ(R).</li>
<li>If LATEST(R) &lt; REQ(R) for some server <span class="math inline">\(R\)</span> in CURR, it sends an invalidation request to <span class="math inline">\(R\)</span> (requesting <span class="math inline">\(R\)</span> to reply with a message timestamped same as or later than REQ(R)), waits for the response, and then processes it. This results in an extra message to server <span class="math inline">\(R\)</span> and delays the current transaction, causing a <strong>consistency stall</strong>.</li>
</ul>
<p>Note that invalidation processing in steps 2 and 3 can cause the transaction to abort (if the transaction had already used an invalidated object).</p>
<h5 id="validation">Validation</h5>
<p>A transaction <span class="math inline">\(T_i\)</span>'s reads are validated by its client and its writes are checked by the servers using Weak-CLOCC.</p>
<ul>
<li>To validate <span class="math inline">\(T_i\)</span> 's reads, its client <span class="math inline">\(C\)</span> ensures that <span class="math inline">\(C\)</span> has recent-enough information about invalidations for all servers used by <span class="math inline">\(T_i\)</span>, i.e., for each server <span class="math inline">\(X\)</span> in CURR, the client checks that LATEST(X) &gt;= REQ(X). This check is called the read-dependency check. If this condition does not hold for some servers, a consistency stall occurs and the client sends an invalidation-request messages to each server <span class="math inline">\(X\)</span> where the information was not sufficiently recent. When the client receives the replies, it processes them as in CLOCC, i.e., it <strong>aborts</strong> <span class="math inline">\(T_i\)</span> if the reply indicates <span class="math inline">\(T_i\)</span> has read an obsolete object; otherwise, <span class="math inline">\(T_i\)</span> passes the read-dependency check.</li>
<li>If transaction <span class="math inline">\(T_i\)</span> is read-only, there is no more work to be done and the transaction <strong>commits locally at the client</strong>.</li>
<li>Otherwise, the client sends the read and write sets to the servers so that the Weak-CLOCC checks can be performed, and so that <span class="math inline">\(T_i\)</span>'s multistamp can be computed.</li>
</ul>
<h4 id="truncation">Truncation</h4>
<p>We remove "old" tuples from multistamps. To account for the removed tuples, each multistamp <span class="math inline">\(m\)</span> also contains a timestamp <span class="math inline">\(m.threshold\)</span>; <span class="math inline">\(m.threshold\)</span> is <strong>greater than or equal to</strong> timestamps of <strong>all</strong> tuples that have been removed from <span class="math inline">\(m\)</span>. The threshold allows us to compute an effective multistamp <span class="math inline">\(\operatorname{EFF}(m)\)</span> containing a tuple <span class="math inline">\(\langle C, X, ts\rangle\)</span> for <strong>every</strong> client/server pair, where <span class="math inline">\(ts\)</span> is the timestamp in the tuple for client <span class="math inline">\(C\)</span> and server <span class="math inline">\(X\)</span> in <span class="math inline">\(m\)</span> if one exists and otherwise, <span class="math inline">\(ts\)</span> is <span class="math inline">\(m.threshold\)</span>.</p>
<p>Suppose there are two servers, <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, and two clients, <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span>. The non-truncated multistamp <span class="math inline">\(m\)</span> of transaction <span class="math inline">\(T_i\)</span> is:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Client</th>
<th style="text-align: center;">Server</th>
<th style="text-align: center;">Ts</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">3:01:17 pm</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">3:02:11 pm</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">3:02:21 pm</td>
</tr>
</tbody>
</table>
<p>Then, <span class="math inline">\(\operatorname{EFF}(m) = m\)</span>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Client</th>
<th style="text-align: center;">Server</th>
<th style="text-align: center;">Ts</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">3:01:17 pm</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">3:02:11 pm</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">3:02:21 pm</td>
</tr>
</tbody>
</table>
<p>Suppose <span class="math inline">\(m\)</span> is truncated to obtain <span class="math inline">\(m^\prime\)</span>:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Client</th>
<th style="text-align: center;">Server</th>
<th style="text-align: center;">Ts</th>
<th style="text-align: center;">Threshold</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3:02:11 pm</td>
</tr>
<tr class="even">
<td style="text-align: center;">C</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">3:02:21 pm</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>Then, <span class="math inline">\(\operatorname{EFF}(m^\prime)\)</span> is:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Client</th>
<th style="text-align: center;">Server</th>
<th style="text-align: center;">Ts</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">3:02:11 pm</td>
</tr>
<tr class="even">
<td style="text-align: center;">D</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">3:02:11 pm</td>
</tr>
<tr class="odd">
<td style="text-align: center;">D</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">3:02:11 pm</td>
</tr>
<tr class="even">
<td style="text-align: center;">C</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">3:02:21 pm</td>
</tr>
</tbody>
</table>
<p>We observe that for any client/server pair, the timestamp in <span class="math inline">\(\operatorname{EFF}(m^\prime)\)</span> is greater than or equal to the timestamp in <span class="math inline">\(\operatorname{EFF}(m)\)</span>, i.e. the truncated multistamp is a more conservative version of the original.</p>
<p>The VQ and PSTAMP tables can also be truncated in a similar manner.</p>
<ul>
<li>Whenever the multistamp of a transaction contains no tuples (i.e., it consists only of a threshold), it is dropped from the VQ. The VQ has an associated multistamp <span class="math inline">\(VQ.threshold\)</span> that is greater than or equal to the (effective) multistamps of all transactions dropped from VQ. When a server generates a transaction <span class="math inline">\(T_i\)</span>'s multistamp (<span class="math inline">\(T_i.mstamp\)</span>), it initializes <span class="math inline">\(T_i.mstamp\)</span> to be <span class="math inline">\(VQ.threshold\)</span>.</li>
<li>Information is dropped from PSTAMP in the same way, with information about multistamps of dropped entries merged into <span class="math inline">\(PSTAMP.threshold\)</span>.</li>
</ul>
<h4 id="offloading-multistamp-generation-to-clients">Offloading Multistamp Generation to Clients</h4>
<p>As mentioned in section "Commit Processing", the final multistamp of prepared transaction <span class="math inline">\(T_i\)</span> is calculated in the following ways:</p>
<ul>
<li>Each participant server <span class="math inline">\(S\)</span> generates an intermediate multistamp with <span class="math inline">\(\left\{\left\langle C, S, ts\right\rangle \right\} \cup VQ[U_1].mstamp \cup VQ[U_2].mstamp \cup \ldots\)</span> where <span class="math inline">\(C\)</span> is a client whose cached pages may be invalidated by <span class="math inline">\(T_i\)</span> and <span class="math inline">\(U_1\)</span> is a transaction that <span class="math inline">\(T_i\)</span> depends on.
<ul>
<li>For each potentially invalidated client <span class="math inline">\(C\)</span>, <span class="math inline">\(S\)</span> adds tuple <span class="math inline">\(\langle C, S, ts\rangle\)</span> to <span class="math inline">\(m\)</span>.</li>
<li>For each transaction <span class="math inline">\(U\)</span> that <span class="math inline">\(T\)</span> depends on, <span class="math inline">\(S\)</span> merges <span class="math inline">\(U\)</span>'s multistamp with <span class="math inline">\(m\)</span>.</li>
</ul></li>
<li>The coordinator merges multistamps received from participants to obtain <span class="math inline">\(T_i\)</span>'s multistamp.</li>
</ul>
<p>As mentioned in the "Fetch Processing" section, servers send fetch replies containing page <span class="math inline">\(P\)</span> and its multistamp PSTAMP(P).</p>
<p>So we can optimize this process through the following client-merger scheme:</p>
<ul>
<li>Let clients (instead of servers) generate a portion of the intermediate multistamps. When client <span class="math inline">\(C\)</span> receives a page <span class="math inline">\(P\)</span>'s multistamp, it retains it in a <strong>CLIENTPMAP</strong> table mapping page ids to their multistamps for pages in <span class="math inline">\(C\)</span>'s cache. The CLIENTPMAP table is maintained in a manner similar to the PSTAMP table, i.e., only multistamps of recently fetched pages are kept; other multistamps are summarized using a threshold multistamp. When transaction <span class="math inline">\(T_i\)</span> ends, <span class="math inline">\(C\)</span> computes <span class="math inline">\(T_i\)</span>'s initial multistamp by merging the multistamps of pages accessed by <span class="math inline">\(T_i\)</span> and sends it to the coordinator. The initial multistamp equals the merge of <span class="math inline">\(VQ[U_1].mstamp \cup VQ[U_2].mstamp \cup \ldots\)</span> from different participants.</li>
<li>Each participant <span class="math inline">\(S\)</span> simply sends tuples generated due to <span class="math inline">\(T_i\)</span>'s invalidations (<span class="math inline">\(\langle C, S, ts\rangle\)</span>) in its vote to the coordinator.</li>
<li>The coordinator merges these tuples to obtain <span class="math inline">\(T_i\)</span>'s final multistamp.</li>
</ul>
<p>Our original approach for generating multistamps used exact write sets from the VQ and <span class="math inline">\(T_i\)</span>'s read set. However, in the client-merger scheme, <span class="math inline">\(T_i\)</span>'s initial multistamp is computed at a client <strong>based on coarse-grained information</strong>, i.e., pages accessed by <span class="math inline">\(T_i\)</span> (since the CLIENTMAP table is maintained at a page granularity). The loss of precision can result in larger multistamps, and hence, more truncation, leading to a higher number of consistency stalls. To alleviate this problem of false dependencies, ...</p>
<h3 id="pl-3u-mechanism-for-read-only-transactions">PL-3U Mechanism for Read-only Transactions</h3>
<h4 id="a-theorem-for-implementing-pl-3u">A Theorem for Implementing PL-3U</h4>
<p>The author has proven that disallowing G-update schedules is equivalent to enforcing the no-update-conflict-misses property. Unlike the use of direct serialization graphs (DSG) and start-ordered serialization graphs (SSG) to guide the implementation of serializability for committed transactions, we would not use them to implement PL-3U. Instead, we would use the no-update-conflict-misses property to guide the implementation of PL-3U.</p>
<p>Our implementation for committing a read-only transaction <span class="math inline">\(T_q\)</span> at PL-3U ensures that the no-update-conflict-misses condition is satisfied, i.e., if the client running <span class="math inline">\(T_q\)</span> observes a modification of transaction <span class="math inline">\(T_i\)</span>, it can commit <span class="math inline">\(T_q\)</span> locally only if it has received all the invalidations of <span class="math inline">\(T_i\)</span> and any update transactions that <span class="math inline">\(T_i\)</span> <strong>depends or anti-depends on</strong>. Thus, multistamps need to capture <strong>dependencies and anti-dependencies</strong>.</p>
<h4 id="implementing-pl-3u">Implementing PL-3U</h4>
<p>We make the following change to the multistamp-based scheme for PL-2+. When a transaction <span class="math inline">\(T_i\)</span> prepares at a server <span class="math inline">\(X\)</span>, the server computes the multistamp by merging the multistamps of all transactions that <span class="math inline">\(T_i\)</span> depends and anti-depends on.</p>
<p>If a read-only transaction <span class="math inline">\(T_q\)</span> requests level PL-3U and accesses objects from only a server <span class="math inline">\(X\)</span>, it can be committed locally regardless of the values of LATEST(X) and REQ(X) (recall that single-server transactions can be committed locally at level PL-2+ as well). In this scenario, if <span class="math inline">\(T_q\)</span> observes the effects of a transaction <span class="math inline">\(T_i\)</span> from <span class="math inline">\(X\)</span>, it will not miss the effects of any committed update transaction that <span class="math inline">\(T_i\)</span> depends or anti-depends on. The reason is that after <span class="math inline">\(T_i\)</span> prepares at <span class="math inline">\(X\)</span>, CLOCC prevents any transaction that conflicts with <span class="math inline">\(T_i\)</span> to prepare with a timestamp earlier than <span class="math inline">\(T_i\)</span>. Thus, <span class="math inline">\(T_q\)</span> can be serialized after all update transactions (such as <span class="math inline">\(T_i\)</span> ) that <span class="math inline">\(T_q\)</span> depends or anti-depends on.</p>
<p>As stated in the "Fetch Processing" section:</p>
<p>When a server receives a fetch request for object <span class="math inline">\(x\)</span> on page <span class="math inline">\(P\)</span>, if there is a prepared transaction <span class="math inline">\(T_i\)</span> that modified <span class="math inline">\(x\)</span>, the server <strong>waits for <span class="math inline">\(T_i\)</span> to complete</strong> before responding. It then sends the fetch reply containing <span class="math inline">\(P\)</span> and PSTAMP(P). Waiting for <span class="math inline">\(T_i\)</span> to complete ensures that the client receives <span class="math inline">\(T_i\)</span>'s <strong>final multistamp</strong> rather than an intermediate value.</p>
<p>The author also states that if a <strong>preparing</strong> transaction <span class="math inline">\(T_i\)</span> anti-depends on a prepared transaction <span class="math inline">\(T_j\)</span>, <span class="math inline">\(T_i\)</span>'s prepare is delayed until <span class="math inline">\(T_j\)</span> commits or aborts. This ensures that the server merges <span class="math inline">\(T_j\)</span>'s final multistamp into <span class="math inline">\(T_i\)</span>'s multistamp.</p>
<p>The author seems to imply that <span class="math inline">\(T_j\)</span>'s multistamp at server <span class="math inline">\(S\)</span> before receiving the coordinator's merged multistamp is an intermediate value. However, if <span class="math inline">\(S\)</span> instead returns PSTAMP(P), RPSTAMP(P) and ILIST(C) without merging <span class="math inline">\(T_j\)</span>'s multistamp, would that be a valid option?</p>
<h4 id="pl-3u-in-action-an-illustrative-example">PL-3U in Action: An Illustrative Example</h4>
<p>The original thesis simply distinguishes PL-3U implementation from PL-2+ implementation. However, I am unclear on how to implement a system providing PL-3 for update transactions and PL-3U for read-only transactions. I will provide more details on implementing such a mixed system.</p>
<p>Assume two clients, <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span>, and two servers, <span class="math inline">\(S\)</span> and <span class="math inline">\(T\)</span>.</p>
<ul>
<li><span class="math inline">\(S\)</span> contains page <span class="math inline">\(P\)</span> with objects <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>.</li>
<li><span class="math inline">\(T\)</span> contains page <span class="math inline">\(Q\)</span> with object <span class="math inline">\(M\)</span>.</li>
</ul>
<p>There is a history <span class="math inline">\(H_{non-3U}\)</span> allowed by PL-2+ but not PL-3U.</p>
<ul>
<li>Transactions <span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_2\)</span>, ..., <span class="math inline">\(T_5\)</span> are prepared and committed in sequential order; for example, <span class="math inline">\(T_2\)</span> is prepared after <span class="math inline">\(T_1\)</span> commits.</li>
<li><span class="math inline">\(T_1\)</span>, <span class="math inline">\(T_3\)</span> and <span class="math inline">\(T_4\)</span> are performed by client <span class="math inline">\(C\)</span>.</li>
<li><span class="math inline">\(T_2\)</span> and <span class="math inline">\(T_5\)</span> are performed by client <span class="math inline">\(D\)</span>.</li>
</ul>
<p><span class="math inline">\(T_2\)</span> caches <span class="math inline">\(X_1\)</span> and <span class="math inline">\(Y_1\)</span>, so <span class="math inline">\(T_5\)</span> reads stale data. We analyze why <span class="math inline">\(T_5\)</span> commits in PL-2+ but aborts in PL-3U.</p>
<p><span class="math display">\[\begin{align*}
H_{non-3U}: r_1(M_0,Open)   &amp;\\
            w_1(X_1,50)     &amp;\\
            w_1(Y_1,50)     &amp;\\
            c_1             &amp;\\
            r_2(X_1,50)     &amp;\\
            r_2(Y_1,50)     &amp;\\
            c_2             &amp;\\
            r_3(M_0,Open)   &amp;\\
            w_3(X_3,55)     &amp;\\
            w_3(Y_3,55)     &amp;\\
            c_3             &amp;\\
            w_4(M_4,Closed) &amp;\\
            c_4             &amp;\\
            r_5(X_1,50)     &amp;\\
            r_5(Y_1,50)     &amp;\\
            r_5(M_4,Closed) &amp;\\
            c_5             &amp;\\
[M_0 \ll M_4, X_1 \ll X_3, Y_1 \ll Y_3]
\end{align*}\]</span></p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T</th>
<th style="text-align: center;">Client C's Cached Page</th>
<th style="text-align: center;">Client D's Cached Page</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T1</td>
<td style="text-align: center;">{P,Q}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;">T2</td>
<td style="text-align: center;">{P,Q}</td>
<td style="text-align: center;">{P}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T3</td>
<td style="text-align: center;">{P,Q}</td>
<td style="text-align: center;">{P}</td>
</tr>
<tr class="even">
<td style="text-align: center;">T4</td>
<td style="text-align: center;">{P,Q}</td>
<td style="text-align: center;">{P}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T5</td>
<td style="text-align: center;">{P,Q}</td>
<td style="text-align: center;">{P,Q}</td>
</tr>
</tbody>
</table>
<p>The following table shows the T.mstamp and PSTAMP calculations in a PL-2+ implementation:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T</th>
<th style="text-align: center;">T.mstamp</th>
<th style="text-align: center;">PSTAMP(P)</th>
<th style="text-align: center;">PSTAMP(Q)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T1</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;">T2</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T3</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T4</td>
<td style="text-align: center;">{{C,T,11:10}}</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{{C,T,11:10}}</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<p>For PL-3U, we also need to maintain anti-dependency information for pages; for this purpose:</p>
<ul>
<li>We use a new table, <strong>RPSTAMP</strong>, which maps a page <span class="math inline">\(P\)</span> to the (merged) multistamp of all <strong>update</strong> transactions that have <strong>read</strong> <span class="math inline">\(P\)</span>.</li>
<li>For each page <span class="math inline">\(P\)</span> modified by <span class="math inline">\(T_i\)</span>, it merges RPSTAMP(P) into <span class="math inline">\(T_i\)</span>'s multistamp.</li>
</ul>
<p>We first calculate the RPSTAMP table for <span class="math inline">\(H_{non-3U}\)</span> from top to bottom, from left to right. For example:</p>
<ul>
<li>After <span class="math inline">\(T_1\)</span> commits:
<ul>
<li><span class="math inline">\(T_1\)</span> does not invalidate any clients or depend on any other transactions (we do not consider <span class="math inline">\(T_0\)</span> to simplify), so its multistamp is the empty set.</li>
<li><span class="math inline">\(T_1\)</span> is an update transaction. It reads <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span> (we assume transactions always read objects before modifying them, disallowing blind writes). Therefore, RPSTAMP(P)(T1) and RPSTAMP(Q)(T1) are merged with T1.mstamp, both resulting in the empty set.</li>
</ul></li>
<li>After <span class="math inline">\(T_2\)</span> commits:
<ul>
<li><span class="math inline">\(T_2\)</span> does not invalidate any clients, but it depends on <span class="math inline">\(T_1\)</span>. It does not modify any objects belonging to any pages. Therefore, it should not merge any RPSTAMP items. T2.mstamp results in the empty set.</li>
<li><span class="math inline">\(T_2\)</span> is a read-only transaction, not an update transaction. Therefore, RPSTAMP(P)(T2) and RPSTAMP(Q)(T2) should not merge T2.mstamp. They remain the same as RPSTAMP(P)(T1) and RPSTAMP(Q)(T1), resulting in the empty set.</li>
</ul></li>
<li>After <span class="math inline">\(T_3\)</span> prepares and commits at 11:00:
<ul>
<li><span class="math inline">\(T_3\)</span> writes to <span class="math inline">\(X\)</span> and <span class="math inline">\(Y\)</span>, invalidating clients <span class="math inline">\(C\)</span> and <span class="math inline">\(D\)</span> which cache page <span class="math inline">\(P\)</span> on server <span class="math inline">\(S\)</span>. Therefore, its multistamp should contain {{C,S,11:00}, {D,S,11:00}}. <span class="math inline">\(T_3\)</span> depends on <span class="math inline">\(T_1\)</span>, so it merges T1.mstamp. <span class="math inline">\(T_3\)</span> also modifies <span class="math inline">\(P\)</span>, so it merges RPSTAMP(P)(T2). After these merges, the result is {{C,S,11:00}, {D,S,11:00}}.</li>
<li><span class="math inline">\(T_3\)</span> is an update transaction that reads <span class="math inline">\(P\)</span> and <span class="math inline">\(Q\)</span>. Therefore, RPSTAMP(P)(T3) merges RPSTAMP(P)(T2) and T3.mstamp, resulting in {{C,S,11:00},{D,S,11:00}}. RPSTAMP(Q)(T2) is calculated the same way as RPSTAMP(P)(T2) is calculated, resulting in {{C,S,11:00},{D,S,11:00}}.</li>
</ul></li>
<li>After <span class="math inline">\(T_4\)</span> prepares and commits at 11:10:
<ul>
<li><span class="math inline">\(T_4\)</span> writes to <span class="math inline">\(M\)</span>, invalidating client <span class="math inline">\(C\)</span> which caches <span class="math inline">\(Q\)</span> on server <span class="math inline">\(T\)</span>. Therefore, its multistamp should contain {{C,T,11:10}}. <span class="math inline">\(T_4\)</span> does not depend on any transaction (we do not consider <span class="math inline">\(T_0\)</span> to simplify), so T4.mstamp should not merge the multistamp of any other transactions. <span class="math inline">\(T_4\)</span> is an update transaction that writes <span class="math inline">\(Q\)</span>, so T4.mstamp should merge RPSTAMP(Q)(T3), resulting in {{C,T,11:10},{C,S,11:00},{D,S,11:00}}.</li>
<li><span class="math inline">\(T_4\)</span> is an update transaction that reads <span class="math inline">\(Q\)</span>, so RPSTAMP(Q)(T4) should merge RPSTAMP(Q)(T3) and T4.mstamp, resulting in {{C,S,11:00},{D,S,11:00},{C,T,11:10}}.</li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T</th>
<th style="text-align: center;">T.mstamp</th>
<th style="text-align: center;">RPSTAMP(P)</th>
<th style="text-align: center;">RPSTAMP(Q)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T1</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;">T2</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T3</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{{C,S,11:00},</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;">{D,S,11:00}}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T4</td>
<td style="text-align: center;">{{C,T,11:10},</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{{C,S,11:00},</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">{C,S,11:00},</td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;">{D,S,11:00},</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">{C,T,11:10}}</td>
</tr>
</tbody>
</table>
<p>We then calculate the PSTAMP table for <span class="math inline">\(H_{non-3U}\)</span> from top to bottom. For example:</p>
<ul>
<li>After transaction <span class="math inline">\(T_1\)</span> commits, page <span class="math inline">\(P\)</span> is modified by <span class="math inline">\(T_1\)</span>. PSTAMP(P)(T1) should merge T1.mtamp, resulting in an empty set.</li>
<li>After transaction <span class="math inline">\(T_2\)</span> commits, no pages are modified by <span class="math inline">\(T_2\)</span>. PSTAMP(P)(T2) and PSTAMP(Q)(T2) remain the same as PSTAMP(P)(T1) and PSTAMP(Q)(T2), resulting in an empty set.</li>
<li>After transaction <span class="math inline">\(T_3\)</span> commits, page <span class="math inline">\(P\)</span> is modified by <span class="math inline">\(T_3\)</span>. PSTAMP(P)(T3) should merge PSTAMP(P)(T2) and T3.mstamp, resulting in {{C,S,11:00},{D,S,11:00}}.</li>
<li>After transaction <span class="math inline">\(T_4\)</span> commits, page <span class="math inline">\(Q\)</span> is modified by <span class="math inline">\(T_4\)</span>. PSTAMP(Q)(T4) should merge PSTAMP(Q)(T3) and T4.mstamp, resulting in {{C,T,11:10},{C,S,11:00},{D,S,11:00}}.</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">T</th>
<th style="text-align: center;">T.mstamp</th>
<th style="text-align: center;">PSTAMP(P)</th>
<th style="text-align: center;">PSTAMP(Q)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">T1</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;">T2</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="odd">
<td style="text-align: center;">T3</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{}</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">T4</td>
<td style="text-align: center;">{{C,T,11:10},</td>
<td style="text-align: center;">{{C,S,11:00},</td>
<td style="text-align: center;">{{C,T,11:10},</td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;">{C,S,11:00},</td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;">{C,S,11:00},</td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;">{D,S,11:00}}</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">{D,S,11:00}}</td>
</tr>
</tbody>
</table>
<p>When client <span class="math inline">\(D\)</span> running transaction <span class="math inline">\(T_5\)</span> reads object <span class="math inline">\(M\)</span> belonging to page <span class="math inline">\(Q\)</span> in server <span class="math inline">\(T\)</span>, it will receive {D,S,11:00} asking it to wait for an invalidation message from server <span class="math inline">\(S\)</span>. The invalidation message will invalidate <span class="math inline">\(X_1\)</span> and <span class="math inline">\(Y_1\)</span>. <span class="math inline">\(T_5\)</span> will abort if it has read <span class="math inline">\(X_1\)</span> and <span class="math inline">\(Y_1\)</span>. Otherwise, <span class="math inline">\(T_5\)</span> will read <span class="math inline">\(X_3\)</span> and <span class="math inline">\(Y_3\)</span>, resulting in a valid transaction.</p>
<h5 id="the-aim-of-importing-the-rpstamp-table">The Aim of Importing the RPSTAMP Table</h5>
<p>For PL-3U, the no-update-conflict-misses condition requires that if transaction <span class="math inline">\(T_q\)</span> observes a modification of transaction <span class="math inline">\(T_i\)</span>, <span class="math inline">\(T_q\)</span> can only commit if it has received all invalidations of <span class="math inline">\(T_i\)</span> and any transactions that <span class="math inline">\(T_i\)</span> anti-depends on. The straightforward way to find all transactions that <span class="math inline">\(T_i\)</span> anti-depends on is to check all objects that <span class="math inline">\(T_i\)</span> writes. For each object that <span class="math inline">\(T_i\)</span> writes, we should find which transactions have read the last version of that object. Then merge the multistamps of those transactions into Ti.mstamp. However, the straightforward way is too costly.</p>
<p>We can take a coarser approach to accomplish this task: Find all pages written by <span class="math inline">\(T_i\)</span> and merge all the multistamps of transactions that have read those pages. We can cache the merged result of all multistamps of transactions that have read a page as the RPSTAMP table. When calculating Ti.mstamp, we should merge RPSTAMP(P) if <span class="math inline">\(T_i\)</span> writes page <span class="math inline">\(P\)</span>.</p>
<p>The coarse approach is coarser because we do not consider which transactions have read <strong>the exact last versions</strong> of those objects. We simply merge all multistamps of transactions that have read the pages. By taking a coarser approach and merging the multistamps of all transactions that have read the relevant pages, we avoid the cost of pinpointing exactly which transactions read the last version of each object. However, this coarseness may introduce some imprecision.</p>
<p>We can use the same coarse approach to calculate T.mstamp in PL-2+. We do not need to find all transactions that <span class="math inline">\(T\)</span> depends on and merge their multistamps. We simply merge all PSTAMP(P) entries for pages that <span class="math inline">\(T\)</span> reads.</p>
<h5 id="will-pl-3u-fail-if-an-earlier-update-transaction-arrives">Will PL-3U Fail if an Earlier Update Transaction Arrives?</h5>
<p>Let's assume there exists two committed transactions, read-only transaction <span class="math inline">\(Q\)</span> and update transaction <span class="math inline">\(T\)</span>, where <span class="math inline">\(Q\)</span> depends on <span class="math inline">\(T\)</span>. If two additional transactions then arrive - <span class="math inline">\(S_i\)</span> with an earlier timestamp than <span class="math inline">\(T\)</span> and <span class="math inline">\(S_j\)</span> with a later timestamp than <span class="math inline">\(T\)</span> - will they violate the PL-3U isolation guarantee for <span class="math inline">\(Q\)</span>?</p>
<ul>
<li>Because transaction <span class="math inline">\(S_j\)</span> arrives with a timestamp later than transaction <span class="math inline">\(T\)</span>, the serializable history of these transactions would be ordered as <span class="math inline">\(T\)</span>, then <span class="math inline">\(Q\)</span>, then <span class="math inline">\(S_j\)</span>. According to the current implementation, transaction <span class="math inline">\(Q\)</span> cannot depend on <span class="math inline">\(S_j\)</span> since <span class="math inline">\(S_j\)</span> has not yet committed. Therefore, any actions taken by <span class="math inline">\(S_j\)</span> will have no effect on committed transaction <span class="math inline">\(Q\)</span>.</li>
<li>After <span class="math inline">\(T\)</span> prepares, CLOCC prevents any transaction that conflicts with <span class="math inline">\(T\)</span> to prepare with a timestamp earlier than <span class="math inline">\(T\)</span>.
<ul>
<li>As discussed in the section "Providing External Consistency", if transaction <span class="math inline">\(S_i\)</span> has read an object that <span class="math inline">\(T\)</span> has modified (<span class="math inline">\(S_i \stackrel{rw}{\longrightarrow} T\)</span>), <span class="math inline">\(S_i\)</span> can still be serialized. However, to provide external consistency (ensuring that the transaction commit order observed by clients matches real-time order), we abort <span class="math inline">\(S_i\)</span> in this case. So transaction <span class="math inline">\(T\)</span> will not anti-depends on transaction <span class="math inline">\(S_i\)</span>, which has an earlier timestamp yet arrives later.</li>
<li>As discussed in the section "A Theorem for ROS and MOS Tests", since transaction <span class="math inline">\(T\)</span> has already committed, it could not have observed any updates from transaction <span class="math inline">\(S_i\)</span> (which arrives later). In other words, <span class="math inline">\(S_i \stackrel{wr}{\longrightarrow} T\)</span> is impossible. Stated simply, <span class="math inline">\(T\)</span> will not depend on <span class="math inline">\(S_i\)</span>.</li>
</ul></li>
</ul>
<h5 id="the-pl-3u-does-not-guarantee-serializability">The PL-3U Does Not Guarantee Serializability</h5>
<p>The author states: "The PL-3U scheme also uses arrival order, but without coordinating this order across servers. As a result, it does not provide serializability: two read-only transactions <span class="math inline">\(T_q\)</span> and <span class="math inline">\(T_r\)</span> that commit at client machines are not ordered with respect to each other."</p>
<p>However, I find this statement confusing. I would like to propose an alternative interpretation. As an example, consider history <span class="math inline">\(H_{3U}\)</span> mentioned in the section "Differentiating Between Levels PL-3U and PL-3". Assume <span class="math inline">\(T_4\)</span>'s timestamp is earlier than <span class="math inline">\(T_5\)</span>'s timestamp. In CLOCC, transactions are serialized in timestamp order, so <span class="math inline">\(T_4\)</span> would be serialized before <span class="math inline">\(T_5\)</span>. However, there is no direct dependency between <span class="math inline">\(T_4\)</span> and <span class="math inline">\(T_5\)</span> (<span class="math inline">\(T_4\)</span> neither depends on nor anti-depends on <span class="math inline">\(T_5\)</span>; <span class="math inline">\(T_5\)</span> neither depends on nor anti-depends on <span class="math inline">\(T_4\)</span>). From <span class="math inline">\(T_b\)</span>'s view, <span class="math inline">\(T_5\)</span> could be serialized before <span class="math inline">\(T_4\)</span> (see the DSG of <span class="math inline">\(H_{3U}\)</span>). This is why PL-3U does not provide serializability - it allows read-only transactions like <span class="math inline">\(T_b\)</span> to observe a different order than timestamp order. Although <span class="math inline">\(T_b\)</span> observes an order different from timestamp order, <span class="math inline">\(T_b\)</span> can still be positioned within the serialized order (<span class="math inline">\(\langle T_1, T_5, T_b , T_4\rangle\)</span>) of the complete history that includes all update transactions as well as <span class="math inline">\(T_b\)</span> itself (and excludes any other read-only transactions like <span class="math inline">\(T_a\)</span>).</p>
<h2 id="reference">Reference</h2>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://pmg.csail.mit.edu/papers/adya-phd.pdf">Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions, by Atul Adya</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.oreilly.com/library/view/transaction-processing/9780080519555/">J. N. Gray and A. Reuter. Transaction Processing: Concepts and Techniques. Morgan Kaufmann Publishers Inc., 1993.</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://courses.cs.washington.edu/courses/csep552/18wi/papers/CSE550BHG-Ch7.pdf">Concurrency Control and Recovery in Database Systems, by Philip A. Bernstein, Vassos Hadzilacos, and Nathan Goodman</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/323596.323607">W. E. Weihl. Distributed Version Management for Read-only Actions</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf">A Critique of ANSI SQL Isolation Levels, by Hal Berenson, Phil Bernstein, Jim Gray, Jim Melton, Elizabeth O'Neil and Patrick O'Neil</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://citeseerx.ist.psu.edu/doc/10.1.1.72.8778">A. Adya. Transaction Management for Mobile Objects Using Optimistic Concurrency Control. Master’s thesis, Massachusetts Institute of Technology, Jan. 1994.</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://users.cs.utah.edu/~stutsman/cs6963/public/papers/thor.pdf">A. Adya, R. Gruber, B. Liskov, and U. Maheshwari. Efficient Optimistic Concurrency Control using Loosely Synchronized Clocks</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://dspace.mit.edu/handle/1721.1/10762">R. Gruber. Optimism vs. Locking: A Study of Concurrency Control for Client-Server Object-Oriented Databases</a></p></li>
<li><p>Field calls, <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/588111.588126">A. Reuter. Concurrency on High-Traffic Data Elements</a>.</p></li>
<li><p>Escrow reads, <a target="_blank" rel="noopener" href="https://www.cs.umb.edu/~poneil/EscrowTM.pdf">P. O'Neil. The Escrow Transactional Method</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/259380.259425">A. Adya and B. Liskov. Lazy Consistency Using Loosely Synchronized Clocks. In Proceedings of the ACM Symposium on Principles of Distributed Computing, pages 73–82, Santa Barbara, CA, Aug. 1997.</a></p></li>
<li><p><a target="_blank" rel="noopener" href="https://www.fabriziomusacchio.com/blog/2021-08-10-How_to_use_LaTeX_in_Markdown/#mjx-eqn-eqtest1">Fabrizio Musacchio: How to use LaTeX in Markdown</a></p></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Computer-Science/" class="category-chain-item">Computer Science</a>
  
  
    <span>></span>
    
  <a href="/categories/Computer-Science/Serializability/" class="category-chain-item">Serializability</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Paper Interpretation - Weak Consistency: A Generalized Theory and Optimistic Implementations for Distributed Transactions</div>
      <div>https://clcanny.github.io/2023/03/06/computer-science/serializability/paper-interpretation-weak-consistency-a-generalized-theory-and-optimistic-implementations-for-distributed-transactions/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>JunBin</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年3月6日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/26/computer-science/programming-language/tla+/the-beginner-s-guide-to-tla+-specifying-and-verifying-distributed-systems/" title="The Beginner&#39;s Guide to TLA+: Specifying and Verifying Distributed Systems">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">The Beginner&#39;s Guide to TLA+: Specifying and Verifying Distributed Systems</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/05/computer-science/serializability/paper-interpretation-a-critique-of-ansi-sql-solation-levels/" title="Paper Interpretation - A Critique of ANSI SQL Isolation Levels">
                        <span class="hidden-mobile">Paper Interpretation - A Critique of ANSI SQL Isolation Levels</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
